<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="/images/avatar1.webp">
  <title>java基础语法 | 行初雾</title>
  <meta name="author" content="行初雾" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="基础快捷键12345678910Ctrl+d    &#x2F;&#x2F;复制当前行到下一行Ctrl+Alt+I    &#x2F;&#x2F;自动对齐Ctrl+左键    &#x2F;&#x2F;查看文档Shift+点第一个和点最后一个    &#x2F;&#x2F;多选Alt+Insert    &#x2F;&#x2F;生成构造器Ctrl+H    &#x2F;&#x2F;继承关系Ctrl+Alt+T    &#x2F;&#x2F;将代码包在一个块中，例如try&#x2F;catchCtrl+B    &#x2F;&#x2F;看方法的源码Alt+7    &#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础语法">
<meta property="og:url" content="https://xingchuwu.github.io/2022/01/14/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/index.html">
<meta property="og:site_name" content="行初雾">
<meta property="og:description" content="基础快捷键12345678910Ctrl+d    &#x2F;&#x2F;复制当前行到下一行Ctrl+Alt+I    &#x2F;&#x2F;自动对齐Ctrl+左键    &#x2F;&#x2F;查看文档Shift+点第一个和点最后一个    &#x2F;&#x2F;多选Alt+Insert    &#x2F;&#x2F;生成构造器Ctrl+H    &#x2F;&#x2F;继承关系Ctrl+Alt+T    &#x2F;&#x2F;将代码包在一个块中，例如try&#x2F;catchCtrl+B    &#x2F;&#x2F;看方法的源码Alt+7    &#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xingchuwu.github.io/images/avatar1.webp">
<meta property="article:published_time" content="2022-01-14T11:24:01.000Z">
<meta property="article:modified_time" content="2022-01-14T11:42:56.429Z">
<meta property="article:author" content="行初雾">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xingchuwu.github.io/images/avatar1.webp">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://unpkg.com/nprogress@0.2.0/nprogress.css" type="text/css" media="all">
  
  
    <link rel="stylesheet" href="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.css">
  
  
    <link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://unpkg.com/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('/images/banner.webp');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('/images/bg.webp');
        }
      }
    
  </style>
  
<meta name="generator" content="Hexo 6.0.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                                    
                                        <li><a href="/friends/"><i class="fa fa-paw"></i>好伙伴</a></li>
                                    
                                
                                    
                                        <li>
                                            <a><i class="fa fa-link"></i>链接</a>
                                            <ul class="sub-menu">
                                                
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://candinya.com">作者博客</a></li>
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://github.com/Candinya/Kratos-Rebirth">项目链接</a></li>
                                                    
                                                
                                            </ul>
                                        </li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">行初雾</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>行初雾</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article>
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center">java基础语法</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><i class="fa fa-calendar"></i> 2022-01-14</li>
                <li><i class="fa fa-user"></i> 作者 行初雾</li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~116.92K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                本文最后编辑于 <time datetime="1642160576429"></time> 前，其中的内容可能需要更新。
            </div>
            
            <hr />
            <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+d    //复制当前行到下一行</span><br><span class="line">Ctrl+Alt+I    //自动对齐</span><br><span class="line">Ctrl+左键    //查看文档</span><br><span class="line">Shift+点第一个和点最后一个    //多选</span><br><span class="line">Alt+Insert    //生成构造器</span><br><span class="line">Ctrl+H    //继承关系</span><br><span class="line">Ctrl+Alt+T    //将代码包在一个块中，例如try/catch</span><br><span class="line">Ctrl+B    //看方法的源码</span><br><span class="line">Alt+7    //打开一个窗口，可以看到类的所有信息</span><br><span class="line">Alt    //多选</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">快捷键：Ctrl+/</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *文档注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h2><p>关键字：</p>
<table>
<thead>
<tr>
<th><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/abstract">abstract</a></th>
<th><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/assert">assert</a></th>
<th><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/boolean">boolean</a></th>
<th>break</th>
<th><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/byte">byte</a></th>
</tr>
</thead>
<tbody><tr>
<td>case</td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/catch">catch</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/char">char</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/class">class</a></td>
<td>const</td>
</tr>
<tr>
<td>continue</td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/default">default</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/do">do</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/double">double</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/else">else</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/enum">enum</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/extends">extends</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/final">final</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/finally">finally</a></td>
<td>float</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/for">for</a></td>
<td>goto</td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/if">if</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/implements">implements</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/import">import</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/instanceof">instanceof</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/int">int</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/interface">interface</a></td>
<td>long</td>
<td>native</td>
</tr>
<tr>
<td>new</td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/package">package</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/private">private</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/protected">protected</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/public">public</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/return">return</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/strictfp">strictfp</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/short">short</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/static">static</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/super">super</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/switch">switch</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/synchronized">synchronized</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/this">this</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/throw">throw</a></td>
<td>throws</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/transient">transient</a></td>
<td>try</td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/void">void</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/volatile">volatile</a></td>
<td><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/while">while</a></td>
</tr>
</tbody></table>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>强类型语言：要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用</p>
<p>java的数据类型分为两大类：</p>
<ol>
<li><p>基本数据类型：整数类型、浮点类型、字符类型、boolean类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//八大基本数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">byte</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">short</span> num3 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">long</span> num4 = <span class="number">30L</span>;<span class="comment">//Long类型要在数字后面加个L</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//小数：浮点数</span></span><br><span class="line"><span class="keyword">float</span> num5 = <span class="number">50.1F</span>; <span class="comment">//float类型要在数字后面加个F</span></span><br><span class="line"><span class="keyword">double</span> num6 = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符</span></span><br><span class="line"><span class="keyword">char</span> name = <span class="string">&#x27;常&#x27;</span>;</span><br><span class="line"><span class="comment">//字符串,String不是关键字，是类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔值：是非</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>引用数据类型：类、接口、数组</p>
</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">低 -------------------------------------&gt; 高</span><br><span class="line">byte,short,char-&gt; int-&gt; long-&gt; float-&gt; double</span><br><span class="line"></span><br><span class="line">运算中，不同数据类型的数据先转化为同一类型，然后进行运算</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//操作比较大的数的时候，注意溢出问题</span><br><span class="line">//JDK7新特性，数字之间可以用下划线分割</span><br><span class="line">int money = 10_0000_0000;</span><br><span class="line">int years = 20;</span><br><span class="line">int tota1 = money*years;//-1474836480,计算的时候溢出了</span><br><span class="line">int total2 = money*(long)years;//20000000000</span><br></pre></td></tr></table></figure>

<h2 id="变量、常量、作用域"><a href="#变量、常量、作用域" class="headerlink" title="变量、常量、作用域"></a>变量、常量、作用域</h2><p>变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    //类变量 static</span><br><span class="line">    static double salary = 2500;</span><br><span class="line"></span><br><span class="line">    //实例变量；从属于对象；</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //局部变量；必须声明和初始化值</span><br><span class="line">        int i = 10;</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">        //变量类型 变量名字 = new Hello();</span><br><span class="line">        Hello h = new Hello();</span><br><span class="line">        System.out.println(h.name);</span><br><span class="line">        System.out.println(h.age);</span><br><span class="line"></span><br><span class="line">        //类变量 static</span><br><span class="line">        System.out.println(salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量：用final来修饰</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final double PI = 3.14;</span><br><span class="line">//常量名一般用大写字母和下划线:MAX_VALUE</span><br><span class="line">//类名一般首字母大写+驼峰</span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>算数运算符：+，_，*，/，%，++，–</li>
<li>赋值运算符：=</li>
<li>关系运算符：&gt;，&lt;，&gt;=，&lt;=，==，!=，instanceof（判断是否是一个类的实例）</li>
<li>逻辑运算符：&amp;&amp;，||，！</li>
<li>位运算符：&amp;，|，~，&gt;&gt;，&lt;&lt;，&gt;&gt;&gt;</li>
<li>条件运算符：？：</li>
<li>扩展赋值运算符：+=，-=，*=，/=</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">幂运算</span><br><span class="line">double pow = Math.pow(2,3);</span><br></pre></td></tr></table></figure>

<h2 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h2><p>包语句的语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package pkg1[.pk2[.pkg3...]];</span><br></pre></td></tr></table></figure>

<p>一般利用公司域名倒置作为包名</p>
<p>导包用import语句</p>
<h2 id="javaDoc生成文档"><a href="#javaDoc生成文档" class="headerlink" title="javaDoc生成文档"></a>javaDoc生成文档</h2><p>jaovDoc命令用来生成自己的API文档</p>
<p>参数信息</p>
<ul>
<li>@author 作者名</li>
<li>@version 版本号</li>
<li>@since 指明需要最早使用的jdk版本</li>
<li>@param 参数</li>
<li>@return 返回值情况</li>
<li>@throws 异常抛光情况</li>
</ul>
<p>命令行生成文档：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc -encoding UTF-8 -charset UTF-8 Doc.java</span><br></pre></td></tr></table></figure>

<p>idea生成JavaDoc文档：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tools-&gt;Generate JavaDoc</span><br></pre></td></tr></table></figure>





<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="用户交互Scanner"><a href="#用户交互Scanner" class="headerlink" title="用户交互Scanner"></a>用户交互Scanner</h2><p>next():</p>
<ul>
<li>以空格为结束符</li>
<li>一定要读取到有效字符后才可以结束输入</li>
<li>next()不能得到带有空格的字符串</li>
</ul>
<p>nextLine():</p>
<ul>
<li>以Enter为结束符</li>
<li>可以获得空白</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//创建一个扫面器对象，用于接收键盘数据</span><br><span class="line">     Scanner scanner = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">     System.out.println(&quot;使用next方式接收：&quot;);</span><br><span class="line"></span><br><span class="line">     //判断用户有没有输入字符串</span><br><span class="line">     if(scanner.hasNext())&#123;</span><br><span class="line">         //使用next方式接收</span><br><span class="line">         String str = scanner.next();</span><br><span class="line">         System.out.println(&quot;输出的内容为：&quot;+str);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     System.out.println(&quot;使用nextLine方式接收：&quot;);</span><br><span class="line"></span><br><span class="line">     //判断用户有没有输入字符串</span><br><span class="line">     if(scanner.hasNextLine())&#123;</span><br><span class="line">         //使用next方式接收</span><br><span class="line">         String str = scanner.nextLine();</span><br><span class="line">         System.out.println(&quot;输出的内容为：&quot;+str);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     //凡是属于IO流的类如果不关闭会一直占用资源，用完就关</span><br><span class="line">     scanner.close();</span><br></pre></td></tr></table></figure>

<p>判断输入的是否是整数：scanner.has.NextInt()</p>
<p>判断输入的是否是小数：scanner.has.NextFloat()</p>
<h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>JAVA的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行</p>
<p>它是任何一个算法都离不开的一种基本算法结构</p>
<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式1)&#123;</span><br><span class="line"></span><br><span class="line">&#125;else if(布尔表达式2)&#123;</span><br><span class="line"></span><br><span class="line">&#125;else if(布尔表达式3)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch(expression)&#123;</span><br><span class="line"></span><br><span class="line">	case value:</span><br><span class="line">		//语句</span><br><span class="line">		break;</span><br><span class="line">	case value:</span><br><span class="line">		//语句</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		//语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">while(布尔表达式)&#123;</span><br><span class="line">	//循环内容</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do&#123;</span><br><span class="line">	//代码语句</span><br><span class="line">&#125;while(布尔表达式)</span><br><span class="line"></span><br><span class="line">for(初始化;布尔表达式;更新)&#123;</span><br><span class="line">	//代码语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int[] number = &#123;10,20,30,40,50&#125;;</span><br><span class="line"></span><br><span class="line">for(int x:number)&#123;</span><br><span class="line">	System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h2><ul>
<li><p>break在任何循环语句的主题部分，均可用break控制循环的流程。break用于强制退出循环</p>
</li>
<li><p>continue用于终止某次循环过程</p>
</li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Java方法是语句的集合，它们在一起执行一个功能</p>
<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
<p>设计方法的原则：最好保持方法的原子行，就是一个方法只完成1个功能，这样利于我们后期的扩展</p>
<h2 id="定义及调用"><a href="#定义及调用" class="headerlink" title="定义及调用"></a>定义及调用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 参数名）&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	方法名</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	return 返回值；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void max(int num1,int num2)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>重载就是在一个类中，有相同的函数名称，但形参不同的函数</p>
<p>规则：</p>
<ul>
<li>方法名称必须相同</li>
<li>参数列表必须不同（个数、类型、参数排列顺序等）</li>
<li>方法的返回类型可以相同也可以不相同</li>
<li>仅仅返回类型不同不足以成为方法的重载</li>
</ul>
<p>理论：方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，            如果匹配失败，则编译器保持。</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>JDK1.5开始，jav支持传递同类型的可变参数给一个方法</p>
<p>在方法声明中，在指定参数类型后加一个省略号(…)</p>
<p>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归：自己调用自己</p>
<p>递归结构：</p>
<ul>
<li>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环</li>
<li>递归体：什么时候调用自身方法</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li>数组是相同类型数据的有序集合</li>
<li>数组描述的是相同类型的若干数据，按照一定的先后次序排列组合而成</li>
<li>每一个数据称作一个数组元素，用下标来访问</li>
</ul>
<h2 id="数组声明创建"><a href="#数组声明创建" class="headerlink" title="数组声明创建"></a>数组声明创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dateType[] arrayRefVar;</span><br><span class="line">dateType[] arrayRefvar = new dataType[arraySize];</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//静态初始化</span><br><span class="line">int[] a = &#123;1,2,3&#125;;</span><br><span class="line">Man[] mans = &#123;new Man(),new Man()&#125;;</span><br><span class="line"></span><br><span class="line">//动态初始化</span><br><span class="line">int [] a = new int[2];</span><br><span class="line">a[0]=1;</span><br><span class="line">a[1]=2;</span><br></pre></td></tr></table></figure>

<h2 id="数组使用"><a href="#数组使用" class="headerlink" title="数组使用"></a>数组使用</h2><ul>
<li>普通的For循环</li>
<li>For-Each循环</li>
<li>数组作方法入参</li>
<li>数组作返回值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int array : arrays)&#123;</span><br><span class="line">	System.out.println(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] a = &#123;&#123;&#125;,&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>数组的工具类java.util.Arrays</p>
<ul>
<li>给数组赋值：fill</li>
<li>对数组排序：sort</li>
<li>比较数组：equals</li>
<li>查找数组元素：binarySearch</li>
</ul>
<h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><p>当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组</p>
<p>处理方式：</p>
<ul>
<li>记录数组一共有几行几列，有多少个不同的值</li>
<li>把具有不同值的元素和行列及值记录在一个小规模的数组中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int[][] array1 = new int[11][11];</span><br><span class="line">array1[1][2] = 1;</span><br><span class="line">array1[2][3] = 2;</span><br><span class="line"></span><br><span class="line">int sum = 0;</span><br><span class="line">for(int i = 0; i &lt; 11; i++)</span><br><span class="line">	for(int j = 0; j &lt; 11; j++)</span><br><span class="line">		if(array1[i][j] != 0)</span><br><span class="line">			sum++;</span><br><span class="line"></span><br><span class="line">int[][] array2 = new int[sum+1][3];</span><br><span class="line"></span><br><span class="line">array2[0][0] = 11;</span><br><span class="line">array2[0][1] = 11;</span><br><span class="line">array2[0][2] = sum;</span><br><span class="line"></span><br><span class="line">int count = 0;</span><br><span class="line">for(int i = 0; i &lt; array1.length; i++)</span><br><span class="line">	for(int j = 0; j &lt; array1.length; j++)</span><br><span class="line">		if(array1[i][j] != 0)&#123;</span><br><span class="line">			count++;</span><br><span class="line">			array2[count][0] = i;</span><br><span class="line">			array2[count][1] = j;</span><br><span class="line">			array2[count][2] = array1[i][j];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象思想：</p>
<ul>
<li>物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后才对某个分类下的细节进行面向过程的思索</li>
<li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题</li>
</ul>
<p>面向对象编程（Object-Oriented Programming,OOP）</p>
<p>面向对象编程的本质：以类的方式组织代码，以对象的组织（封装）数据</p>
<p>抽象</p>
<p>三大特性：</p>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><ol>
<li>和类名相同</li>
<li>没有返回值</li>
</ol>
<p>作用：</p>
<ol>
<li>new本质在调用构造方法</li>
<li>初始化对象的值</li>
</ol>
<p>注意点：</p>
<ol>
<li>定义有参构造后，如果想使用无参构造，显示的定义一个无参的构造</li>
</ol>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul>
<li>我们程序设计要追求”高内聚，低耦合“。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合就是仅暴露少量的方法给外部使用</li>
<li>封装（数据的隐藏）：通常应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问</li>
<li>属性私有，get/set</li>
</ul>
<p>好处：</p>
<ul>
<li>提高程序的安全性，保护数据</li>
<li>隐藏代码的实现细节</li>
<li>统一接口</li>
<li>系统可维护性增加</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模</li>
<li>extends的意思是”扩展“。子类是父类的扩展</li>
<li>JAVA中类只有单继承，没有多继承</li>
<li>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖。组合、聚合等</li>
<li>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示</li>
<li>在JAVA中，所有的类都默认直接或间接继承Object</li>
<li>私有的东西无法被继承</li>
</ul>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super注意点</p>
<ul>
<li>super调用父类的构造方法，必须在构造方法的第一个</li>
<li>super必须只能出现在子类的方法或者构造方法中</li>
<li>super和this不能同时调用构造方法</li>
</ul>
<p>Vs this：</p>
<ul>
<li><p>代表的对象不同</p>
<ul>
<li>this：本身调用者这个对象</li>
<li>super：代表父类对象的应用</li>
</ul>
</li>
<li><p>前提</p>
<ul>
<li>this：没有继承也可以使用</li>
<li>super：只能在继承条件才可以使用</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li>this（）：本来的构造</li>
<li>super（）：父类的构造</li>
</ul>
</li>
</ul>
<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>重写都是方法的重写，和属性无关</p>
<p>需要有继承关系，子类重写父类的方法</p>
<p>子类的方法和子类必须一致，方法体不同</p>
<ul>
<li>方法名必须相同</li>
<li>参数列表必须相同</li>
<li>修饰符：范围可以扩大不能缩小    public&gt;Protect&gt;Default&gt;private</li>
<li>抛出的异常：范围，可以被缩小，不能扩大：ClassNotFoundException –&gt; Exception(大)</li>
</ul>
<p>为什么需要重写：</p>
<ul>
<li>父类的功能，子类不一定需要，或不一定满足</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li> 多态即同一方法可以根据发送对象的不同而采用多种不同的行为方式</li>
<li>一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多（父类，有关系的类）</li>
<li>多态存在的条件<ul>
<li>有继承关系</li>
<li>子类重写父类方法</li>
<li>父类引用指向子类对象</li>
</ul>
</li>
<li>注意：多态是方法的多态，属性没有多态性</li>
<li>把子类转换为父类，向上转型</li>
<li>把父类转换为子类，向下转型    强制转换</li>
<li>方便方法的调用，减少重复的代码 简洁</li>
</ul>
<p>instanceof 判断一个对象是什么类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student s = new Student();</span><br><span class="line">System.out.println(s instanceof Student);    //true</span><br></pre></td></tr></table></figure>

<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>abstract，抽象方法，只要方法名字，没有方法实现</p>
<ul>
<li>不能new这个抽象类，只能靠子类去实现它；约束！</li>
<li>抽象类中可以写普通的方法</li>
<li>抽象方法必须在抽象类中</li>
<li>抽象的抽象：约束</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>普通类：只有具体实现</li>
<li>抽象类：具体实现和规范（抽象方法）都有</li>
<li>接口：只有规范</li>
</ul>
<p>OO的精髓，是对对象的抽象，最能体现这一点的就是接口。</p>
<p>声明接口的关键字是interface</p>
<p>实现接口用implements</p>
<p>接口不能被实例化，接口中没有构造方法</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>在一个类的内部定义一个类</p>
<ul>
<li>成员内部类</li>
<li>静态内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ul>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul>
<li><p>异常（Exception）指程序运行中出现的不期而至的各种状况，如：文件找不到，网络连接错误，非法参数等</p>
</li>
<li><p>异常发生在程序运行期间，它影响了正常的程序执行流程</p>
</li>
<li><p>检查性移仓：最具代表的检查性异常是用户错误或问题引起的异常</p>
</li>
<li><p>运行时异常：是可能被程序员避免的异常</p>
</li>
<li><p>错误：错误不是异常，而是脱离程序员控制的问题</p>
</li>
</ul>
<h2 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h2><ul>
<li>java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类</li>
<li>在Java API中已经定义了许多异常类，常分为两大类，错误Error和异常Exception</li>
</ul>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><ul>
<li>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关</li>
<li>Java虚拟机运行错误，当JVM不再有继续执行操作所需的内存资源是，将出现OutOfMemoryError。这些异常发生时，JVM一般会选择线程终止</li>
<li>还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError），连接错误（LinkageError）。</li>
</ul>
<h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><ul>
<li>在Exception分支中有一个重要的子类RuntimeException（运行时异常）<ul>
<li>ArrayIndexOutOfBoundsException（数组小标越界）</li>
<li>NullPointerException（空指针异常）</li>
<li>ArithmeticException（算术异常）</li>
<li>MissingResourceException（丢失资源）</li>
<li>ClassNotFoundException（找不到类）</li>
</ul>
</li>
<li>这些异常一般时由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生</li>
<li>Error和Exception的区别：Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，JVM一般会选择终止线程。Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</li>
</ul>
<h2 id="捕获、抛出异常"><a href="#捕获、抛出异常" class="headerlink" title="捕获、抛出异常"></a>捕获、抛出异常</h2><ul>
<li>抛出异常</li>
<li>捕获异常</li>
<li>异常处理五个关键字：try、catch、finally、throw、throws</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class text &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = 0;</span><br><span class="line"></span><br><span class="line">		//捕获多个异常：从小到大</span><br><span class="line">        try &#123;//try监控区域</span><br><span class="line">            System.out.println(a / b);</span><br><span class="line">        &#125;catch(Error e)&#123;//catch（想要捕获的异常类型！）捕获异常</span><br><span class="line">            System.out.println(&quot;Error&quot;);</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;Exception&quot;);</span><br><span class="line">        &#125;catch(Throwable e)&#123;</span><br><span class="line">            System.out.println(&quot;Throwable&quot;);</span><br><span class="line">        &#125; finally&#123;</span><br><span class="line">            System.out.println(&quot;finally&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class text &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            new text().test(1,0);</span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void test(int a,int b) throws ArithmeticException&#123;</span><br><span class="line">        if(b==0)&#123;</span><br><span class="line">            throw new ArithmeticException();//主动抛出异常，一般在方法中使用</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    static void test(int a)throws MyException&#123;</span><br><span class="line">        System.out.println(&quot;传递的参数为：&quot;+a);</span><br><span class="line"></span><br><span class="line">        if(a&gt;10)&#123;</span><br><span class="line"></span><br><span class="line">                throw new MyException(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;OK&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            test(11);</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyException extends Exception&#123;</span><br><span class="line"></span><br><span class="line">    //传递数字&gt;10</span><br><span class="line">    private int detail;</span><br><span class="line"></span><br><span class="line">    public MyException(int x) &#123;</span><br><span class="line">        this.detail=x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyException&#123;&quot; +</span><br><span class="line">                &quot;detail=&quot; + detail +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理</li>
<li>在多重catch快后面，可以加一个catch(Exception)来处理可能会被遗漏的异常</li>
<li>对应不确定的代码，也可以加上try-catch，处理潜在的异常</li>
<li>尽量去处理异常，切忌只是简单地调用PrintStackTrace（）去打印输出</li>
<li>具体如何处理异常，要根据不同的业务需求和异常类型去决定</li>
<li>尽量添加finally语句块去释放占用的资源</li>
</ul>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><p><img src="E:\TyporaReport\java\image\常用类1.png" alt="常用类"></p>
<p><img src="E:\TyporaReport\java\image\常用类2.png" alt="常用类"></p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul>
<li>针对八种基本数据类型相应的引用类型—-包装类</li>
<li>有了类的特点，就可以调用类中的方法</li>
</ul>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
<th>父类</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
<td>Object</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
<td>Object</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
<td>Number</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>Number</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
<td>Number</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
<td>Number</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>Number</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>Number</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    //jak5之前，手动装箱和手动拆箱</span><br><span class="line">    int n1 = 100;</span><br><span class="line">    Integer integer = new Integer(n1);</span><br><span class="line">    Integer integer1 = Integer.valueOf(n1);</span><br><span class="line">    </span><br><span class="line">    int i = integer.intValue();</span><br><span class="line">    </span><br><span class="line">    //jdk5后，就可以自动装箱和自动拆箱</span><br><span class="line">    int n2 = 200;</span><br><span class="line">    //自动装箱 int-&gt;Integer</span><br><span class="line">    Integer integer2 = n2;</span><br><span class="line">    //自动拆箱 Integer-&gt;int</span><br><span class="line">    int n3 = integer2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包装类与String互转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//包装类（Integer）-&gt;String</span><br><span class="line">Integer i = 100;</span><br><span class="line">//方式1</span><br><span class="line">String str1 = i + &quot;&quot;;</span><br><span class="line">//方式2</span><br><span class="line">String str2 = i.toString();</span><br><span class="line">//方式3</span><br><span class="line">String str3 = String.valueOf(i);</span><br><span class="line"></span><br><span class="line">//String -&gt; 包装类(Integer)</span><br><span class="line">String str4 = &quot;123456&quot;;</span><br><span class="line">Integer i2 = Integer.parseInt(str4);</span><br><span class="line">Integer i3 = new Integer(str4);</span><br></pre></td></tr></table></figure>

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul>
<li>字符串不可变，他们的值在创建后不能被更改</li>
<li>String的值不可变，但是它们可以被共享</li>
</ul>
<p>构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String();    //初始化新创建的 String对象，使其表示空字符序列。</span><br><span class="line"></span><br><span class="line">char[] chs = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span><br><span class="line">String s2 = new String(chs);    //根据字符数组的内容来创建字符串对象</span><br><span class="line"></span><br><span class="line">byte[] bys = &#123;97,98,99&#125;;</span><br><span class="line">String s3 = new String(bys);    //根据字节数组的内容来创建字符串对象</span><br><span class="line"></span><br><span class="line">String s4 = &quot;abc&quot;;    //直接赋值的方式创建字符串对象</span><br></pre></td></tr></table></figure>

<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>使用==做比较</p>
<ul>
<li>基本类型：比较的是数据值是否相同</li>
<li>引用类型：比较的是地址值是否相同</li>
</ul>
<p>字符串是对象，它比较内容是否相同，是用equals()比较多</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String name = &quot;xingchuwu&quot;;</span><br><span class="line">        String password = &quot;123456&quot;;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        String name1;</span><br><span class="line">        String password1;</span><br><span class="line">        for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.print(&quot;请输入用户名：&quot;);</span><br><span class="line">            name1 = scanner.nextLine();</span><br><span class="line">            System.out.print(&quot;请输入密码：&quot;);</span><br><span class="line">            password1 = scanner.nextLine();</span><br><span class="line">            if(name1.equals(name) &amp;&amp; password1.equals(password))&#123;</span><br><span class="line">                System.out.println(&quot;登录成功！&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if(i==2) &#123;</span><br><span class="line">                System.out.println(&quot;您的账号已被锁定！&quot;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                    System.out.println(&quot;登录失败！你还有&quot; + (2-i) + &quot;次机会&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串遍历"><a href="#字符串遍历" class="headerlink" title="字符串遍历"></a>字符串遍历</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String line = sc.nextLine();</span><br><span class="line">        for(int i=0;i&lt;line.length();i++)&#123;</span><br><span class="line">            System.out.println(line.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。</p>
<p>toCharArray()：把字符串转变成字符数组</p>
<p>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。</p>
<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>可变长字符串，JDK1.0提供，运行效率慢、线程安全</p>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>可变长字符串，JDK5.0提供，运行效率快、线程不安全</p>
<p>如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，即耗时又浪费内存空间。</p>
<p>StringBuilder是一个可变的字符串类，可以把它看成是一个容器</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//创建一个空白可变字符串对象，不含任何内容</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">System.out.println(&quot;sb:&quot;+sb);</span><br><span class="line">System.out.println(&quot;sb.length():&quot;+sb.length());</span><br><span class="line"></span><br><span class="line">//根据字符串的内容，来创建可变字符串对象</span><br><span class="line">StringBuilder sb2 = new StringBuilder(&quot;hello&quot;);</span><br><span class="line">System.out.println(&quot;sb2:&quot;+sb2);</span><br><span class="line">System.out.println(&quot;sb2.length():&quot;+sb2.length());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="添加和反转"><a href="#添加和反转" class="headerlink" title="添加和反转"></a>添加和反转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line"></span><br><span class="line">        //public StringBuilder append(任意类型); 添加数据，返回对象本身</span><br><span class="line">//        sb.append(&quot;hello&quot;);</span><br><span class="line">//        sb.append(&quot; &quot;);</span><br><span class="line">//        sb.append(&quot;world&quot;);</span><br><span class="line"></span><br><span class="line">        //链式编程</span><br><span class="line">        sb.append(&quot;hello&quot;).append(&quot; &quot;).append(&quot;world&quot;);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">		</span><br><span class="line">		//public StringBuilder reverse(); 返回相反的字符序列</span><br><span class="line">        sb.reverse();</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StringBuilder和String相互转换"><a href="#StringBuilder和String相互转换" class="headerlink" title="StringBuilder和String相互转换"></a>StringBuilder和String相互转换</h3><ul>
<li>StringBuilder –&gt; String：通过toString()</li>
<li>String –&gt; tringBuilder：通过构造方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">String s = sb.toString;</span><br><span class="line"></span><br><span class="line">StringBuilder sb1 = new StringBuilder(s);</span><br></pre></td></tr></table></figure>

<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//public Date();分配一个Date对象，并初始化，以便它代表它被分配的时间，精确的毫秒</span><br><span class="line">   Date d1 = new Date();</span><br><span class="line">       System.out.println(d1);    //Sun Dec 26 23:28:48 CST 2021</span><br><span class="line"></span><br><span class="line">       //public Date(long date); 分配一个Date对象，并将其初始化为便是从标准基准时间起指定的毫秒数</span><br><span class="line">       long date = 1000*60*60;</span><br><span class="line">       Date d2 = new Date(date);</span><br><span class="line">       System.out.println(d2);    //Thu Jan 01 09:00:00 CST 1970</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Date d = new Date();</span><br><span class="line">//public long getTime();获取的是日期对象从1970年1月1日 00：00：00到现在的毫秒值。</span><br><span class="line">System.out.println(d.getTime());</span><br><span class="line"></span><br><span class="line">//public void setTime(long time);设置时间，给的时毫秒值。</span><br><span class="line">long time = System.currentTimeMillis();//当前时间</span><br><span class="line">d.setTime(time);</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure>

<h2 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h2><p>SimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期</p>
<p>日期和时间格式由日期和时间模式字符串指定，其中，从’A’到’Z’以及从’a’到’z’引号的字母被解释为表示日期或时间字符串的组件的模式字母</p>
<p>常用的模式字母及对应关系如下：</p>
<ul>
<li>y                年</li>
<li>M               月</li>
<li>d                日</li>
<li>H                时</li>
<li>m               秒</li>
<li>s                 分</li>
</ul>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//格式化，从Date到String</span><br><span class="line">//public final String format(Date date);将日期格式化成日期/时间字符串</span><br><span class="line">Date d = new Date();</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat();</span><br><span class="line">String s = sdf.format(d);</span><br><span class="line">System.out.println(s);//21-12-27 上午12:53</span><br><span class="line"></span><br><span class="line">SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);</span><br><span class="line">String s1 = sdf1.format(d);</span><br><span class="line">System.out.println(s1);//2021年12月27日 00:53:06</span><br><span class="line"></span><br><span class="line">//解析：从String到Date</span><br><span class="line">//public Date parse(String source);从给定的字符串开始解析文本以生成日期</span><br><span class="line">String s2 = &quot;2016-12-13 05:02:01&quot;;</span><br><span class="line">SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">Date d2 = sdf2.parse(s2);</span><br><span class="line">System.out.println(d2);//Tue Dec 13 05:02:01 CST 2016</span><br></pre></td></tr></table></figure>

<h2 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h2><p>Calendar为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//Calendar提供了一个类方法getInstance用于获取Calendar对象，其日历字段已实验当前日期和时间初始化</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">//public int get(int field);返回给定日历字段的值</span><br><span class="line">int year = c.get(Calendar.YEAR);</span><br><span class="line">int month = c.get(Calendar.MONTH) + 1;</span><br><span class="line">int date = c.get(Calendar.DATE);</span><br><span class="line">System.out.println(year + &quot;年&quot; + month + &quot;月&quot; + date + &quot;日&quot;);</span><br><span class="line"></span><br><span class="line">//public abstract void add(int field,int amount);根据日历的规则，将指定的时间量添加或减去给定的日历字段</span><br><span class="line">//10年前的5天后</span><br><span class="line">c.add(Calendar.YEAR,-10);</span><br><span class="line">c.add(Calendar.DATE,5);</span><br><span class="line">int year = c.get(Calendar.YEAR);</span><br><span class="line">int month = c.get(Calendar.MONTH) + 1;</span><br><span class="line">int date = c.get(Calendar.DATE);</span><br><span class="line">System.out.println(year + &quot;年&quot; + month + &quot;月&quot; + date + &quot;日&quot;);</span><br><span class="line"></span><br><span class="line">//public final void set(int year,int month,int date);设置当前日历的年月日</span><br><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line">c1.set(2016,11,13);</span><br><span class="line">int year1 = c1.get(Calendar.YEAR);</span><br><span class="line">int month1 = c1.get(Calendar.MONTH)+1;</span><br><span class="line">int date1 = c1.get(Calendar.DATE);</span><br><span class="line">System.out.println(year1 + &quot;年&quot; + month1 + &quot;月&quot; + date1 + &quot;日&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">      Scanner sc = new Scanner(System.in);</span><br><span class="line">      System.out.println(&quot;请输入年份：&quot;);</span><br><span class="line">      int year = sc.nextInt();</span><br><span class="line"></span><br><span class="line">      Calendar c = Calendar.getInstance();</span><br><span class="line">      c.set(year,2,1);</span><br><span class="line">      c.add(Calendar.DATE,-1);</span><br><span class="line">      int date = c.get(Calendar.DATE);</span><br><span class="line">      System.out.println(year + &quot;年的2月份有&quot; + date + &quot;天&quot;);</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      //请输入年份：</span><br><span class="line">//2016</span><br><span class="line">//2016年的2月份有29天</span><br></pre></td></tr></table></figure>

<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合类的特点：提供一种存储空间可变的存储模型，存储的数据容量可以发生改变</p>
<p><img src="E:\TyporaReport\java\image\集合体系.png" alt="集合体系"></p>
<p><img src="E:\TyporaReport\java\image\集合框架1.png" alt="集合"></p>
<p><img src="E:\TyporaReport\java\image\集合框架2.png" alt="集合"></p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList<E>:</p>
<ul>
<li>可调整大小的数组实现</li>
<li><E>：是一种特殊的数据类型，泛型</li>
</ul>
<h3 id="构造和添加方法"><a href="#构造和添加方法" class="headerlink" title="构造和添加方法"></a>构造和添加方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayListDemo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //public ArrayList();创建一个空的集合对象</span><br><span class="line">        ArrayList&lt;String&gt; array= new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        //public boolean add(E e);将指定的元素追加到此集合的末尾</span><br><span class="line">        array.add(&quot;hello&quot;);</span><br><span class="line">        array.add(&quot;world&quot;);</span><br><span class="line">        array.add(&quot;java&quot;);</span><br><span class="line"></span><br><span class="line">        //public void add(int index,E element)；在此集合中的指定位置插入指定的元素</span><br><span class="line"></span><br><span class="line">        array.add(1,&quot;javase&quot;);</span><br><span class="line">        System.out.println(&quot;arrat:&quot; + array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>public boolean remove(Object o);删除指定的元素，返回删除是否成功</p>
<p>public E remove(int index);删除指定索引处的元素，返回被删除的元素</p>
<p>public E set(int index,E element);修改指定索引处的元素，返回被修该的元素</p>
<p>public E get(int index);返回指定索引处的元素</p>
<p>public int size();返回集合中的元素的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayListDemo02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建一个空的集合对象</span><br><span class="line">        ArrayList&lt;String&gt; array= new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        //添加元素</span><br><span class="line">        array.add(&quot;hello&quot;);</span><br><span class="line">        array.add(&quot;world&quot;);</span><br><span class="line">        array.add(&quot;java&quot;);</span><br><span class="line"></span><br><span class="line">        //public boolean remove(Object o);删除指定的元素，返回删除是否成功</span><br><span class="line">//        System.out.println(array.remove(&quot;world&quot;));</span><br><span class="line">//        System.out.println(array.remove(&quot;world&quot;));</span><br><span class="line"></span><br><span class="line">        //public E remove(int index);删除指定索引处的元素，返回被删除的元素</span><br><span class="line">        System.out.println(array.remove(1));</span><br><span class="line"></span><br><span class="line">        //public E set(int index,E element);修改指定索引处的元素，返回被修该的元素</span><br><span class="line">        System.out.println(array.set(1,&quot;javaee&quot;));</span><br><span class="line"></span><br><span class="line">        //public E get(int index);返回指定索引处的元素</span><br><span class="line">        System.out.println(array.get(0));</span><br><span class="line">        System.out.println(array.get(1));</span><br><span class="line">       // System.out.println(array.get(2));</span><br><span class="line"></span><br><span class="line">        //public int size();返回集合中的元素的个数</span><br><span class="line">        System.out.println(array.size());</span><br><span class="line">        </span><br><span class="line">        //输出集合</span><br><span class="line">        System.out.println(&quot;arrat:&quot; + array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>集合概述：</p>
<ul>
<li>是单例集合的顶层接口，它表示一组对象，这些对象也被称为Collection的元素</li>
<li>JDK不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List）实现</li>
</ul>
<p>创建Collection集合的对象</p>
<ul>
<li>多态的方式</li>
<li>具体的实现类ArrayList</li>
</ul>
<h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//创建Collection集合的对象，通过多态的方式，ArrayList()</span><br><span class="line">Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">//添加元素：boolean add (E e)</span><br><span class="line">c.add(&quot;hello&quot;);</span><br><span class="line">c.add(&quot;hello1&quot;);</span><br><span class="line">c.add(&quot;hello2&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(c);</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>boolean add(E e)    //添加元素</li>
<li>boolean remove(Object o)    //从该集合中删除指定元素</li>
<li>void clear()    //清空集合中的元素</li>
<li>boolean contains(Object o)    //判断集合中是否存在指定的元素</li>
<li>boolean isEmpty()    //判断集合是否为空</li>
<li>int size()    //集合的长度，也就是集合中元素的个数</li>
</ul>
<h3 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h3><p>Iterator：迭代器，集合的专用遍历方式</p>
<ul>
<li>Iterator<E> iterator();    返回此集合中元素的迭代器，通过集合的iterator()方法得到</li>
<li>迭代器是通过集合的iterator()方法得到的，所以我们说它是依赖于集合而存在的</li>
</ul>
<p>Iterator中的常用方法：</p>
<ul>
<li>E next();    返回迭代中的下一个元素</li>
<li>boolean hasNext();    如果迭代具有更多元素，则返回true</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">      c.add(&quot;hello1&quot;);</span><br><span class="line">      c.add(&quot;hello2&quot;);</span><br><span class="line">      c.add(&quot;hello3&quot;);</span><br><span class="line"></span><br><span class="line">      Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line"></span><br><span class="line">      while(it.hasNext())&#123;</span><br><span class="line">          System.out.println(it.next());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List集合概述</p>
<ul>
<li>有序集合（也称为<em>序列</em> ）。 该界面的用户可以精确控制列表中每个元素的插入位置。 用户可以通过整数索引（列表中的位置）访问元素，并搜索列表中的元素。</li>
<li>与Set集合不同，列表通常允许重复的元素。</li>
</ul>
<p>List集合特点</p>
<ul>
<li>有序：存储和取出的元素顺序一致</li>
<li>可重复：存储的元素可以重复</li>
</ul>
<h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(&quot;hello&quot;);</span><br><span class="line">        list.add(&quot;hello&quot;);</span><br><span class="line">        list.add(&quot;hello&quot;);</span><br><span class="line">        list.add(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>void add(int index,E element)    在此集合中的指定位置插入指定的元素</li>
<li>E remove(int index)    删除指定索引处的元素，返回被删除的元素</li>
<li>E set(int index,E element)    修改指定索引处的元素，返回被修改的元素</li>
<li>E get(int index)  返回指定索引处的元素</li>
</ul>
<h3 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h3><ul>
<li><p>并发修改异常（ConcurrentModificationException）</p>
</li>
<li><p>原因：迭代器遍历过程中，通过集合对象修改了集合中元素的长度，导致了迭代器获取元素中判断预期修改值和实际修改值不一致</p>
</li>
<li><p>解决方案：用for循环遍历，然后用集合对象做对应的操作即可</p>
</li>
</ul>
<h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p>ListItertor：列表迭代器</p>
<ul>
<li>通过List集合的listIterator()方法得到，所以说它是List集合特意的迭代器</li>
<li>用于允许程序员沿任一方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置</li>
</ul>
<p>ListIterator中的常用方法：</p>
<ul>
<li>E next()：返回迭代中的下一个元素</li>
<li>boolean hasNext()：如果迭代具有更多元素，则返回true</li>
<li>E previous()：返回列表中的上一元素</li>
<li>boolean hasPrevious()：如果此列表迭代器在相反方向遍历列表时具有更多元素，则返回true</li>
<li>void add(E e)：将指定的元素插入列表</li>
</ul>
<h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p>增强for：简化数组和Collection集合的遍历</p>
<ul>
<li>实现Iterable接口的类允许其对象成为增强型语句的目标</li>
<li>它时JDK5之后出现的，其内部原理是一个Iterrator迭代器</li>
</ul>
<p>增强for的格式</p>
<ul>
<li>格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素数据类型 变量名 : 数组或者Collection集合)&#123;</span><br><span class="line">	//在此处使用变量即可，该变量就是元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>范例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = &#123;1,2,3,4&#125;;</span><br><span class="line">for(int i : arr)&#123;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;hello&quot;);</span><br><span class="line">list.add(&quot;hello2&quot;);</span><br><span class="line">list.add(&quot;hello3&quot;);</span><br><span class="line"></span><br><span class="line">for(String s : list)&#123;</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List集合子类"><a href="#List集合子类" class="headerlink" title="List集合子类"></a>List集合子类</h3><p>List集合常用子类：ArrayList、LinkedList</p>
<ul>
<li>ArrayList：底层数据结构是数组，查询快，增删慢</li>
<li>LinkedList：底层数据结构是链表，查询慢，增删快</li>
</ul>
<h4 id="LinkedList集合的特有功能"><a href="#LinkedList集合的特有功能" class="headerlink" title="LinkedList集合的特有功能"></a>LinkedList集合的特有功能</h4><ul>
<li>public void addFirst(E e);    在该列表开头插入指定的元素</li>
<li>public void addLast(E e);    将指定的元素追加到此列表的末尾</li>
<li>public E getFirst();    返回此列表中的第一个元素</li>
<li>public E getLast();    返回此列表中的最后一个元素</li>
<li>public E removeFirst();    从此列表中欧给删除并返回第一个元素</li>
<li>public E removeLast();    从此列表中欧给删除并返回最后一个元素</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>set集合特点</p>
<ul>
<li>不包含重复元素的集合</li>
<li>没有带索引的方法，所以不能使用普通for循环遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = new HashSet&lt;String&gt;();</span><br><span class="line">set.add(&quot;hello1&quot;);</span><br><span class="line">set.add(&quot;hello2&quot;);</span><br><span class="line">set.add(&quot;hello3&quot;);</span><br><span class="line">for(String s : set)&#123;</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h3><p>哈希值：是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值</p>
<p>Object类中有一个方法可以获取对象的哈希值</p>
<ul>
<li>Public int hashCode();    返回对象的哈希码值</li>
</ul>
<p>对象的哈希值特点</p>
<ul>
<li>同一个对象多次调用hashCode()方法返回的哈希值是相同的</li>
<li>默认情况下，不同对象的哈希值是不同的，而重写hasCode()方法，可以使其相同</li>
</ul>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>集合特点</p>
<ul>
<li>底层数据结构使哈希表</li>
<li>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致</li>
<li>没有带索引的方法，所以不能使用普通for循环遍历</li>
<li>由于是Set集合，所以不包含重复元素</li>
</ul>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet集合概述和特点</p>
<ul>
<li>哈希表和链表实现的Set接口，具有可预测的迭代次序</li>
<li>由链表保证元素有序，也就是说元素的存储和取出顺序一致</li>
<li>由哈希表保证元素唯一，也就是说没有重复的元素</li>
</ul>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet集合特点</p>
<ul>
<li>元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方法取决于构造方法<ul>
<li>TreeSet();     根据其元素的自然排序进行排序</li>
<li>TreeSet(Comparator comparator);    根据指定的比较器进行排序</li>
</ul>
</li>
<li>没有带索引的方法，所以不能使用普通的for循环遍历</li>
<li>由于是Set集合，所以不包含重复元素的集合</li>
</ul>
<h4 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h4><ul>
<li>用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的</li>
<li>自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法</li>
<li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public int compareTo(Student s)&#123;</span><br><span class="line">	int num = this.age - s.age;</span><br><span class="line">	int num2 = num == 0?this.name.compareTo(s.name):num;</span><br><span class="line">	return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;()&#123;</span><br><span class="line">	public int compare(Student s1,Student s2)&#123;</span><br><span class="line">		int num = s1.getAge() - s2.getAge();</span><br><span class="line">    	int num2 = num == 0?s1.getName().compareTo(s2.getName()):num;</span><br><span class="line">    	return num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型：是JDK5中引入的特性，它提供了编译时类型安全检测机制，该极致允许在编译时检测到非法的类型</p>
<p>它的本质时参数化类型，也就是说所操作的数据类型被指定为一个参数</p>
<p>泛型定义格式：</p>
<ul>
<li>&lt;类型&gt;：指定一种类型的格式。这里的类型可以看成是形参</li>
<li>&lt;类型1，类型2…&gt;：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成事形参</li>
<li>将来具体调用时给定的类型可以看成事实参，并且实参的类型只能是引用数据类型</li>
</ul>
<p>泛型的好处：</p>
<ul>
<li>把运行时期的问题提前到了编译期间</li>
<li>避免了强制类型转换</li>
</ul>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类的定义格式：</p>
<ul>
<li>格式：修饰符 class 类名 &lt;类型&gt;{}</li>
<li>范例：public class Generic<T>{}    <ul>
<li>此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Generic&lt;T&gt; &#123;</span><br><span class="line">    private T t;</span><br><span class="line"></span><br><span class="line">    public T getT() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setT(T t) &#123;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class GenericDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Generic&lt;String&gt; g1 = new Generic&lt;&gt;();</span><br><span class="line">        g1.setT(&quot;xingchuwu&quot;);</span><br><span class="line">        System.out.println(g1.getT());</span><br><span class="line"></span><br><span class="line">        Generic&lt;Integer&gt; g2 = new Generic&lt;&gt;();</span><br><span class="line">        g2.setT(100);</span><br><span class="line">        System.out.println(g2.getT());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法的定义格式：</p>
<ul>
<li>格式：修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名){}</li>
<li>范例：public <T> void show(T t){}</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Generic&#123;</span><br><span class="line">   public &lt;T&gt; void show(T t)&#123;</span><br><span class="line">   	   System.out.println(t);	</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class GenericDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Generic g = new Generic();</span><br><span class="line">        g.show(&quot;xingchuwu&quot;);</span><br><span class="line">        g.show(100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口的定义格式：</p>
<ul>
<li>格式：修饰符 interface 接口名&lt;类型&gt;{} </li>
<li>范例：public interface Generic<T>{}</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Generic1&lt;T&gt; &#123;</span><br><span class="line">    void show(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class GenericImpl&lt;T&gt; implements Generic1&lt;T&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show(T t) &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class GenericDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GenericImpl&lt;String&gt; g = new GenericImpl&lt;&gt;();</span><br><span class="line">        g.show(&quot;xingchuwu&quot;);</span><br><span class="line"></span><br><span class="line">        GenericImpl&lt;Integer&gt; g1 = new GenericImpl&lt;&gt;();</span><br><span class="line">        g1.show(100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><p>为了表示各种泛型List的父类，可以使用类型通配符</p>
<ul>
<li>类型通配符：&lt;?&gt;</li>
<li>List&lt;?&gt;：表示元素类型未知的List，它的元素可以匹配任何的类型</li>
<li>这种带通配符的List仅代表它是各种泛型List的父类，并不能把元素添加到其中</li>
</ul>
<p>如果说我们不希望List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限</p>
<ul>
<li>类型通配符上限：&lt;? extends 类型&gt;</li>
<li>List&lt;? extends Number&gt;：它表示的类型是Number或者其子类型</li>
</ul>
<p>除了可以指定类型通配符的上限，我们也可以指定其下限</p>
<ul>
<li>类型通配符下限：&lt;? super 类型&gt;</li>
<li>List&lt;? super Number&gt;：它表示的类型是Number或者其父类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list1 = new ArrayList&lt;Object&gt;();</span><br><span class="line">      List&lt;?&gt; list2 = new ArrayList&lt;Number&gt;();</span><br><span class="line">      List&lt;?&gt; list3 = new ArrayList&lt;Integer&gt;();</span><br><span class="line">      </span><br><span class="line">      List&lt;? extends Number&gt; list4 = new ArrayList&lt;Number&gt;();</span><br><span class="line">      List&lt;? extends Number&gt; list5 = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">      List&lt;? super  Number&gt; list6 = new ArrayList&lt;Object&gt;();</span><br><span class="line">      List&lt;? super  Number&gt; list7 = new ArrayList&lt;Number&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="可变参数-1"><a href="#可变参数-1" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数又称参数个数可变，用作方法的形参出现，那么方法的参数个数就是可变的了</p>
<ul>
<li>格式：修饰符 返回值类型 方法名(数据类型…变量名){}</li>
<li>范例：public static int sum(int…a){}</li>
</ul>
<p>注意事项：</p>
<ul>
<li>这里的变量其实是一个数组</li>
<li>如果一个方法有多个参数，包含可变参数，可变参数要放在最后</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ArgsDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(sum(10,20));</span><br><span class="line">        System.out.println(sum(10,20,30));</span><br><span class="line">        System.out.println(sum(10,20,30,40));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int sum (int...a)&#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i : a)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可变参数的使用"><a href="#可变参数的使用" class="headerlink" title="可变参数的使用"></a>可变参数的使用</h3><p>Arrays工具类中有一个静态方法：</p>
<ul>
<li>public static <T> List<T> asList(T…a);    返回由指定数组支持的固定大小的列表</li>
<li>返回的集合不能做增删操作，可以做修改操作</li>
</ul>
<p>List接口中有一个静态方法：</p>
<ul>
<li>public static <E> List<T> of(E…elements);    返回包含任意数量元素的不可变列表</li>
<li>返回的集合不能做增删改操作</li>
</ul>
<p>Set接口中有一个静态方法：</p>
<ul>
<li>public static <E> Set<T> of(E…elements);    返回一个包含任意数量元素的不可变集合</li>
<li>返回的集合不能做增删操作，没有修改的方法</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map集合概述：</p>
<ul>
<li>Interface Map&lt;K,V&gt;    K：健的类型；V：值的类型</li>
<li>将健映射到值的对象；不能包含重复的健；每个健可以映射到最多一个值</li>
<li>举例：学生的学号和姓名</li>
</ul>
<p>创建Map集合的对象：</p>
<ul>
<li>多态的方式</li>
<li>具体的实现类HashMap</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MapDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(&quot;xingchuwu&quot;,&quot;qianxiyun&quot;);</span><br><span class="line">        map.put(&quot;52&quot;,&quot;1213&quot;);</span><br><span class="line">        map.put(&quot;52&quot;,&quot;121399&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>V put(K key,V value);    添加元素</li>
<li>V remove(Object key);    根据健删除键值对元素</li>
<li>void clear();    移除所有的键值对元素</li>
<li>boolean containsKey(Object key);    判断集合中是否包含指定的健</li>
<li>boolean containsValue(Object value);    判断集合中是否包含指定的值</li>
<li>boolean isEmpty();    判断集合是否为空</li>
<li>int size();    集合长度，也就是集合中键值对的个数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MapDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(&quot;xingchuwu&quot;,&quot;qianxiyun&quot;);</span><br><span class="line">        map.put(&quot;52&quot;,&quot;1213&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//        System.out.println(map.remove(&quot;52&quot;));</span><br><span class="line"></span><br><span class="line">//        map.clear();</span><br><span class="line"></span><br><span class="line">        System.out.println(map.containsKey(&quot;xingchuwu&quot;));</span><br><span class="line">        System.out.println(map.containsValue(&quot;qianxiyun&quot;));</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map集合的获取功能"><a href="#Map集合的获取功能" class="headerlink" title="Map集合的获取功能"></a>Map集合的获取功能</h3><ul>
<li>V get(Object key);    根据健获取值</li>
<li>Set<K> keySet();    获取所有健的集合</li>
<li>Collection<V> values();    获取所有值的集合</li>
<li>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();    获取所有键值对对象的集合</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MapDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(&quot;xingchuwu&quot;,&quot;qianxiyun&quot;);</span><br><span class="line">        map.put(&quot;52&quot;,&quot;1213&quot;);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        for(Map.Entry&lt;String,String&gt; me : entrySet)&#123;</span><br><span class="line">            String key = me.getKey();</span><br><span class="line">            String value = me.getValue();</span><br><span class="line">            System.out.println(key + &#x27;,&#x27; + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap案例"><a href="#HashMap案例" class="headerlink" title="HashMap案例"></a>HashMap案例</h3><p>ArrayList集合存储HashMap元素并遍历:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MapDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;HashMap&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">        HashMap&lt;String,String&gt; hm1 = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        hm1.put(&quot;hello1&quot;,&quot;world1&quot;);</span><br><span class="line">        hm1.put(&quot;hello2&quot;,&quot;world2&quot;);</span><br><span class="line">        hm1.put(&quot;hello3&quot;,&quot;world3&quot;);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String,String&gt; hm2 = new HashMap&lt;&gt;();</span><br><span class="line">        hm2.put(&quot;hello4&quot;,&quot;world4&quot;);</span><br><span class="line">        hm2.put(&quot;hello5&quot;,&quot;world5&quot;);</span><br><span class="line">        hm2.put(&quot;hello6&quot;,&quot;world6&quot;);</span><br><span class="line"></span><br><span class="line">        arrayList.add(hm1);</span><br><span class="line">        arrayList.add(hm2);</span><br><span class="line"></span><br><span class="line">        for(HashMap&lt;String,String&gt; hm : arrayList)&#123;</span><br><span class="line">            Set&lt;String&gt; keySet = hm.keySet();</span><br><span class="line">            for(String key : keySet)&#123;</span><br><span class="line">                String value = hm.get(key);</span><br><span class="line">                System.out.println(key + &#x27;,&#x27; + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap集合存储ArrayList元素并遍历:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class MapDemo4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String, ArrayList&lt;String&gt;&gt; hm =new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; arrayList1 = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        arrayList1.add(&quot;hello1&quot;);</span><br><span class="line">        arrayList1.add(&quot;hello2&quot;);</span><br><span class="line">        arrayList1.add(&quot;hello3&quot;);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; arrayList2 = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        arrayList2.add(&quot;hello4&quot;);</span><br><span class="line">        arrayList2.add(&quot;hello5&quot;);</span><br><span class="line">        arrayList2.add(&quot;hello6&quot;);</span><br><span class="line"></span><br><span class="line">        hm.put(&quot;hh&quot;,arrayList1);</span><br><span class="line">        hm.put(&quot;hhh&quot;,arrayList2);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keySet = hm.keySet();</span><br><span class="line">        for(String key : keySet)&#123;</span><br><span class="line">            ArrayList&lt;String&gt; value = hm.get(key);</span><br><span class="line">            for(String s : value)</span><br><span class="line">                System.out.println(key + &#x27; &#x27; + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>统计字符串中每个字符出现的次数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class MapDemo5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Character,Integer&gt; hm = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;str.length();i++)&#123;</span><br><span class="line">            char key = str.charAt(i);</span><br><span class="line"></span><br><span class="line">            if(!hm.containsKey(key))&#123;</span><br><span class="line">                hm.put(key,1);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                int num = hm.get(key);</span><br><span class="line">                hm.put(key,num+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//        Set&lt;Character&gt; set = hm.keySet();</span><br><span class="line">//        for(Character c : set)&#123;</span><br><span class="line">//            Integer value = hm.get(c);</span><br><span class="line">//            System.out.print(c);</span><br><span class="line">//            System.out.print(&quot;(&quot;);</span><br><span class="line">//            System.out.print(value);</span><br><span class="line">//            System.out.print(&quot;)&quot;);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line"></span><br><span class="line">        Set&lt;Character&gt; keySet = hm.keySet();</span><br><span class="line">        for(Character key : keySet)&#123;</span><br><span class="line">            Integer value = hm.get(key);</span><br><span class="line">            sb.append(key).append(&quot;(&quot;).append(value).append(&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Collctions"><a href="#Collctions" class="headerlink" title="Collctions"></a>Collctions</h2><p>Collections类是针对集合操作的工具类</p>
<h3 id="常用方法-6"><a href="#常用方法-6" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List<T> list);    将指定的列表按升序排序</li>
<li>public static void reverse(List&lt;?&gt; list);    反转指定列表中元素的顺序</li>
<li>public static void shuffle(List&lt;?&gt; list);    使用默认的随机源随机排序指定列表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionsDemo11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(30);</span><br><span class="line">        list.add(50);</span><br><span class="line">        list.add(20);</span><br><span class="line">        list.add(40);</span><br><span class="line">        list.add(10);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>ArrayList存储学生对象并排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionsDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Student s1 = new Student(&quot;xingchuwu&quot;,20);</span><br><span class="line">        Student s2 = new Student(&quot;qianxiyunu&quot;,19);</span><br><span class="line">        Student s3 = new Student(&quot;xxx&quot;,35);</span><br><span class="line">        Student s4 = new Student(&quot;aaa&quot;,20);</span><br><span class="line"></span><br><span class="line">        arrayList.add(s1);</span><br><span class="line">        arrayList.add(s2);</span><br><span class="line">        arrayList.add(s3);</span><br><span class="line">        arrayList.add(s4);</span><br><span class="line"></span><br><span class="line">        Collections.sort(arrayList, new Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Student s1, Student s2) &#123;</span><br><span class="line">                int num = s1.getAge() -s2.getAge();</span><br><span class="line">                int num2 = num == 0 ? s1.getName().compareTo(s2.getName()) : num;</span><br><span class="line">                return num2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for(Student s : arrayList)&#123;</span><br><span class="line">            System.out.println(s.getName() + &#x27; &#x27; + s.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟斗地主：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionsDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String[] colors = &#123;&quot;♦&quot;,&quot;♠&quot;,&quot;♥&quot;,&quot;♣&quot;&#125;;</span><br><span class="line">        String[] numbers = &#123;&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;&#125;;</span><br><span class="line">        for(String color : colors)&#123;</span><br><span class="line">            for(String number : numbers)</span><br><span class="line">                arrayList.add(color+number);</span><br><span class="line">        &#125;</span><br><span class="line">        arrayList.add(&quot;大王&quot;);</span><br><span class="line">        arrayList.add(&quot;小王&quot;);</span><br><span class="line"></span><br><span class="line">        Collections.shuffle(arrayList);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; dzArray = new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; nmArray1 = new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; nmArray2 = new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; dpArray = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;arrayList.size();i++)&#123;</span><br><span class="line">            String poker = arrayList.get(i);</span><br><span class="line"></span><br><span class="line">            if(i &gt;= arrayList.size()-3)&#123;</span><br><span class="line">                dpArray.add(poker);</span><br><span class="line">            &#125;else if(i%3==0)&#123;</span><br><span class="line">                dzArray.add(poker);</span><br><span class="line">            &#125;else if(i%3==1)&#123;</span><br><span class="line">                nmArray1.add(poker);</span><br><span class="line">            &#125;else if(i%3==2)&#123;</span><br><span class="line">                nmArray2.add(poker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lookPoker(&quot;地主&quot;,dzArray);</span><br><span class="line">        lookPoker(&quot;农民1&quot;,nmArray1);</span><br><span class="line">        lookPoker(&quot;农民2&quot;,nmArray2);</span><br><span class="line">        lookPoker(&quot;地牌&quot;,dpArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //看牌方法</span><br><span class="line">    public static void lookPoker(String name,ArrayList&lt;String&gt; arrayList)&#123;</span><br><span class="line">        System.out.println(name + &quot;的牌是&quot;);</span><br><span class="line">        for(String poker : arrayList)&#123;</span><br><span class="line">            System.out.print(poker + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>模拟斗地主升级版：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionsDemo4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer,String&gt; hm = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String[] colors = &#123;&quot;♦&quot;,&quot;♠&quot;,&quot;♥&quot;,&quot;♣&quot;&#125;;</span><br><span class="line">        String[] numbers = &#123;&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;&#125;;</span><br><span class="line">        hm.put(0,&quot;大王&quot;);</span><br><span class="line">        hm.put(1,&quot;小王&quot;);</span><br><span class="line">        int num = 2;</span><br><span class="line">        for(String number : numbers)&#123;</span><br><span class="line">            for(String color : colors)&#123;</span><br><span class="line">                hm.put(num,color+number);</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; keySet = hm.keySet();</span><br><span class="line">        for(Integer key : keySet)&#123;</span><br><span class="line">            String value = hm.get(key);</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            sb.append(key).append(&quot;:&quot;).append(value);</span><br><span class="line">            System.out.println(sb);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i=0;i&lt;52;i++)</span><br><span class="line">            arrayList.add(i);</span><br><span class="line">        Collections.shuffle(arrayList);</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Integer&gt; dzArray = new TreeSet&lt;&gt;();</span><br><span class="line">        TreeSet&lt;Integer&gt; nmArray1 = new TreeSet&lt;&gt;();</span><br><span class="line">        TreeSet&lt;Integer&gt; nmArray2 = new TreeSet&lt;&gt;();</span><br><span class="line">        TreeSet&lt;Integer&gt; dpArray = new TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;arrayList.size();i++)&#123;</span><br><span class="line">            Integer poker = arrayList.get(i);</span><br><span class="line"></span><br><span class="line">            if(i &gt;= arrayList.size()-3)&#123;</span><br><span class="line">                dpArray.add(poker);</span><br><span class="line">            &#125;else if(i%3==0)&#123;</span><br><span class="line">                dzArray.add(poker);</span><br><span class="line">            &#125;else if(i%3==1)&#123;</span><br><span class="line">                nmArray1.add(poker);</span><br><span class="line">            &#125;else if(i%3==2)&#123;</span><br><span class="line">                nmArray2.add(poker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lookPoker(&quot;地主&quot;,dzArray,hm);</span><br><span class="line">        lookPoker(&quot;农民1&quot;,nmArray1,hm);</span><br><span class="line">        lookPoker(&quot;农民2&quot;,nmArray2,hm);</span><br><span class="line">        lookPoker(&quot;地牌&quot;,dpArray,hm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void lookPoker(String name,TreeSet&lt;Integer&gt; arrayList,HashMap&lt;Integer,String&gt; hm)&#123;</span><br><span class="line">        System.out.println(name + &quot;的牌是&quot;);</span><br><span class="line">        for(Integer poker : arrayList)&#123;</span><br><span class="line">            System.out.print(hm.get(poker) + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>math包含执行基本数字运算的方法</p>
<p>静态类，通过类名可以直接调用</p>
<p>工具类的设计思想：</p>
<ul>
<li>构造方法用private修饰</li>
<li>成员用public static修饰</li>
</ul>
<h3 id="常用方法-7"><a href="#常用方法-7" class="headerlink" title="常用方法"></a>常用方法</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public static int abs(int a)</td>
<td align="center">返回参数的绝对值</td>
</tr>
<tr>
<td align="center">public static double ceil(double a)</td>
<td align="center">返回大于或等于参数的最小double值，等于一个整数</td>
</tr>
<tr>
<td align="center">public static double floor(double a)</td>
<td align="center">返回小于或等于参数的最大double值，等于一个整数</td>
</tr>
<tr>
<td align="center">public static int round(float a)</td>
<td align="center">按照四舍五入返回最接近参数的int</td>
</tr>
<tr>
<td align="center">public static int max(int a,int b)</td>
<td align="center">返回两个int值中的较大值</td>
</tr>
<tr>
<td align="center">public static int min(int a,int b)</td>
<td align="center">返回两个int值中的较小值</td>
</tr>
<tr>
<td align="center">public static double pow(double a,double b)</td>
<td align="center">返回a的b次幂的值</td>
</tr>
<tr>
<td align="center">public static double random()</td>
<td align="center">返回值为double的正值，[0.0,1.0)</td>
</tr>
</tbody></table>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>System包含几个有用的类字段和方法，它不能被实例化</p>
<h3 id="常用方法-8"><a href="#常用方法-8" class="headerlink" title="常用方法"></a>常用方法</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public static void exit(int status)</td>
<td>终止当前运行的java虚拟机，非零表示异常终止</td>
</tr>
<tr>
<td align="center">public static long currentTimeMillis()</td>
<td>返回当前的时间（以毫秒为单位）</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for(int i = 0; i &lt; 10000; i++)&#123;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">	System.out.println(&quot;共耗时：&quot; + (end - start) + &quot;毫秒&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Object是类层次结构的根，每个类都可以将Object作为超类，所有类都直接或间接的继承自该类</p>
<p>构造方法：public Object();</p>
<h3 id="常用方法-9"><a href="#常用方法-9" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>public String toString();//返回对象的字符串表示形式，建议所有子类重写此方法，自动生成即可</li>
<li>public boolean equals(Object obj);//比较对象是否相等。默认比较地址，重写可以比较内容，自动生成</li>
</ul>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>Arrays类包含用于操作数组的各种方法</p>
<h3 id="常用方法-10"><a href="#常用方法-10" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>public static String toString(int[] a);返回指定数组的内容的字符串表示形式</li>
<li>public static void sort(int[] a);按照数字顺序排列指定的数组</li>
</ul>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p><img src="E:\TyporaReport\java\image\IO.jpeg" alt="IO"></p>
<p><img src="E:\TyporaReport\java\image\IO流.png" alt="IO"></p>
<p>IO流概述：</p>
<ul>
<li>IO：输入/输出(Input/Output)</li>
<li>流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输</li>
<li>IO流就是用来处理设备间数据传输问题的，如：文件复制、文件上传、文件下载</li>
</ul>
<p>分类：</p>
<ul>
<li><p>按照数据的流向：</p>
<ul>
<li>输入流：读数据</li>
<li>输出流：写数据</li>
</ul>
</li>
<li><p>按照数据类型：</p>
<ul>
<li>字节流：字节输入流、字节输出流</li>
<li>字符流：字符输入流、字符输出流</li>
</ul>
</li>
<li><p>如果数据通过记事本软件打开，可以读懂，用字符流</p>
</li>
<li><p>否则用字节流，一般默认字节流</p>
</li>
</ul>
<h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>File：它是文件和目录路径名的抽象表示</p>
<ul>
<li>文件和目录是可以通过File封装成对象的</li>
<li>对应File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的</li>
</ul>
<h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>File(String pathname);    通过将给定的路径名字符串转换为抽象路径名来创建新的File实例</li>
<li>File(String parent,String child);    从父路径名字符串和子路径名字符串创建新的File实例</li>
<li>File(File parent,String child);    从父抽象路径名和子路径名字符串创建新的File实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class FileDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File f1 = new File(&quot;E:\\javadProgram\\javaIOTest\\java.txt&quot;);</span><br><span class="line">        System.out.println(f1);</span><br><span class="line"></span><br><span class="line">        File f2 = new File(&quot;E:\\javadProgram\\javaIOTest&quot;,&quot;java.txt&quot;);</span><br><span class="line">        System.out.println(f2);</span><br><span class="line"></span><br><span class="line">        File f3 = new File(&quot;E:\\javadProgram\\javaIOTest&quot;);</span><br><span class="line">        File f4 = new File(f3,&quot;java.txt&quot;);</span><br><span class="line">        System.out.println(f4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h3><ul>
<li>public boolean createNewFile();    当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件</li>
<li>public boolean mkdir();    创建由此抽象路径名命名的目录</li>
<li>public boolean mkdirs();    创建由此抽象路径名命名的目录，包括任何必须但不存在的父目录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class FileDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        File f1 = new File(&quot;E:\\javadProgram\\javaIOTest\\java.txt&quot;);</span><br><span class="line">        System.out.println(f1.createNewFile());</span><br><span class="line"></span><br><span class="line">        File f2 = new File(&quot;E:\\javadProgram\\javaIOTest\\javaSE&quot;);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line"></span><br><span class="line">        File f3 = new File(&quot;E:\\javadProgram\\javaIOTest\\javaWeb\\html&quot;);</span><br><span class="line">        System.out.println(f3.mkdirs());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="判断和获取功能"><a href="#判断和获取功能" class="headerlink" title="判断和获取功能"></a>判断和获取功能</h3><ul>
<li>public boolean isDirectory();    测试此抽象路径名表示的File是否为目录</li>
<li>public boolean isFile();    测试此抽象路径名表示的File是否为文件</li>
<li>public boolean exists();    测试此抽象路径名表示的File是否为存在</li>
<li>public String getAbsolutePath();    返回此抽象路径名的绝对路径名字符串</li>
<li>public String getPath();    将此抽象路径名转换为路径名字符串</li>
<li>public String getName();    返回此抽象路径名表示的文件或目录的名称</li>
<li>public String[] list();    返回此抽象路径名表示的目录中的文件和目录的名称字符串数组</li>
<li>public File[] listFiles();    返回此抽象路径名表示的目录中的文件和目录的File对象数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class FileDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File f1 = new File(&quot;javaStudy.iml&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(f1.isDirectory());</span><br><span class="line">        System.out.println(f1.isFile());</span><br><span class="line">        System.out.println(f1.exists());</span><br><span class="line"></span><br><span class="line">        System.out.println(f1.getAbsoluteFile());</span><br><span class="line">        System.out.println(f1.getPath());</span><br><span class="line">        System.out.println(f1.getName());</span><br><span class="line"></span><br><span class="line">        File f2 = new File(&quot;E:\\javadProgram\\javaIOTest&quot;);</span><br><span class="line">        String[] strArrays = f2.list();</span><br><span class="line">        for(String str : strArrays)</span><br><span class="line">            System.out.println(str);</span><br><span class="line"></span><br><span class="line">        File[] fileArrays = f2.listFiles();</span><br><span class="line">        for(File file : fileArrays)&#123;</span><br><span class="line">            if(file.isFile())</span><br><span class="line">                System.out.println(file.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h3><ul>
<li>public boolean delete();    删除由此抽象路径名表示的文件或目录</li>
</ul>
<p>注意事项</p>
<ul>
<li>如果一个目录中有内容（目录，文件），不能直接删除。应该先删除目录中的内容，最后才能删除目录</li>
</ul>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>遍历目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class FileDemo4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File f = new File(&quot;E:\\javadProgram\\javaIOTest&quot;);</span><br><span class="line">        if(f.exists())</span><br><span class="line">            getAllFilePath(f);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void getAllFilePath(File f)&#123;</span><br><span class="line">        File[] fileArray = f.listFiles();</span><br><span class="line">        if(fileArray != null)&#123;</span><br><span class="line">            for(File file : fileArray)&#123;</span><br><span class="line">                if(file.isDirectory())&#123;</span><br><span class="line">//                    System.out.print(file.getPath());</span><br><span class="line">//                    System.out.println(&quot;:&quot;);</span><br><span class="line">                    getAllFilePath(file);</span><br><span class="line">                &#125;else if(file.isFile())&#123;</span><br><span class="line">                    System.out.println(file.getAbsoluteFile());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>字节流抽象基类：</p>
<ul>
<li>InputStream：这个抽象类是表示字节输入流的所有类的超类</li>
<li>OutputStream：这个抽象类是表示字节输出流的所有类的超类</li>
<li>子类名特点：子类名称都是以其父类名作为子类名的后缀</li>
</ul>
<h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p>FileOutputStream：文件输出流用于将数据写入File</p>
<ul>
<li>FileOutputStream(String name)：创建文件输出流以指定的名称写入文件</li>
</ul>
<p>使用字节输出流写数据的步骤：</p>
<ul>
<li>创建字节输出流对象（调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件）</li>
<li>调用字节输出流对象的写数据方法</li>
<li>释放资源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FileOutputStreamDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;E:\\javadProgram\\javaStudy\\src\\com\\chang\\base\\myIO\\ByteStreamDemo\\fos.txt&quot;);</span><br><span class="line"></span><br><span class="line">        fos.write(97);</span><br><span class="line">        </span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写数据方法"><a href="#写数据方法" class="headerlink" title="写数据方法"></a>写数据方法</h4><ul>
<li>void write(int b)：将指定的字节写入此文件输出流，一次写一个字节数据</li>
<li>void write(byte[] b)：将b.length字节从指定的字节数组写入此文件输出流，一次写一个字节数组数据</li>
<li>void write(byte[] b,int off,int len)：将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流，一次写一个字节数组的部分数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class FileOutputStreamDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;E:\\javadProgram\\javaStudy\\src\\com\\chang\\base\\myIO\\ByteStreamDemo\\fos.txt&quot;);</span><br><span class="line"></span><br><span class="line">        fos.write(97);</span><br><span class="line">        byte[] bys = &quot;abcde&quot;.getBytes();</span><br><span class="line">        fos.write(bys);</span><br><span class="line"></span><br><span class="line">        fos.write(bys,1,2);</span><br><span class="line"></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="换行和追加写入"><a href="#换行和追加写入" class="headerlink" title="换行和追加写入"></a>换行和追加写入</h4><p>换行：</p>
<ul>
<li>写完数据后，加换行符<ul>
<li>windows：\r\n</li>
<li>linux：\n</li>
<li>mac：\r</li>
</ul>
</li>
</ul>
<p>追加写入：</p>
<ul>
<li>public FielOutputStream(String name,boolean append)</li>
<li>创建文件输出流以指定的名称写入文件。如果第二个参数为true，则字节将写入文件的末尾而不是开头</li>
</ul>
<h4 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class FileOutputStreamDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FileOutputStream fos = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            fos = new FileOutputStream(&quot;fos.txt&quot;);</span><br><span class="line">            fos.write(&quot;hello&quot;.getBytes());</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if(fos != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>FileInputStream：从文件系统中的文件获取输入字节</p>
<ul>
<li>FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream，该文件由文件系统中的路径名name命名</li>
</ul>
<p>使用字节输入流写数据的步骤：</p>
<ul>
<li>创建字节输入流对象</li>
<li>调用字节输入流对象的读数据方法</li>
<li>释放资源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class FileInputStreamDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;fos.txt&quot;);</span><br><span class="line"></span><br><span class="line">        int by;</span><br><span class="line">        while((by = fis.read()) != -1)&#123;</span><br><span class="line">            System.out.print((char)by);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读字节数组数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class FileInputStreamDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;fos.txt&quot;);</span><br><span class="line"></span><br><span class="line">        byte[] bys = new byte[1024];    //1024及其倍数</span><br><span class="line">        int len;</span><br><span class="line">        while((len = fis.read(bys)) != -1)&#123;</span><br><span class="line">            System.out.println(new String(bys,0,len));</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><p>字节流复制文本文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class FileInputStreamDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;fos.txt&quot;);</span><br><span class="line">        FileOutputStream fos = new 					       FileOutputStream(&quot;E:\\javadProgram\\javaIOTest\\java.txt&quot;); </span><br><span class="line"></span><br><span class="line">        int by;</span><br><span class="line">        while((by = fis.read()) != -1)&#123;</span><br><span class="line">            fos.write(by);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class FileInputStreamDemo4 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;E:\\UpupooWallpaper\\1800011075\\previewFix.jpg&quot;);</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;E:\\javadProgram\\javaIOTest\\test.jpg&quot;);</span><br><span class="line"></span><br><span class="line">        int by;</span><br><span class="line">        while((by = fis.read()) != -1)&#123;</span><br><span class="line">            fos.write(by);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制视频</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public class CopyAviDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//        method1();</span><br><span class="line">//        method2();</span><br><span class="line">//        method3();</span><br><span class="line">        method4();</span><br><span class="line"></span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(endTime-startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    //基本字节流一次读写一个字节   107610ms</span><br><span class="line">    public static void method1() throws IOException&#123;</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;E:\\javadProgram\\javaIOTest\\1111.avi&quot;);</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;C:\\Users\\10923\\Videos\\Captures\\1111.avi&quot;);</span><br><span class="line"></span><br><span class="line">        int by;</span><br><span class="line">        while((by = fis.read()) != -1)&#123;</span><br><span class="line">            fos.write(by);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //基本字节流一次读写一个字节数组    143ms</span><br><span class="line">    public static void method2() throws IOException&#123;</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;E:\\javadProgram\\javaIOTest\\1111.avi&quot;);</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;C:\\Users\\10923\\Videos\\Captures\\11112.avi&quot;);</span><br><span class="line"></span><br><span class="line">        byte[] bys = new byte[1024];</span><br><span class="line">        int len;</span><br><span class="line">        while((len = fis.read(bys)) != -1)&#123;</span><br><span class="line">            fos.write(bys,0,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //字节缓冲流一次读写一个字节    189ms</span><br><span class="line">    public static void method3() throws IOException&#123;</span><br><span class="line"></span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;C:\\Users\\10923\\Videos\\Captures\\1111.avi&quot;));</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;E:\\javadProgram\\javaIOTest\\11113.avi&quot;));</span><br><span class="line"></span><br><span class="line">        int by;</span><br><span class="line">        while((by = bis.read()) != -1)&#123;</span><br><span class="line">            bos.write(by);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //字节缓冲流一次读写一个字节数组    35ms</span><br><span class="line">    public static void method4() throws IOException&#123;</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;C:\\Users\\10923\\Videos\\Captures\\1111.avi&quot;));</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;E:\\javadProgram\\javaIOTest\\11114.avi&quot;));</span><br><span class="line"></span><br><span class="line">        byte[] bys = new byte[1024];</span><br><span class="line">        int len;</span><br><span class="line">        while((len = bis.read(bys)) != -1)&#123;</span><br><span class="line">            bos.write(bys,0,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>字节缓冲流：</p>
<ul>
<li>BufferedOutputStream：该类实现缓冲输出流。通过设置这样的输出流，应用程序可以想底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用</li>
<li>BufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组。当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节</li>
</ul>
<p>构造方法：</p>
<ul>
<li>字节缓冲输出流：BufferedOutputStream(OutputSteam out)</li>
<li>字节缓冲输入流：BufferedInputStream(InputStream in)</li>
</ul>
<p>字节缓冲流仅仅提供缓冲区，而真正的读写数据还得依靠基本得字节流对象进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class BufferStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;fos.txt&quot;));</span><br><span class="line"></span><br><span class="line">        bos.write(&quot;hello\r\n&quot;.getBytes());</span><br><span class="line">        bos.write(&quot;world\r\n&quot;.getBytes());</span><br><span class="line"></span><br><span class="line">        bos.close();</span><br><span class="line"></span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;fos.txt&quot;));</span><br><span class="line"></span><br><span class="line">        byte[] bys = new byte[1024];</span><br><span class="line">        int len;</span><br><span class="line">        while((len = bis.read(bys)) != -1)&#123;</span><br><span class="line">            System.out.println(new String(bys,0,len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>由于字节流操作中文不是特别方便，所有java就提供了字符流</p>
<ul>
<li>字符流 = 字节流 + 编码表</li>
</ul>
<p>用字节流复制文本文件时，最终底层操作会自动进行字节拼接成中文</p>
<ul>
<li>汉字在存储时，无论选择哪种编码存储，第一个字节都是负数</li>
</ul>
<h3 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h3><ul>
<li><p>Ascll</p>
</li>
<li><p>GBK</p>
</li>
<li><p>UTF-8</p>
</li>
</ul>
<p>编码：</p>
<ul>
<li>byte[] getBytes(),使用平台的默认字符集将String编码为一系列字节，将结果存储到新的字节数组中</li>
<li>byte[] getBytes(String charsetName)，使用指定得字符集将String编码为一系列字节，将结果存储到新的字节数组中</li>
</ul>
<p>解码：</p>
<ul>
<li>String(byte[] bytes)，通过使用平台的默认字符集解码指定的字节数组来构造新的String</li>
<li>String(byte[] bytes, String charsetName)，通过指定的字符集解码指定的字节数组来构造新的String</li>
</ul>
<h3 id="字符流的编码解码"><a href="#字符流的编码解码" class="headerlink" title="字符流的编码解码"></a>字符流的编码解码</h3><p>字符流抽象基类：</p>
<ul>
<li>Reader：字符输入流的抽象类</li>
<li>Writer：字符输出流的抽象类</li>
</ul>
<p>字符流中和编码解码问题相关的两个类：</p>
<ul>
<li>InputStreamReader</li>
<li>OutputStreamWriter</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ConversionStreamDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;fos.txt&quot;),&quot;GBK&quot;);</span><br><span class="line"></span><br><span class="line">        osw.write(&quot;行初雾&quot;);</span><br><span class="line">        osw.close();</span><br><span class="line"></span><br><span class="line">        InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;fos.txt&quot;),&quot;GBK&quot;);</span><br><span class="line">        int ch;</span><br><span class="line">        while((ch = isr.read()) != -1)&#123;</span><br><span class="line">            System.out.println((char)ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写数据方法-1"><a href="#写数据方法-1" class="headerlink" title="写数据方法"></a>写数据方法</h3><ul>
<li>void write(int c)：    写一个字符</li>
<li>void write(char[] cbuf)：    写入一个字符数组</li>
<li>void write(char[] cbuf,int off,int len)：    写入字符数组的一部分</li>
<li>void write(String str)：    写一个字符串</li>
<li>void write(String str,int off,int len)：    写一个字符串的一部分</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class OutputStreamWriterDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;fos.txt&quot;));</span><br><span class="line"></span><br><span class="line">        osw.write(97);</span><br><span class="line">        osw.flush();</span><br><span class="line"></span><br><span class="line">        char[] chs = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;;</span><br><span class="line">        osw.write(chs);</span><br><span class="line">        osw.flush();</span><br><span class="line"></span><br><span class="line">        osw.write(chs,1,3);</span><br><span class="line">        osw.flush();</span><br><span class="line"></span><br><span class="line">        osw.write(&quot;hello&quot;);</span><br><span class="line">        osw.flush();</span><br><span class="line"></span><br><span class="line">        osw.write(&quot;hello&quot;,1,3);</span><br><span class="line">        </span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读数据方法"><a href="#读数据方法" class="headerlink" title="读数据方法"></a>读数据方法</h3><ul>
<li>int read()：    一次读一个字符数据</li>
<li>int read(char[] cbuf)：    一次读一个字符数组数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class InputStreamReaderDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;fos.txt&quot;));</span><br><span class="line"></span><br><span class="line">//        int ch;</span><br><span class="line">//        while((ch = isr.read()) != -1)&#123;</span><br><span class="line">//            System.out.println((char)ch);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">        char[] chs = new char[1024];</span><br><span class="line">        int len;</span><br><span class="line">        while((len = isr.read(chs)) != -1)&#123;</span><br><span class="line">            System.out.println(new String(chs,0,len));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><p>复制java文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class CopyJavaDemo01 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;E:\\javadProgram\\javaStudy\\src\\com\\chang\\base\\myIO\\ConversionStreamDemo\\ConversionStreamDemo1.java&quot;));</span><br><span class="line">        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;E:\\javadProgram\\javaIOTest\\copy.java&quot;));</span><br><span class="line"></span><br><span class="line">//        int ch;</span><br><span class="line">//        while((ch = isr.read()) != -1)&#123;</span><br><span class="line">//            osw.write(ch);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">        char[] chs = new char[1024];</span><br><span class="line">        int len;</span><br><span class="line">        while((len = isr.read(chs)) != -1)&#123;</span><br><span class="line">            osw.write(chs,0,len);</span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制java文件（改进版）</p>
<p>为了简化书写，转换流提供了对应的子类</p>
<ul>
<li>FileReader：用于读取字符文件的便捷类<ul>
<li>FileReader(String fileName)</li>
</ul>
</li>
<li>FileWriter：用于写入字符文件的便捷类<ul>
<li>FileWriter(String fileName)</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class CopyJavaDemo02 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileReader fr = new FileReader(&quot;E:\\\\javadProgram\\\\javaStudy\\\\src\\\\com\\\\chang\\\\base\\\\myIO\\\\ConversionStreamDemo\\\\ConversionStreamDemo1.java&quot;);</span><br><span class="line">        FileWriter fw = new FileWriter(&quot;E:\\\\javadProgram\\\\javaIOTest\\\\copy.java&quot;);</span><br><span class="line"></span><br><span class="line">//        int ch;</span><br><span class="line">//        while((ch = fr.read()) != -1)&#123;</span><br><span class="line">//            fw.write(ch);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">        char[] chs =new char[1024];</span><br><span class="line">        int len;</span><br><span class="line">        while((len = fr.read(chs)) != -1)&#123;</span><br><span class="line">            fw.write(chs,0,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fr.close();</span><br><span class="line">        fw.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制java文件（字符缓冲流改进版）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class CopyJavaDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader br = new BufferedReader(new FileReader(&quot;E:\\javadProgram\\javaStudy\\src\\com\\chang\\base\\myIO\\ConversionStreamDemo\\ConversionStreamDemo1.java&quot;));</span><br><span class="line">        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;E:\\javadProgram\\javaIOTest\\copy3.java&quot;));</span><br><span class="line"></span><br><span class="line">//        int ch;</span><br><span class="line">//        while((ch = br.read()) != -1)&#123;</span><br><span class="line">//            bw.write(ch);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">        char[] chs = new char[1024];</span><br><span class="line">        int len ;</span><br><span class="line">        while((len = br.read(chs)) != -1)&#123;</span><br><span class="line">            bw.write(chs,0,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><ul>
<li>BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途</li>
<li>BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。默认值足够大，可用于大多数用途</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class BufferedStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;fos.txt&quot;));</span><br><span class="line"></span><br><span class="line">        bw.write(&quot;hello\r\n&quot;);</span><br><span class="line">        bw.write(&quot;hello\r\n&quot;);</span><br><span class="line">        bw.close();</span><br><span class="line"></span><br><span class="line">        BufferedReader br = new BufferedReader(new FileReader(&quot;fos.txt&quot;));</span><br><span class="line"></span><br><span class="line">        int ch;</span><br><span class="line">        while((ch = br.read()) != -1)&#123;</span><br><span class="line">            System.out.print((char)ch);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特有功能"><a href="#特有功能" class="headerlink" title="特有功能"></a>特有功能</h4><ul>
<li>BufferedWriter:<ul>
<li>void newLine()：写一行行分隔符，行分割符字符串由系统属性定义</li>
</ul>
</li>
<li>BufferedReader：<ul>
<li>public String readLine()：读一行文字，结果包含行的的内容的字符串，不包括任何行终止字符，如果流的结尾已经到达，则为null</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class BufferedStreamDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;fos.txt&quot;));</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            bw.write(&quot;hello&quot;+i);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bw.close();</span><br><span class="line"></span><br><span class="line">        BufferedReader br = new BufferedReader(new FileReader(&quot;fos.txt&quot;));</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = br.readLine()) != null)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h2><p>集合到文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayListToTxtDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">        arrayList.add(&quot;hello1&quot;);</span><br><span class="line">        arrayList.add(&quot;hello2&quot;);</span><br><span class="line">        arrayList.add(&quot;hello3&quot;);</span><br><span class="line"></span><br><span class="line">        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;fos.txt&quot;));</span><br><span class="line"></span><br><span class="line">        for(String array : arrayList)&#123;</span><br><span class="line">            bw.write(array);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件到集合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TxtToArrayListDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        BufferedReader br = new BufferedReader(new FileReader(&quot;fos.txt&quot;));</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">        String line;</span><br><span class="line">        while((line = br.readLine()) != null)&#123;</span><br><span class="line">            arrayList.add(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        for(String s : arrayList)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制单级文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CopyFolderDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        File srcFolder = new File(&quot;E:\\javadProgram\\javaIOTest\\javaSE&quot;);</span><br><span class="line"></span><br><span class="line">        String srcFolderName = srcFolder.getName();</span><br><span class="line"></span><br><span class="line">        File destFolder = new File(&quot;E:\\javadProgram\\javaIOTest\\javaWeb&quot;,srcFolderName);</span><br><span class="line"></span><br><span class="line">        if(!destFolder.exists())&#123;</span><br><span class="line">            destFolder.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File[] files = srcFolder.listFiles();</span><br><span class="line">        for(File srcFile : files)&#123;</span><br><span class="line">            String srcFileName = srcFile.getName();</span><br><span class="line">            File destFile = new File(destFolder,srcFileName);</span><br><span class="line">            copyFile(srcFile,destFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void copyFile(File srcFile,File destFile) throws IOException&#123;</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile));</span><br><span class="line"></span><br><span class="line">        byte[] bys = new byte[1024];</span><br><span class="line">        int len;</span><br><span class="line">        while((len = bis.read(bys)) != -1)&#123;</span><br><span class="line">            bos.write(bys,0,len);</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制多级文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class CopyFoldersDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        File srcFile = new File(&quot;E:\\javadProgram\\javaIOTest&quot;);</span><br><span class="line"></span><br><span class="line">        File destFile = new File(&quot;E:\\javadProgram\\javaIOTest2&quot;);</span><br><span class="line"></span><br><span class="line">        copyFolder(srcFile,destFile);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void copyFolder(File srcFile,File destFile) throws IOException &#123;</span><br><span class="line">        if(srcFile.isDirectory())&#123;</span><br><span class="line">            String srcFileName = srcFile.getName();</span><br><span class="line">            File destFolder = new File(destFile,srcFileName);</span><br><span class="line">            if(!destFolder.exists())&#123;</span><br><span class="line">                destFolder.mkdir();</span><br><span class="line">            &#125;</span><br><span class="line">            File[] files = srcFile.listFiles();</span><br><span class="line">            for(File file : files)&#123;</span><br><span class="line">                copyFolder(file,destFolder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(srcFile.isFile())&#123;</span><br><span class="line">            File newFile = new File(destFile,srcFile.getName());</span><br><span class="line">            copyFile(srcFile,newFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void copyFile(File srcFile, File destFile) throws IOException &#123;</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile));</span><br><span class="line"></span><br><span class="line">        byte[] bys = new byte[1024];</span><br><span class="line">        int len;</span><br><span class="line">        while((len = bis.read(bys)) != -1)&#123;</span><br><span class="line">            bos.write(bys,0,len);</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特殊操作流"><a href="#特殊操作流" class="headerlink" title="特殊操作流"></a>特殊操作流</h2><h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h3><p>System类中有两个静态的成员变量：</p>
<ul>
<li>public static final InputStream in：标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的另一个输入源</li>
<li>public static final PrintStream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输入目标</li>
</ul>
<p>自己实现键盘录入数据</p>
<ul>
<li>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</li>
</ul>
<p>Java提供了一个类实现键盘录入</p>
<ul>
<li>Scanner sc = new Scanner(System.in);</li>
</ul>
<p>输出语句的本质：是一个标准的输出流</p>
<ul>
<li>PrintStream ps = System.out;</li>
<li>PrintStream类有的方法，System.out都可以使用</li>
</ul>
<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>打印流分类：</p>
<ul>
<li>字节打印流：PrintStream</li>
<li>字符打印流：PrintWriter</li>
</ul>
<p>打印流的特点：</p>
<ul>
<li>只负责输出数据，不负责读取数据</li>
<li>有自己的特有方法</li>
</ul>
<p>字节打印流：</p>
<ul>
<li>PrintStream(String fileName)：使用指定的文件名创建新的打印流</li>
<li>使用继承父类的方法（write()）写数据，查看时会转码；使用自己特有的方法（print（））写数据，查看的数据原样输出</li>
</ul>
<p>字符打印流：</p>
<ul>
<li>PrintWriter(String fileName)    使用指定的文件名创建一个新的PrintWriter，而不需要自动执行刷新</li>
<li>PrintWriter(Writer out,boolean autoFlush)    创建一个新的PrintWriter，out：字符输出流；autoFlush：若为真，则Println，printf，format方法将刷新输出缓冲区</li>
</ul>
<h3 id="对象序列化流"><a href="#对象序列化流" class="headerlink" title="对象序列化流"></a>对象序列化流</h3><p>对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象</p>
<p>对象序列化流：ObjectOutputStream</p>
<h3 id="对象反序列化流"><a href="#对象反序列化流" class="headerlink" title="对象反序列化流"></a>对象反序列化流</h3><p>对象反序列化流：ObjectInputStream</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><img src="E:\TyporaReport\java\image\多线程1.png" alt="多线程"></p>
<p><img src="E:\TyporaReport\java\image\多线程2.png" alt="多线程"></p>
<p><img src="E:\TyporaReport\java\image\多线程3.png" alt="多线程"></p>
<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><ul>
<li>程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念</li>
<li>进程是执行程序的一次执行过程，是一个动态的概念。是系统资源分配的单位</li>
<li>一个进程中可以包含若干个线程。线程是CPU调度和执行的单位</li>
</ul>
<p>核心概念：</p>
<ul>
<li>线程就是独立的执行路径</li>
<li>在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程</li>
<li>main()称之为主线程，为系统的入口，用于执行整个程序</li>
<li>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为的干预的</li>
<li>堆同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制</li>
<li>线程会带来额外的开销，如cpu调度时间，并发控制开销</li>
<li>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</li>
</ul>
<h2 id="线程实现（重点）"><a href="#线程实现（重点）" class="headerlink" title="线程实现（重点）"></a>线程实现（重点）</h2><p>创建线程的三种方式：</p>
<ul>
<li>继承Thread类<ul>
<li>子类继承Thread类具有多线程能力</li>
<li>启动线程：子类对象.start()</li>
<li>不建议使用：避免OOP单继承局限性</li>
</ul>
</li>
<li>实现Runnable接口<ul>
<li>实现接口Runnable具有多线程能力</li>
<li>启动线程：传入目标对象+Thread对象.start()</li>
<li>推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</li>
</ul>
</li>
<li>实现Callable接口</li>
</ul>
<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><ul>
<li>自定义线程类继承Thread类</li>
<li>重写run()方法，编写线程执行体</li>
<li>创建线程对象，调用start()方法启动线程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//总结：注意，线程开启不一定立即执行，由CPU调度执行</span><br><span class="line">public class ThreadDemo1 extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 200; i++) &#123;</span><br><span class="line">            System.out.println(&quot;run------------&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadDemo1 threadDemo1 = new ThreadDemo1();</span><br><span class="line">        threadDemo1.start();</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            System.out.println(&quot;main-&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：下载网图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo2 extends Thread&#123;</span><br><span class="line">    private String url;    //网络图片地址</span><br><span class="line">    private String name;    //保存的文件名</span><br><span class="line"></span><br><span class="line">    public ThreadDemo2(String url,String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        WebDownloader webDownloader = new WebDownloader();</span><br><span class="line">        webDownloader.downloader(url,name);</span><br><span class="line">        System.out.println(&quot;下载了文件：&quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadDemo2 t1 = new ThreadDemo2(&quot;https://bkimg.cdn.bcebos.com/pic/730e0cf3d7ca7bcb3700f79abe096b63f624a80f?x-bce-process=image/resize,m_lfit,w_220,limit_1/format,f_auto&quot;,&quot;E:\\javadProgram\\javaIOTest\\1.jpg&quot;);</span><br><span class="line">        ThreadDemo2 t2 = new ThreadDemo2(&quot;https://bkimg.cdn.bcebos.com/pic/730e0cf3d7ca7bcb3700f79abe096b63f624a80f?x-bce-process=image/resize,m_lfit,w_220,limit_1/format,f_auto&quot;,&quot;2.jpg&quot;);</span><br><span class="line">        ThreadDemo2 t3 = new ThreadDemo2(&quot;https://bkimg.cdn.bcebos.com/pic/730e0cf3d7ca7bcb3700f79abe096b63f624a80f?x-bce-process=image/resize,m_lfit,w_220,limit_1/format,f_auto&quot;,&quot;3.jpg&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下载器</span><br><span class="line">class WebDownloader&#123;</span><br><span class="line">    //下载方法</span><br><span class="line">    public void downloader(String url,String name)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            FileUtils.copyURLToFile(new URL(url),new File(name));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;IO异常，downloader方法出现问题&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><ul>
<li>自定义类实现Runnable接口</li>
<li>实现run()方法，编写线程执行体</li>
<li>创建线程对象，调用start()方法启动线程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo3 implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 200; i++) &#123;</span><br><span class="line">            System.out.println(&quot;run----------&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadDemo3 threadDemo3 = new ThreadDemo3();</span><br><span class="line"></span><br><span class="line">        new Thread(threadDemo3).start();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            System.out.println(&quot;main--&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h3><p>并发：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo4 implements Runnable&#123;</span><br><span class="line">    //票数</span><br><span class="line">    private int ticketNums = 10;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(ticketNums &lt;=0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(200);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;-&gt; 拿到了第&quot; + ticketNums-- + &quot;张票&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadDemo4 ticket = new ThreadDemo4();</span><br><span class="line"></span><br><span class="line">        new Thread(ticket,&quot;A&quot;).start();</span><br><span class="line">        new Thread(ticket,&quot;B&quot;).start();</span><br><span class="line">        new Thread(ticket,&quot;C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>龟兔赛跑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo5 implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private static String winner;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt;= 100; i++) &#123;</span><br><span class="line"></span><br><span class="line">            //模拟兔子休息</span><br><span class="line">            if(Thread.currentThread().getName() == &quot;兔子&quot; &amp;&amp; i%10 ==5)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            boolean flag = gameOver(i);</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;--&gt;跑了&quot;+ i + &quot;步&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //判断是否完成比赛</span><br><span class="line">    private boolean gameOver(int steps)&#123;</span><br><span class="line">        if(winner!=null)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(steps&gt;=100)&#123;</span><br><span class="line">                winner = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(&quot;winner is &quot; + winner);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadDemo5 threadDemo5 = new ThreadDemo5();</span><br><span class="line">        new Thread(threadDemo5,&quot;兔子&quot;).start();</span><br><span class="line">        new Thread(threadDemo5,&quot;乌龟&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><ul>
<li>实现Callable接口，需要返回值类型</li>
<li>重写call方法，需要抛出异常</li>
<li>创建目标对象</li>
<li>创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(3);</li>
<li>提交执行：Future<Boolean> r1 = ser.submit(t1);</li>
<li>获取结果：boolean rs1 = r1.get();</li>
<li>关闭服务：ser.shutdownNow();</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo6 implements Callable&lt;Boolean&gt; &#123;</span><br><span class="line">    private String url;    //网络图片地址</span><br><span class="line">    private String name;    //保存的文件名</span><br><span class="line"></span><br><span class="line">    public ThreadDemo6(String url,String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.url = url;    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Boolean call()&#123;</span><br><span class="line">        WebDownloader webDownloader = new WebDownloader();</span><br><span class="line">        webDownloader.downloader(url,name);</span><br><span class="line">        System.out.println(&quot;下载了文件：&quot; + name);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        ThreadDemo6 t1 = new ThreadDemo6(&quot;https://bkimg.cdn.bcebos.com/pic/730e0cf3d7ca7bcb3700f79abe096b63f624a80f?x-bce-process=image/resize,m_lfit,w_220,limit_1/format,f_auto&quot;,&quot;E:\\javadProgram\\javaIOTest\\1.jpg&quot;);</span><br><span class="line">        ThreadDemo6 t2 = new ThreadDemo6(&quot;https://bkimg.cdn.bcebos.com/pic/730e0cf3d7ca7bcb3700f79abe096b63f624a80f?x-bce-process=image/resize,m_lfit,w_220,limit_1/format,f_auto&quot;,&quot;E:\\javadProgram\\javaIOTest\\2.jpg&quot;);</span><br><span class="line">        ThreadDemo6 t3 = new ThreadDemo6(&quot;https://bkimg.cdn.bcebos.com/pic/730e0cf3d7ca7bcb3700f79abe096b63f624a80f?x-bce-process=image/resize,m_lfit,w_220,limit_1/format,f_auto&quot;,&quot;E:\\javadProgram\\javaIOTest\\3.jpg&quot;);</span><br><span class="line"></span><br><span class="line">        //创建执行服务</span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(3);</span><br><span class="line"></span><br><span class="line">        //提交执行</span><br><span class="line">        Future&lt;Boolean&gt; r1 = ser.submit(t1);</span><br><span class="line">        Future&lt;Boolean&gt; r2 = ser.submit(t2);</span><br><span class="line">        Future&lt;Boolean&gt; r3 = ser.submit(t3);</span><br><span class="line"></span><br><span class="line">        //获取结果</span><br><span class="line">        boolean rs1 = r1.get();</span><br><span class="line">        boolean rs2 = r2.get();</span><br><span class="line">        boolean rs3 = r2.get();</span><br><span class="line"></span><br><span class="line">        //关闭服务</span><br><span class="line">        ser.shutdownNow();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><ul>
<li>避免匿名内部类定义过多</li>
<li>其实质属于函数式编程得概念</li>
<li>理解Functional Interface（函数式接口）是学习Java8 lambda表达式得关键所在</li>
<li>函数式接口得定义：<ul>
<li>任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口</li>
<li>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaDemo1 &#123;</span><br><span class="line"></span><br><span class="line">    //3.静态内部类</span><br><span class="line">    static class Like2 implements ILike&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void lambda() &#123;</span><br><span class="line">            System.out.println(&quot;i like lambda2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ILike like = new Like();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        like = new Like2();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        //4.局部内部类</span><br><span class="line">        class Like3 implements ILike&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void lambda() &#123;</span><br><span class="line">                System.out.println(&quot;i like lambda3&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        like = new Like3();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        //5.匿名内部类</span><br><span class="line">        like = new ILike() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void lambda() &#123;</span><br><span class="line">                System.out.println(&quot;i like lambda4&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        //6.用lambda简化</span><br><span class="line">        like = ()-&gt; &#123;</span><br><span class="line">            System.out.println(&quot;i like lambda5&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//1.定义一个函数式接口</span><br><span class="line">interface ILike&#123;</span><br><span class="line">    void lambda();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2.实现类</span><br><span class="line">class Like implements ILike&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void lambda() &#123;</span><br><span class="line">        System.out.println(&quot;i like lambda&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ILove love = null;</span><br><span class="line">        //简化1.参数类型</span><br><span class="line">        love = (a)-&gt;&#123;</span><br><span class="line">            System.out.println(&quot;i love you -&gt;&quot; + a);</span><br><span class="line">        &#125;;</span><br><span class="line">        //简化2.简化括号</span><br><span class="line">        love = a -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;i love you -&gt;&quot; + a);</span><br><span class="line">        &#125;;</span><br><span class="line">        //简化3.去掉花括号</span><br><span class="line">        love = a -&gt; System.out.println(&quot;i love you -&gt;&quot; + a);</span><br><span class="line">        love.love(520);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface ILove&#123;</span><br><span class="line">    void love(int a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>lambda表达式只能在有一行代码的情况下才能简化成为一行，如果有多好，那么就用代码块包裹</li>
<li>前提是接口为函数式接口</li>
<li>多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号</li>
</ul>
<h2 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h2><ul>
<li><p>真实对象和代理对象都要实现同一个接口</p>
</li>
<li><p>代理对象要代理真实角色</p>
</li>
<li><p>好处：</p>
<ul>
<li>代理对象可以做很多真实对象做不了得事情</li>
<li>真实对象专注做自己得事情</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class StaticProxy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        WeddingCompany weddingCompany = new WeddingCompany(new You());</span><br><span class="line">//        weddingCompany.HappyMarry();</span><br><span class="line">        You you = new You();</span><br><span class="line"></span><br><span class="line">        new Thread( ()-&gt; System.out.println(&quot;aaa&quot;)).start();</span><br><span class="line"></span><br><span class="line">        new WeddingCompany(you).HappyMarry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Marry&#123;</span><br><span class="line">    void HappyMarry();</span><br><span class="line">&#125;</span><br><span class="line">class You implements Marry&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void HappyMarry() &#123;</span><br><span class="line">        System.out.println(&quot;HAPPYMARRY&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class WeddingCompany implements Marry&#123;</span><br><span class="line">    private Marry target;</span><br><span class="line"></span><br><span class="line">    public WeddingCompany(Marry target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void HappyMarry() &#123;</span><br><span class="line">        before();</span><br><span class="line">        this.target.HappyMarry();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="E:\TyporaReport\java\image\进程状态.png" alt="线程状态"></p>
<h3 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h3><ul>
<li>setPriority(int newPriority)    更改线程优先级</li>
<li>static void sleep(long millis)    在指定的毫秒数内让当前正在执行的线程休眠</li>
<li>void join()    等待该线程终止</li>
<li>static void yield()    暂停当前正在执行的线程对象，并执行其他线程</li>
<li>void interrupt()    中断线程，别用这个方式</li>
<li>boolean isAlive()    测试线程是否处于活动状态</li>
</ul>
<h3 id="线程停止："><a href="#线程停止：" class="headerlink" title="线程停止："></a>线程停止：</h3><ul>
<li>建议线程正常停止—&gt;利用次数，不建议死循环</li>
<li>建议使用标志位–&gt;设置一个标志位</li>
<li>不要使用stop或者destroy等过时或JDK不建议使用的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class TestStop implements Runnable&#123;</span><br><span class="line">    //1.设置一个标志位</span><br><span class="line">    private boolean flag = true;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (flag)&#123;</span><br><span class="line">            System.out.println(&quot;run.......Thread&quot; + i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.设置一个公开的方法停止线程，转换标志位</span><br><span class="line">    public void stop()&#123;</span><br><span class="line">        this.flag = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestStop testStop = new TestStop();</span><br><span class="line">        new Thread(testStop).start();</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            System.out.println(&quot;main&quot;+i);</span><br><span class="line">            if(i==900)&#123;</span><br><span class="line">                testStop.stop();</span><br><span class="line">                System.out.println(&quot;线程该停止了&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><ul>
<li>sleep(时间)指定当前线程阻塞的毫秒数</li>
<li>sleep存在异常InterruptedException</li>
<li>sleep时间达到后线程进入就绪状态</li>
<li>sleep可以模拟网络延时，倒计时等</li>
<li>每一个对象都有一个锁，sleep不会释放锁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TestSleep2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Date startTime = new Date(System.currentTimeMillis());</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime));</span><br><span class="line">            startTime = new Date(System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void tenDown() throws InterruptedException &#123;</span><br><span class="line">        int num = 10;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(num--);</span><br><span class="line">            if(num&lt;=0)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h3><ul>
<li>礼让线程，让当前正在执行的线程暂停，但不阻塞</li>
<li>将线程从运行状态转为就绪状态</li>
<li>让cpu重新调度，礼让不一定成功！看CPU心情</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TestYield &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyYield myYield = new MyYield();</span><br><span class="line"></span><br><span class="line">        new Thread(myYield,&quot;a&quot;).start();</span><br><span class="line">        new Thread(myYield,&quot;b&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyYield implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;线程开始执行&quot;);</span><br><span class="line">        Thread.yield();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;线程停止执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程强制执行"><a href="#线程强制执行" class="headerlink" title="线程强制执行"></a>线程强制执行</h3><ul>
<li>Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</li>
<li>可以想象成插队</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TestJoin implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 500; i++) &#123;</span><br><span class="line">            System.out.println(&quot;线程vip来了&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        TestJoin testJoin = new TestJoin();</span><br><span class="line">        Thread thread = new Thread(testJoin);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 500; i++) &#123;</span><br><span class="line">            if(i==200)&#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;main&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h3><p>Thread.State：线程状态。线程可以处于以下状态之一</p>
<ul>
<li>NEW</li>
<li>RUNNABLE</li>
<li>BLOCKED</li>
<li>WAITING</li>
<li>TIMED_WAITING</li>
<li>TERMINATED</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class TestState &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t= new Thread( ()-&gt;&#123;</span><br><span class="line">            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;/////&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.State state = t.getState();</span><br><span class="line">        System.out.println(state);    //NEW</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        state = t.getState();</span><br><span class="line">        System.out.println(state);    //RUNNABLE</span><br><span class="line"></span><br><span class="line">        while(state!=Thread.State.TERMINATED)&#123;</span><br><span class="line">            Thread.sleep(200);</span><br><span class="line">            state = t.getState();</span><br><span class="line">            System.out.println(state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><ul>
<li>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度那个线程来执行</li>
<li>现成的优先级用数字表示，范围从1~10<ul>
<li>Thread.MIN_PRIORITY = 1</li>
<li>Thread.MAX_PRIORITY = 10</li>
<li>Thread.NORM_PRIORITY = 5</li>
</ul>
</li>
<li>使用一些方式改变或获取优先级<ul>
<li>getPriority()</li>
<li>setPriority(int x)</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class TestPriority &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+Thread.currentThread().getPriority());</span><br><span class="line"></span><br><span class="line">        MyPriority myPriority = new MyPriority();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(myPriority);</span><br><span class="line">        Thread t2 = new Thread(myPriority);</span><br><span class="line">        Thread t3 = new Thread(myPriority);</span><br><span class="line">        Thread t4 = new Thread(myPriority);</span><br><span class="line">        Thread t5 = new Thread(myPriority);</span><br><span class="line">        Thread t6 = new Thread(myPriority);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        t2.setPriority(7);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t3.setPriority(4);</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        t4.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">//        t5.setPriority(-1);</span><br><span class="line">//        t5.start();</span><br><span class="line">//</span><br><span class="line">//        t6.setPriority(11);</span><br><span class="line">//        t6.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyPriority implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+Thread.currentThread().getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="收获线程"><a href="#收获线程" class="headerlink" title="收获线程"></a>收获线程</h3><ul>
<li>线程分为用户线程和守护线程</li>
<li>虚拟机必须确保用户线程执行完毕</li>
<li>虚拟机不用等待守护线程执行完毕</li>
<li>如，后台记录操作日志，监控内存，垃圾回收等待</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class TextDaemon &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        God god = new God();</span><br><span class="line">        You you = new You();</span><br><span class="line"></span><br><span class="line">        Thread thread = new Thread(god);</span><br><span class="line">        thread.setDaemon(true);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        new Thread(you).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//上帝</span><br><span class="line">class God implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)</span><br><span class="line">            System.out.println(&quot;上帝保佑着你&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//你</span><br><span class="line">class You implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 36500; i++) &#123;</span><br><span class="line">            System.out.println(&quot;你一生都开心的活着&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;byebye&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程同步（重点）"><a href="#线程同步（重点）" class="headerlink" title="线程同步（重点）"></a>线程同步（重点）</h2><ul>
<li>线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用</li>
<li>形成条件：队列+锁</li>
<li>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题：<ul>
<li>一个线程持有锁会导致其他所有需要此锁的线程挂起</li>
<li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题</li>
</ul>
</li>
</ul>
<p>线程不安全的集合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class UnsafeList &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                list.add(Thread.currentThread().getName());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><ul>
<li>由于我们可以通过private关键字来保证数据对象只能被方法访问，所以只需要针对方法提出一套机制，也就是synchronized关键字，它包括两种用法：synchronized方法和synchronzied块<ul>
<li>同步方法：public synchronized void method(int args){}</li>
</ul>
</li>
<li>synchronzied方法控制对对象的访问，每个对象对应一把锁，每个synchronzied方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，知道该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行<ul>
<li>缺陷：若将一个大的方法申明为synchronzied将会影响效率</li>
<li>弊端：方法里需要修改的内容才需要锁，锁的太多，浪费资源</li>
</ul>
</li>
</ul>
<h3 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h3><ul>
<li>同步块：synchronzied(Obj){}</li>
<li>Obj称之为同步监视器<ul>
<li>Obj可以是任何对象，但是推荐使用共享资源作为同步监视器</li>
<li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class</li>
</ul>
</li>
<li>同步监视器的执行过程<ul>
<li>第一个线程访问，锁定同步监视器，执行其中代码</li>
<li>第二个线程访问，发现同步监视器被锁定，无法访问</li>
<li>第一个线程访问完毕，解锁同步监视器</li>
<li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问 </li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo4 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BuyTicket ticket = new BuyTicket();</span><br><span class="line"></span><br><span class="line">        new Thread(ticket,&quot;A&quot;).start();</span><br><span class="line">        new Thread(ticket,&quot;B&quot;).start();</span><br><span class="line">        new Thread(ticket,&quot;C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BuyTicket implements Runnable&#123;</span><br><span class="line">    //票数</span><br><span class="line">    private int ticketNums = 10;</span><br><span class="line">    boolean flag = true;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        while(flag)&#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                buy();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private synchronized void buy() throws InterruptedException &#123;</span><br><span class="line">        if(ticketNums&lt;=0)&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;-&gt; 拿到了第&quot; + ticketNums-- + &quot;张票&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁的对象是变化的量，需要增删改的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class UnsafeList &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line"></span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">                synchronized (list)&#123;</span><br><span class="line">                    list.add(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul>
<li>多个线程各自占有一些共有资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有“两个以上对象的锁”时，就可能发生死锁问题</li>
</ul>
<p>产生死锁的四个必要条件：</p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLock &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Makeup g1 = new Makeup(0,&quot;灰姑娘&quot;);</span><br><span class="line">        Makeup g2 = new Makeup(1,&quot;白雪公主&quot;);</span><br><span class="line"></span><br><span class="line">        g1.start();</span><br><span class="line">        g2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//口红</span><br><span class="line">class Lipatick&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//镜子</span><br><span class="line">class Mirror&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Makeup extends Thread &#123;</span><br><span class="line">    //需要的资源只有一份，用static来保证只有一份</span><br><span class="line">    static Lipatick lipatick = new Lipatick();</span><br><span class="line">    static Mirror mirror = new Mirror();</span><br><span class="line"></span><br><span class="line">    int choice;//选择</span><br><span class="line">    String girlName;//使用化妆品的人</span><br><span class="line"></span><br><span class="line">    public Makeup(int choice, String girlName) &#123;</span><br><span class="line">        this.choice = choice;</span><br><span class="line">        this.girlName = girlName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            makeup();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //化妆，互相持有对方的锁，就是需要拿到对方的资源</span><br><span class="line">    private void makeup() throws InterruptedException &#123;</span><br><span class="line">        if (choice == 0) &#123;</span><br><span class="line">            synchronized (lipatick) &#123;</span><br><span class="line">                System.out.println(this.girlName + &quot;获得口红的锁&quot;);</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                synchronized (mirror) &#123;</span><br><span class="line">                    System.out.println(this.girlName + &quot;获得镜子的锁&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            /*</span><br><span class="line">            //原本是拿着镜子用口红，现在是拿镜子，放镜子，那口红</span><br><span class="line">            synchronized (lipatick) &#123;</span><br><span class="line">                System.out.println(this.girlName + &quot;获得口红的锁&quot;);</span><br><span class="line">                Thread.sleep(1000);       </span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (mirror) &#123;</span><br><span class="line">                    System.out.println(this.girlName + &quot;获得镜子的锁&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            */</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            synchronized (mirror) &#123;</span><br><span class="line">                System.out.println(this.girlName + &quot;获得镜子的锁&quot;);</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                synchronized (lipatick) &#123;</span><br><span class="line">                    System.out.println(this.girlName + &quot;获得口红的锁&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lock（锁）"><a href="#Lock（锁）" class="headerlink" title="Lock（锁）"></a>Lock（锁）</h2><ul>
<li>从JDK5.0开始，Java提供了更强大的线程同步机制—-通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当</li>
<li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象</li>
<li>ReentrantLock类实现了Lock，它拥有与synchronized相同的并分性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显示加锁、释放锁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class TestLock &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestLock2 testLock2 = new TestLock2();</span><br><span class="line"></span><br><span class="line">        new Thread(testLock2).start();</span><br><span class="line">        new Thread(testLock2).start();</span><br><span class="line">        new Thread(testLock2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestLock2 implements Runnable&#123;</span><br><span class="line">    int ticketNums = 10;</span><br><span class="line"></span><br><span class="line">    //定义lock锁</span><br><span class="line">    private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();//加锁</span><br><span class="line">                if(ticketNums&gt;0)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(ticketNums--);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized与Lock对比"><a href="#synchronized与Lock对比" class="headerlink" title="synchronized与Lock对比"></a>synchronized与Lock对比</h2><ul>
<li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，除了作用域自动释放</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li>
<li>优先使用顺序：<ul>
<li>Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源）&gt;同步方法（在方法体之外）</li>
</ul>
</li>
</ul>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><ul>
<li>应用场景：生产者和消费者问题<ul>
<li>假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费</li>
<li>如果仓库中没有产品，则生产者将产品放入仓库，否则停止生成并等待，直到仓库中的产品被消费者取走为止</li>
<li>如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止</li>
</ul>
</li>
<li>这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件</li>
<li>在此问题中，仅有synchronized是不够的<ul>
<li>synchronized可阻止并发更新同一个共享资源，实现了同步</li>
<li>synchronized不能用来实现不同线程之间的消息传递（通信）</li>
</ul>
</li>
</ul>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><ul>
<li>wait()    表示线程一直等待，知道其他线程通知，与sleep不同，会释放锁</li>
<li>wait(long timeout)    指定等待的毫秒数</li>
<li>notify()    唤醒一个处于等待状态的线程</li>
<li>notifyAll()    唤醒同一个对象上所有调用wait()方法的线程，优先级高的线程优先调度</li>
<li>均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常</li>
</ul>
<h3 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h3><ul>
<li>生产者：负责生产数据的模块（可能是方法，对象，线程，进程）</li>
<li>消费者：负责处理数据的模块（可能是方法，对象，线程，进程）</li>
<li>缓冲区：消费者不能直接使用生产者的数据，他们之间有个“缓冲区”</li>
<li>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">public class TestPC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SynContainer synContainer = new SynContainer();</span><br><span class="line"></span><br><span class="line">        new Productor(synContainer).start();</span><br><span class="line">        new Consumer(synContainer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//生产者</span><br><span class="line">class Productor extends Thread&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line">    public Productor(SynContainer container)&#123;</span><br><span class="line">        this.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //生产</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                container.push(new Chicken(i));</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;生产了&quot;+ i + &quot;只鸡&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//消费者</span><br><span class="line">class Consumer extends Thread&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line">    public Consumer(SynContainer container)&#123;</span><br><span class="line">        this.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //消费</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;消费了--&gt;&quot; + container.pop().id +&quot;只鸡&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//产品</span><br><span class="line">class Chicken&#123;</span><br><span class="line">    int id;</span><br><span class="line"></span><br><span class="line">    public Chicken(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//缓冲区</span><br><span class="line">class SynContainer&#123;</span><br><span class="line">    //容器大小</span><br><span class="line">    Chicken[] chickens = new Chicken[10];</span><br><span class="line">    //计数器</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    //生产者放入产品</span><br><span class="line">    public synchronized void push(Chicken chicken) throws InterruptedException &#123;</span><br><span class="line">        //如果容器满了，就需要等待消费者消费</span><br><span class="line">        if(count==chickens.length)&#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果没满，生产者丢入产品</span><br><span class="line">        chickens[count] = chicken;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        //通知消费者消费</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //消费者消费产品</span><br><span class="line">    public synchronized Chicken pop() throws InterruptedException &#123;</span><br><span class="line">        //判断能否消费</span><br><span class="line">        if(count == 0)&#123;</span><br><span class="line">            //等待生产者生成</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count--;</span><br><span class="line">        Chicken chicken = chickens[count];</span><br><span class="line"></span><br><span class="line">        this.notifyAll();</span><br><span class="line">        return chicken;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="信号灯法"><a href="#信号灯法" class="headerlink" title="信号灯法"></a>信号灯法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public class TestPC2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TV tv = new TV();</span><br><span class="line">        new Player(tv).start();</span><br><span class="line">        new Watcher(tv).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//生产者--&gt; 演员</span><br><span class="line">class Player extends Thread&#123;</span><br><span class="line">    TV tv;</span><br><span class="line">    public Player(TV tv)&#123;</span><br><span class="line">        this.tv=tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            if(i%2==0)</span><br><span class="line">                this.tv.play(&quot;快乐大本营播放中&quot;);</span><br><span class="line">            else</span><br><span class="line">                this.tv.play(&quot;抖音：记录美好生活&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//消费者--&gt; 观众</span><br><span class="line">class Watcher extends Thread&#123;</span><br><span class="line">    TV tv;</span><br><span class="line">    public Watcher(TV tv)&#123;</span><br><span class="line">        this.tv=tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            tv.watch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//产品--&gt; 节目</span><br><span class="line">class TV&#123;</span><br><span class="line">    //演员表演，观众等待 T</span><br><span class="line">    //观众观看，演员等待 F</span><br><span class="line">    String voice; //表演的节目</span><br><span class="line">    boolean flag = true;</span><br><span class="line"></span><br><span class="line">    //表演</span><br><span class="line">    public synchronized void play(String voice)&#123;</span><br><span class="line">        if (!flag)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;演员表演了：&quot;+voice);</span><br><span class="line"></span><br><span class="line">        this.notify();</span><br><span class="line">        this.voice=voice;</span><br><span class="line">        this.flag = !this.flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //观看</span><br><span class="line">    public synchronized void watch()&#123;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;观看了：&quot;+voice);</span><br><span class="line">        this.notify();</span><br><span class="line">        this.flag = !this.flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大</li>
<li>思路：提前创建好多个线程，放入线程池中，使用是直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具</li>
<li>好处：<ul>
<li>提高响应时间（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理（…）</li>
</ul>
</li>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后终止</li>
<li>JDK5.0起提供了线程池相关API：ExecutorService和Executors</li>
<li>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor<ul>
<li>void execute(Runnable command)：    执行任务/命令，没有返回值，一般用来执行Runnable</li>
<li><T> Future<T> submit(Callable<T> task)： 执行任务，有返回值，一般用来执行Callable</li>
<li>void shutdown()：    关闭连接池</li>
</ul>
</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TestPool &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1.创建服务，创建线程池</span><br><span class="line">        //newFixedThreadPool 参数为：线程池大小</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(10);</span><br><span class="line"></span><br><span class="line">        executorService.execute(new MyThread());</span><br><span class="line">        executorService.execute(new MyThread());</span><br><span class="line">        executorService.execute(new MyThread());</span><br><span class="line">        executorService.execute(new MyThread());</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="总结线程的创建"><a href="#总结线程的创建" class="headerlink" title="总结线程的创建"></a>总结线程的创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadNew &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new MyThread1().start();</span><br><span class="line"></span><br><span class="line">        new Thread(new MyThread2()).start();</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new MyThread3());</span><br><span class="line">        new Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Integer integer = futureTask.get();</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//1.继承Thread类</span><br><span class="line">class MyThread1 extends Thread&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;MyThread1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2.实现Runnable接口</span><br><span class="line">class MyThread2 implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;MyThread2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3.实现Callable接口</span><br><span class="line">class MyThread3 implements Callable&lt;Integer&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyThread3&quot;);</span><br><span class="line">        return 100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="注解和反射"><a href="#注解和反射" class="headerlink" title="注解和反射"></a>注解和反射</h1><p><img src="E:\TyporaReport\java\image\注解和反射.png" alt="注解和反射"></p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><p>Annotation是从JDK5.0开始引入的新技术</p>
<p>Annotation的作用：</p>
<ul>
<li>不是程序本身，可以对程序作出解释。（这一点和注释（comment）没什么区别）</li>
<li>可以被其他程序（如：编译器等）读取</li>
</ul>
<p>Annotation的格式：</p>
<ul>
<li>注解是以”@注释名”在代码中存在的，还可以添加一些参数值，如：@SuppressWarnings(value=:unchecked”)</li>
</ul>
<p>Annotation在那里使用？</p>
<ul>
<li>可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问</li>
</ul>
<h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><ul>
<li>@Override：定义在java.lang.Override中，此注释只适用于修斯方法，表示一个方法声明打算重写超类中的另一个方法声明</li>
<li>@Deprecated：定义在java.lang.Deprecated中，此注释可以用于修斯方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择</li>
<li>@SuppressWarnings：定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息<ul>
<li>与前两个注释不同，需要添加一个参数才能正确使用</li>
<li>@SuppressWarnings(“all”)</li>
<li>SuppressWarnings(“unchecked”)</li>
<li>SuppressWarnings(value={“unchecked”,”deprecation”})</li>
<li>等等……</li>
</ul>
</li>
</ul>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>  元注解的作用就是负责注解其他注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明</p>
<ul>
<li>@Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</li>
<li>@Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期<ul>
<li>SOURCE &lt; CLASS &lt; RUNTIME</li>
</ul>
</li>
<li>@Document：说明该注解将被包含在javadoc中</li>
<li>@Inherited：说明子类可以继承父类中的该注解</li>
</ul>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>使用 @interface自定义注解时，自动继承了java.lang.annotation.Annotation接口</p>
<ul>
<li>@interface用来声明一个注解，格式：public @ interface 注解名 {定义内容}</li>
<li>其中的每一个方法实际上是声明了一个配置参数</li>
<li>方法的名称就是参数的名称</li>
<li>返回值类型就是参数的类型（返回值只能是基本类型，Class，String，Enum）</li>
<li>可以通过default来声明参数的默认值</li>
<li>如果只有一个参数成员，一般参数名为value</li>
<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">    </span><br><span class="line">    //注解可以显示复制，如果没有默认值，则必须给注解赋值</span><br><span class="line">    @MyAnnotation(age = 10,name = &quot;xingchuwu&quot;)</span><br><span class="line">    public void test()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @MyAnnotation2(&quot;xingchuwu&quot;)</span><br><span class="line">    public void test2()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@interface MyAnnotation&#123;</span><br><span class="line">    //注解的参数 ： 参数类型 + 参数名 ();</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line">    int age() ;</span><br><span class="line">    int id() default -1;//如果默认值为-1，代表不存在</span><br><span class="line">    </span><br><span class="line">    String[] schools() default &#123;&quot;aaa&quot;,&quot;bbb&quot;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@interface MyAnnotation2&#123;</span><br><span class="line">    //当注解只有一个参数时，推荐使用value，此时赋值时可不写value</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ul>
<li><p>动态语言：是一类在运行时可以改变其结果的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或时其他结果上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构</p>
<ul>
<li>主要动态语言：Object-C、C#、JavaScript、PHP、Python等</li>
</ul>
</li>
<li><p>静态语言：运行时结构不可变的语言。</p>
<ul>
<li>如Java、C、C++</li>
</ul>
</li>
<li><p>java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性</p>
</li>
</ul>
<h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><ul>
<li>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</li>
<li>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过镜子可以看到类的结构，姑称之为：反射</li>
</ul>
<p>功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>生成动态代理</li>
<li>。。。。。。</li>
</ul>
<p>优点：</p>
<ul>
<li>可以实现动态创建对象和编译，体现出很大的灵活性</li>
</ul>
<p>缺点：</p>
<ul>
<li>对性能有影响。</li>
</ul>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>在Object类中定义了以下方法，此方法将被所有子类继承</p>
<ul>
<li>public final Class getClass()</li>
</ul>
<h3 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h3><ul>
<li>static Class forName(String name)    返回指定类名name的Class对象</li>
<li>Object newInstance()    调用缺省构造函数，返回Class对象的一个实例</li>
<li>getName()    返回此Class对象所表示的实体（类，接口，数组类或void）的名称</li>
<li>Class getSuperClass()    返回当前Class对象的父类的Class对象</li>
<li>Class[] getInterfaces()    获取当前Class对象的接口</li>
<li>ClassLoader getClassLoader    返回该类的类加载器</li>
<li>Constructor[] getConstructors()    返回一个包含某些Constructor对象的数组</li>
<li>Method getMothod(String name,Class.. T)    返回一个Method对象，此对象的形参类型为paramType</li>
<li>Field[] getDeclaredFields()    返回Field对象的一个数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class Deni2 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        Person person = new Student();</span><br><span class="line">        System.out.println(&quot;这个人是：&quot; + person.name);</span><br><span class="line"></span><br><span class="line">        //方式一：通过对象获得</span><br><span class="line">        Class  c1 = person.getClass();</span><br><span class="line">        System.out.println(c1.hashCode());</span><br><span class="line"></span><br><span class="line">        //方法二：forname获得</span><br><span class="line">        Class c2 = Class.forName(&quot;com.chang.base.myReflection.Student&quot;);</span><br><span class="line">        System.out.println(c2.hashCode());</span><br><span class="line"></span><br><span class="line">        //方式三：通过类名.class获得</span><br><span class="line">        Class c3 = Student.class;</span><br><span class="line">        System.out.println(c3.hashCode());</span><br><span class="line"></span><br><span class="line">        //方式四：基本内置类型的包装类都有一个Type属性</span><br><span class="line">        Class c4 = Integer.TYPE;</span><br><span class="line">        System.out.println(c4.hashCode());</span><br><span class="line"></span><br><span class="line">        //获得父类类型</span><br><span class="line">        Class c5 = c1.getSuperclass();</span><br><span class="line">        System.out.println(c5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    public Student() &#123;</span><br><span class="line">        this.name = &quot;Student&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Teacher extends Person&#123;</span><br><span class="line">    public Teacher()&#123;</span><br><span class="line">        this.name = &quot;Teacher&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="那些类型有Class对象"><a href="#那些类型有Class对象" class="headerlink" title="那些类型有Class对象"></a>那些类型有Class对象</h3><ul>
<li>class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</li>
<li>interface：接口</li>
<li>[]：数组</li>
<li>enum：枚举</li>
<li>annotation：注解@interface</li>
<li>primitive type：基本数据类型</li>
<li>void</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class c1 = Object.class;    //类</span><br><span class="line">        Class c2 = Comparable.class;    //接口</span><br><span class="line">        Class c3 = String[].class;    //一维数组</span><br><span class="line">        Class c4 = int[][].class;    //二维数组</span><br><span class="line">        Class c5 = Override.class;    //注解</span><br><span class="line">        Class c6 = ElementType.class;    //枚举</span><br><span class="line">        Class c7 = Integer.class;    //基本数据类型</span><br><span class="line">        Class c8 = void.class;    //void</span><br><span class="line">        Class c9 = Class.class;    //Class</span><br><span class="line"></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        System.out.println(c4);</span><br><span class="line">        System.out.println(c5);</span><br><span class="line">        System.out.println(c6);</span><br><span class="line">        System.out.println(c7);</span><br><span class="line">        System.out.println(c8);</span><br><span class="line">        System.out.println(c9);</span><br><span class="line"></span><br><span class="line">        //只有元素类型与维度一样，就是同一个Class</span><br><span class="line">        int[] a = new int[10];</span><br><span class="line">        int[] b = new int[100];</span><br><span class="line">        System.out.println(a.getClass().hashCode());</span><br><span class="line">        System.out.println(b.getClass().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java内存分析"><a href="#java内存分析" class="headerlink" title="java内存分析"></a>java内存分析</h3><p>java内容：</p>
<ul>
<li>堆<ul>
<li>存放new的对象和数据</li>
<li>可以被所有的线程共享，不会存放别的对象引用</li>
</ul>
</li>
<li>栈<ul>
<li>存放基本变量类型（会包含这个基本类型的具体数值）</li>
<li>引用对象的变量（会存放这个引用在堆里面的具体地址）</li>
</ul>
</li>
<li>方法区<ul>
<li>可以被所有的线程共享</li>
<li>包含了所有的class和static变量</li>
</ul>
</li>
</ul>
<h3 id="类的加载与ClassLoader的理解"><a href="#类的加载与ClassLoader的理解" class="headerlink" title="类的加载与ClassLoader的理解"></a>类的加载与ClassLoader的理解</h3><ul>
<li>加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象</li>
<li>链接：将Java类的二进制代码合并到 JVM的运行状态之中的过程<ul>
<li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题</li>
<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程</li>
</ul>
</li>
<li>初始化：<ul>
<li>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化</li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A a = new A();</span><br><span class="line">        System.out.println(a.m);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">            1.加载到内存，会产生一个类对应Class对象</span><br><span class="line">            2.链接，链接结束后 m = 0</span><br><span class="line">            3.初始化&#123;</span><br><span class="line">                &lt;clinit&gt;()&#123;</span><br><span class="line">                    System.out.println(&quot;A类静态代码块初始化&quot;);</span><br><span class="line">                    m = 300;</span><br><span class="line">                    m = 100;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                m = 100;</span><br><span class="line">            &#125;</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;A类静态代码块初始化&quot;);</span><br><span class="line">        m = 300;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">        m = 300;</span><br><span class="line">        m = 100;</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    static int m = 100;</span><br><span class="line"></span><br><span class="line">    public A()&#123;</span><br><span class="line">        System.out.println(&quot;A类的无参构造初始化&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类初始化时间"><a href="#类初始化时间" class="headerlink" title="类初始化时间"></a>类初始化时间</h3><ul>
<li>类的主动引用（一定会发生类的初始化）<ul>
<li>当虚拟机启动，先初始化main方法所在的类</li>
<li>new一个类的对象</li>
<li>调用类的静态成员（除了final常量）和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则会先初始化它的父类</li>
</ul>
</li>
<li>类的被动引用（不会发生类的初始化）<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Main类被加载&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        //1.主动引用</span><br><span class="line">//        Son son = new Son();</span><br><span class="line"></span><br><span class="line">        //反射也会产生主动引用</span><br><span class="line">//        Class.forName(&quot;com.chang.base.myReflection.Son&quot;);</span><br><span class="line"></span><br><span class="line">        //不会产生类的引用的方法</span><br><span class="line">//        System.out.println(Son.b);</span><br><span class="line"></span><br><span class="line">//        Son[] arrays = new Son[5];</span><br><span class="line"></span><br><span class="line">        System.out.println(Son.M);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Father&#123;</span><br><span class="line"></span><br><span class="line">    static int b = 2;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;父类被加载&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;子类被加载&quot;);</span><br><span class="line">        m = 300;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int m = 100;</span><br><span class="line">    static final int M = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h3><ul>
<li>类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后再堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口</li>
<li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</li>
</ul>
<p>类加载器作用是用来把类（class）装载进内存的。JVM规范定义了如下类型的类的加载器：</p>
<ul>
<li>引导类加载器：用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库。该加载器无法直接获取</li>
<li>扩展类加载器：负责jre/lib/ext目录下的jar包或—D java.ext.dirs指定目录下的jar包装入工作库</li>
<li>系统类加载器：负责java -classpath 或—D java.class.path所指目录下的类与jar包装入工作，是最常用的加载器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class Demo6 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        //获取系统类的加载器</span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line"></span><br><span class="line">        //获取系统类加载器的父类加载器--&gt;扩展类加载器</span><br><span class="line">        ClassLoader parent = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(parent);</span><br><span class="line"></span><br><span class="line">        //获取扩展类加载器的父类加载器 --&gt; 根加载器（C/c++)</span><br><span class="line">        ClassLoader parent1 = parent.getParent();</span><br><span class="line">        System.out.println(parent1);</span><br><span class="line"></span><br><span class="line">        //测试当前类是哪个加载器加载的</span><br><span class="line">        ClassLoader classLoader = Class.forName(&quot;com.chang.base.myReflection.Demo6&quot;).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        //测试JDK内置的类是谁加载的</span><br><span class="line">        ClassLoader classLoader1 = Class.forName(&quot;java.lang.Object&quot;).getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);</span><br><span class="line"></span><br><span class="line">        //获得系统加载器可以加载的路径</span><br><span class="line">        String property = System.getProperty(&quot;java.class.path&quot;);</span><br><span class="line">        System.out.println(property);</span><br><span class="line">        </span><br><span class="line">        //双亲委派机制</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\charsets.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\deploy.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\ext\access-bridge-64.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\ext\cldrdata.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\ext\dnsns.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\ext\jaccess.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\ext\jfxrt.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\ext\localedata.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\ext\nashorn.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\ext\sunec.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\ext\sunjce_provider.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\ext\sunmscapi.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\ext\sunpkcs11.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\ext\zipfs.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\javaws.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\jce.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\jfr.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\jfxswt.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\jsse.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\management-agent.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\plugin.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\resources.jar;</span><br><span class="line">            E:\Java\jdk1.8\jre\lib\rt.jar;</span><br><span class="line">            E:\javadProgram\javaStudy\out\production\javaStudy;</span><br><span class="line">            E:\IntelliJ IDEA\lib\idea_rt.jar</span><br><span class="line"></span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h2><p>通过反射获取运行时类的完整结构：</p>
<p>Field、Method、Constructor、Superclass、Interface、Annot</p>
<ul>
<li>实现的全部接口</li>
<li>所继承的父类</li>
<li>全部的构造器</li>
<li>全部的方法</li>
<li>全部的Field</li>
<li>注解</li>
<li>。。。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class Demo7 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        Class c1 = Class.forName(&quot;com.chang.base.myReflection.User&quot;);</span><br><span class="line"></span><br><span class="line">        //获取类的名字</span><br><span class="line">        System.out.println(c1.getName());    //获得包名+类名</span><br><span class="line">        System.out.println(c1.getSimpleName());    //获得类名</span><br><span class="line">        System.out.println(&quot;=======================&quot;);</span><br><span class="line">        //获得类的属性</span><br><span class="line">        Field[] fields = c1.getFields();    //只能找到public属性</span><br><span class="line">        for(Field field : fields)&#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;------------------&quot;);</span><br><span class="line">        fields = c1.getDeclaredFields();    //找到全部的属性</span><br><span class="line">        for(Field field : fields)&#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;------------------&quot;);</span><br><span class="line">        //获取指定属性的值</span><br><span class="line">        Field name = c1.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(&quot;=======================&quot;);</span><br><span class="line">        //获得类的方法</span><br><span class="line">        Method[] methods = c1.getMethods();    //获得本类及其父类的全部public方法</span><br><span class="line">        for(Method method : methods)&#123;</span><br><span class="line">            System.out.println(&quot;getMethods&quot; + method);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;------------------&quot;);</span><br><span class="line">        methods = c1.getDeclaredMethods();    //获得本类的所有方法</span><br><span class="line">        for(Method method : methods)&#123;</span><br><span class="line">            System.out.println(&quot;getDeclaredMethods：&quot; + method);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;------------------&quot;);</span><br><span class="line">        //获得指定方法</span><br><span class="line">        //重载</span><br><span class="line">        Method getName = c1.getMethod(&quot;getName&quot;,null);</span><br><span class="line">        Method setName = c1.getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">        System.out.println(getName);</span><br><span class="line">        System.out.println(setName);</span><br><span class="line">        System.out.println(&quot;=======================&quot;);</span><br><span class="line">        //获得构造器</span><br><span class="line">        Constructor[] constructors = c1.getConstructors();    //获得public</span><br><span class="line">        for(Constructor constructor : constructors)&#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        constructors = c1.getDeclaredConstructors();    //获得全部</span><br><span class="line">        for(Constructor constructor : constructors)&#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;------------------&quot;);</span><br><span class="line">        //获取指定构造器</span><br><span class="line">        Constructor declaredConstructor = c1.getDeclaredConstructor(String.class, int.class, int.class);</span><br><span class="line">        System.out.println(&quot;指定：&quot; + declaredConstructor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态创建对象执行方法"><a href="#动态创建对象执行方法" class="headerlink" title="动态创建对象执行方法"></a>动态创建对象执行方法</h2><p>创建类的对象：调用Class对象的newInstance()方法</p>
<ul>
<li>类必须有一个无参数的构造器</li>
<li>类的构造器的访问权限需要足够</li>
</ul>
<p>没有无参数的构造器：</p>
<ul>
<li>通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器</li>
<li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数</li>
<li>通过Constructor实例化对象</li>
</ul>
<h3 id="调用指定的方法："><a href="#调用指定的方法：" class="headerlink" title="调用指定的方法："></a>调用指定的方法：</h3><ul>
<li>通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型</li>
<li>之后使用Object invoke(Object obj,Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息</li>
</ul>
<h3 id="setAccessible"><a href="#setAccessible" class="headerlink" title="setAccessible"></a>setAccessible</h3><ul>
<li>Method和Field、Constructor对象都有setAccessible方法</li>
<li>setAccessible作用时启动和禁用访问安全检查的开关</li>
<li>参数值为true则知指示反射的对象在使用时应该取消java语言访问检查<ul>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true</li>
<li>使得原本无法访问的私有成员也可以访问</li>
</ul>
</li>
<li>参数值为false则指示反射的对象应该实施java语言访问检查</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Demo8 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        Class c1 = Class.forName(&quot;com.chang.base.myReflection.User&quot;);</span><br><span class="line"></span><br><span class="line">        //构造一个对象</span><br><span class="line">        User user = (User)c1.newInstance();    //本质是调用了类的无参构造器</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        //通过构造器创建对象</span><br><span class="line">        Constructor constructor = c1.getDeclaredConstructor(String.class,int.class,int.class);</span><br><span class="line">        User user2 = (User)constructor.newInstance(&quot;xingchuwu&quot;,100,10);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line"></span><br><span class="line">        //通过反射调用普通方法</span><br><span class="line">        User user3 = (User)c1.newInstance();</span><br><span class="line">        //通过反射获取一个方法</span><br><span class="line">        Method setName = c1.getDeclaredMethod(&quot;setName&quot;, String.class);</span><br><span class="line"></span><br><span class="line">        //invoke : 激活的意思</span><br><span class="line">        // (对象，”方法的值“)</span><br><span class="line">        setName.invoke(user3,&quot;xingchuwu1&quot;);</span><br><span class="line">        System.out.println(user3);</span><br><span class="line"></span><br><span class="line">        //通过反射操作属性</span><br><span class="line">        User user4 = (User)c1.newInstance();</span><br><span class="line">        Field name = c1.getDeclaredField(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line">        //不能直接操作私有属性，需要关闭程序的安全检测</span><br><span class="line">        name.setAccessible(true);</span><br><span class="line">        name.set(user4,&quot;hello&quot;);</span><br><span class="line">        System.out.println(user4.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Demo9 &#123;</span><br><span class="line">    public static void main(String[] args) throws InvocationTargetException, NoSuchMethodException, IllegalAccessException &#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //普通方式调用    3ms</span><br><span class="line">    public static void test1()&#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        for(int i=0; i&lt;1000000000; i++)&#123;</span><br><span class="line">            user.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;普通方式执行10亿次：&quot; + (endTime - startTime) + &quot;ms&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //反射方式调用    1642ms</span><br><span class="line">    public static void test2() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method method = c1.getDeclaredMethod(&quot;getName&quot;,null);</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        for(int i=0; i&lt;1000000000; i++)&#123;</span><br><span class="line">            method.invoke(user,null);</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;反射方式执行10亿次：&quot; + (endTime - startTime) + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //反射方式调用 关闭检测    1046ms</span><br><span class="line">    public static void test3() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        Class c1 = user.getClass();</span><br><span class="line">        Method method = c1.getDeclaredMethod(&quot;getName&quot;,null);</span><br><span class="line">        method.setAccessible(true);</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        for(int i=0; i&lt;1000000000; i++)&#123;</span><br><span class="line">            method.invoke(user,null);</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;反射方式执行10亿次：&quot; + (endTime - startTime) + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射操作泛型（了解即可）"><a href="#反射操作泛型（了解即可）" class="headerlink" title="反射操作泛型（了解即可）"></a>反射操作泛型（了解即可）</h2><ul>
<li>Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型有关的类型全部擦除</li>
<li>为了通过反射操作这些类型，Java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型</li>
<li>ParameterizedType：表示一种参数化类型，如Collection<String></li>
<li>GenericArrayType：表示一种元素类型时参数化类型或者类型变量的数组类型</li>
<li>TypeVariable：是各种类型变量的公共父接口</li>
<li>WildcardType：代表一种通配符类型表达式</li>
</ul>
<h2 id="反射操作注解"><a href="#反射操作注解" class="headerlink" title="反射操作注解"></a>反射操作注解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">public class Demo10 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123;</span><br><span class="line">        Class c1 = Class.forName(&quot;com.chang.base.myReflection.Student2&quot;);</span><br><span class="line"></span><br><span class="line">        //通过反射获得注解</span><br><span class="line">        Annotation[] annotations = c1.getAnnotations();</span><br><span class="line">        for(Annotation annotation : annotations)&#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获得注解的value的值</span><br><span class="line">        ClassAnnotation classAnnotation = (ClassAnnotation) c1.getAnnotation(ClassAnnotation.class);</span><br><span class="line">        String value = classAnnotation.value();</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        //获得类指定的注解</span><br><span class="line">        Field f = c1.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        FieldAnnotation fieldAnnotation = f.getAnnotation(FieldAnnotation.class);</span><br><span class="line">        System.out.println(fieldAnnotation.columnName());</span><br><span class="line">        System.out.println(fieldAnnotation.type());</span><br><span class="line">        System.out.println(fieldAnnotation.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ClassAnnotation(&quot;db_student&quot;)</span><br><span class="line">class Student2&#123;</span><br><span class="line">    @FieldAnnotation(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length = 10)</span><br><span class="line">    private int age;</span><br><span class="line">    @FieldAnnotation(columnName = &quot;db_id&quot;,type = &quot;int&quot;,length = 10)</span><br><span class="line">    private int id;</span><br><span class="line">    @FieldAnnotation(columnName = &quot;db_name&quot;,type = &quot;varchar&quot;,length = 10)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Student2() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student2(int age, int id, String name) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student2&#123;&quot; +</span><br><span class="line">                &quot;age=&quot; + age +</span><br><span class="line">                &quot;, id=&quot; + id +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//类名的注解</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@interface ClassAnnotation&#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//属性的注解</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@interface FieldAnnotation&#123;</span><br><span class="line">    String columnName();</span><br><span class="line">    String type();</span><br><span class="line">    int length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JDK8新特性"><a href="#JDK8新特性" class="headerlink" title="JDK8新特性"></a>JDK8新特性</h1><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="Lambda和匿名内部类在使用上的区别："><a href="#Lambda和匿名内部类在使用上的区别：" class="headerlink" title="Lambda和匿名内部类在使用上的区别："></a>Lambda和匿名内部类在使用上的区别：</h3><ul>
<li>所需的类型不一样：<ul>
<li>匿名内部类：需要的类型可以是类，抽象类，接口</li>
<li>Lambda表达式，需要的类型必须是接口</li>
</ul>
</li>
<li>抽象方法的数量不一样<ul>
<li>匿名内部类所需的接口中抽象方法的数量随意</li>
<li>Lambda表达式所需的接口只能有一个抽象方法</li>
</ul>
</li>
<li>实现原理不同<ul>
<li>匿名内部类是在编译后会形成class</li>
<li>Lambda表达式是在程序运行的时候动态生成class</li>
</ul>
</li>
</ul>
<p>小结：当接口中只有一个抽象方法时，建议使用Lambda表达式，其他情况还是需要使用匿名内部类</p>
<h2 id="集合之Stream流式操作"><a href="#集合之Stream流式操作" class="headerlink" title="集合之Stream流式操作"></a>集合之Stream流式操作</h2><h2 id="接口的增强"><a href="#接口的增强" class="headerlink" title="接口的增强"></a>接口的增强</h2><p>JDK8接口新增两个方法：</p>
<ul>
<li>默认方法</li>
<li>静态方法</li>
</ul>
<p>JDK8以前的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">	静态常量;</span><br><span class="line">	抽象方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK8的接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">	静态常量;</span><br><span class="line">	抽象方法;</span><br><span class="line">	默认方法;</span><br><span class="line">	静态方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>在JDK 8以前接口中只能有抽象方法。存在以下问题：</p>
<p>如果给接口新增抽象方法，所有实现类都必须重写这个抽象方法。不利于接口的扩展</p>
<p>因此，在JDK 8时为接口新增了默认方法，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">	修饰符 default 返回值类型 方法名()&#123;</span><br><span class="line">		代码;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        B b = new B();</span><br><span class="line">        b.test1();    //实现方法一：直接调用接口的默认方法</span><br><span class="line">        C c = new C();</span><br><span class="line">        c.test1();    //实现方法二：重写接口的默认方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface A&#123;</span><br><span class="line">    public default void test1()&#123;</span><br><span class="line">        System.out.println(&quot;我是接口A的默认方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B implements A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C implements A&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        System.out.println(&quot;我是C类重写的默认方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>为了方便接口扩展，JDK 8为接口新增了静态方法</p>
<p>静态方法不能重写</p>
<p>格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">	修饰符 static 返回值类型 方法名()&#123;</span><br><span class="line">		代码;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A1.test1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface A1&#123;</span><br><span class="line">    public static void test1()&#123;</span><br><span class="line">        System.out.println(&quot;我是接口A1的静态方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="默认方法和静态方法的区别"><a href="#默认方法和静态方法的区别" class="headerlink" title="默认方法和静态方法的区别"></a>默认方法和静态方法的区别</h3><ul>
<li>默认方法通过实例调用，静态方法通过接口名调用</li>
<li>默认方法可以被继承，实现类可以直接使用接口默认方法，也可以重写接口默认方法</li>
<li>静态方法不能被继承，实现类不能重写接口静态方法，只能使用接口名调用</li>
</ul>
<p>小结：</p>
<p>如果这个方法需要被实现类继承或重写，使用默认方法，否则使用静态方法</p>
<h2 id="并行数组排序"><a href="#并行数组排序" class="headerlink" title="并行数组排序"></a>并行数组排序</h2><h2 id="Optional中避免Null检查"><a href="#Optional中避免Null检查" class="headerlink" title="Optional中避免Null检查"></a>Optional中避免Null检查</h2><h2 id="新的时间和日期API"><a href="#新的时间和日期API" class="headerlink" title="新的时间和日期API"></a>新的时间和日期API</h2><h2 id="可重复注解"><a href="#可重复注解" class="headerlink" title="可重复注解"></a>可重复注解</h2>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "https://xingchuwu.github.io/2022/01/14/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://xingchuwu.github.io/2022/01/14/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/";
            const title         = "「java基础语法」";
            const excerpt       = `基础快捷键12345678910Ctrl+d    //复制当前行到下一行Ctrl+Alt+I    //自动对齐Ctrl+左键    //查看文档Shift+点第一个和点最后一个    //多选Alt+Insert    //生成构...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    
                </div>
                <div class="pull-date">
                <span>最后编辑：2022-01-14</span>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            
            <div class="nav-next clearfix">
                <a title=" mysql" href="/2022/01/14/mysql/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar1.webp" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center"></p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                

            
                
            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2022/03/12/Spring/"><i class="fa  fa-book"></i> Spring</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/04/Mybatis/"><i class="fa  fa-book"></i> Mybatis</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/04/Javaweb/"><i class="fa  fa-book"></i> Javaweb</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/01/SMBMS/"><i class="fa  fa-book"></i> SMBMS</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/01/23/JVM-%E5%85%A5%E9%97%A8/"><i class="fa  fa-book"></i> JVM 入门</a>
            
          
        
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://t.me/CandyUnion"><i class="fa fa-telegram"></i></a></li>
                        
                        
                        
                        <li><a target="_blank" rel="me" href="https://nya.one/@Candinya"><i class="fa fa fa-share-alt-square"></i></a></li>
                        <li><a target="_blank" rel="nofollow" href="https://github.com/Candinya"><i class="fa fa-github"></i></a></li>
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2022 行初雾 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by 行初雾.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://unpkg.com/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://unpkg.com/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>

    <div>
        <canvas id="snow"></canvas>
        <script async type="text/javascript" src="/js/snow.min.js"></script>
    </div>


    <script async src="/js/candy.min.js"></script>



    <script defer src="https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="https://unpkg.com/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://unpkg.com/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>