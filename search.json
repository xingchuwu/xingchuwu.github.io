[{"title":"Spring","date":"2022-03-11T17:59:54.000Z","url":"/2022/03/12/Spring/","categories":[["undefined",""]],"content":"Spring简介 Spring：春天—&gt; 给软件行业带来了春天 2002，首次推出了Spring框架的雏形：interface21框架 2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版 Rod Johnson，Spring Frameework创始人，著名作者。 spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架 SSH：Struct2 + Spring + Hibernate SSM: SpringMvc + Spring + Mybatis 官网： 官方下载地址：repo.spring.io Github：spring-projects/spring-framework: Spring Framework (github.com) 优点 Spring是一个开源的免费的框架（容器） Spring是一个轻量级的、非入侵式的框架 控制反转（IOC），面向切面编程（AOP） 支持事务的处理，对框架整合的支持 总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架 组成 拓展在Spring的官网有这个介绍：现代化的java开发，说白了就是基于Spring的开发 Spring Boot 一个快速开发的脚手架 基于SpringBoot可以快速的开发单个微服务 约定大于配置 Spring Cloud SpringCloud是基于SpringBoot实现的 现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用 IOC理论推导IOC基础 UserDao接口 UserDaoImpl实现类 UserService业务接口 UserServiceImpl业务实现 在之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改代码！如果程序代码量十分大，修改一次的成本代价十分昂贵 我们使用一个set接口实现，已经发生了革命性的变化！ 之前，程序是主动创建对象，控制权在程序猿手上 使用了set注入后，程序不再具有主动性，而是变成了被动的接收对象 这种思想，从本质上解决了问题，我们程序猿不用再去管理对象的创建了，系统的耦合性大大降低，可以更加庄主的在业务的实现上！这是IOC的原型！ IOC本质控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方ioc容器，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。 Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。 采用基于XML的配置，Bean定义信息和Bean实现类本身是分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式，Spring中实现控制反转的是IOC容器，其实现方法是依赖注入(DI)。 HelloSpring 编写Hello实体类 编写我们的spring文件，这里命名为beans.xml 测试 IOC创建对象的方式 使用无参构造创建对象，默认！ 使用有参构造创建对象 下标赋值 类型 参数名 总结：在配置文件加载的时候，容器中管理的对象就已经初始化了 Spring配置别名 Bean的配置 importimport，一般用于团队开发使用，可以将多个配置文件，导入合并为一个 假设，现在项目种种那个有多个人开发，这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的！ 张三 李四 王五 applicationContext.xml 使用的时候，直接使用总的配置就可以了 依赖注入构造器注入Set方式注入【重点】 依赖注入：Set注入 依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器来注入 【环境搭建】 复杂类型 真是测试对象 beans.xml 测试类 完善注册信息 拓展方式注入我们可以使用p命令空间和c命令空间进行注入 官方介绍： 使用： 测试： 注意点：p命名空间和c命名空间不能直接使用，需要导入xml约束 bean的作用域 单例模式（Spring默认机制） 原型模式：每次从容器中get的时候，都会产生一个新对象 其余的request、session、application，这些只能在web开发中使用到 Bean的自动装配 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文中自动寻找，并自动给bean装配属性 在Spring中有三种装配的方式 在xml中显示的配置 在java中显示配置 隐式的自动装配bean【重要】 测试环境搭建：一个人有两个宠物 ByName自动装配 ByType自动装配 使用注解实现自动装配jdk1.5支持的注解，Spring2.5就支持注解了 The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. 使用注解须知： 导入约束：context约束 配置注解的支持 context:annotation-config/ @Autowired 直接在属性上使用即可，也可以在set方法上使用 使用Autowired ，可以不编写set方法，前提是这个自动装配的属性在IOC（Spring）容器中存在，且符合名字byName 科普： 测试代码 使用@Autowired自动装配的环境比较复杂时，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifier(value = “xxx”)去配置@Autowired的使用，指定一个唯一的的bean对象注入 @Resource 小结： @Resource和@Autowired的区别： 都是用来自动装配的，都可以放在属性字段上 @Autowired通过byType的方式实现，而且必须要求这个对象存在 @Resource默认通过byname的方式实现，如果找不到名字，则通过byType实现，在两个都找不到的情况下，就报错 执行顺序不同：@Autowired通过byType的方式实现，@Resource默认通过byname的方式实现 使用注解开发在Spring4之后，要使用注解开发，必须要保证aop的包导入 使用注解需要导入context约束，增加注解的支持 bean @Component ：组件，放在类上，说明这个类被Spring管理了，就是bean 属性如何注入 衍生的注解 @Component有几个衍生注解，在web开发中，会按照mvc三层架构分层 dao 【@Repository】 service 【@Service】 controller 【@Controller】 这四个注解的功能都是一样的，都是代表将某个类注册到Spring中，装配Bean 自动装配值 作用域 @Scope(“prototype”) 小结 xml与注解： xml 更加万能，适用于任何场合，维护简单方便 注解 不是自己的类使用不了，维护相对复杂 xml与注解 最佳实践 xml用来管理bean 注解只负责完成属性的注入 在使用的过程中，需要注意一个问题：想要让注解生效，就需要开启注解的支持 使用java的方式配置Spring可以完全不适用Spring的xml配置，全权交给java来做 javaConfig 是Spring的一个子项目，在Spring 4 之后，他成为了一个核心功能 实体类 配置文件 测试类 这种纯java的配置方式，在SpringBoot中随处可见 代理模式为什么要学习代理模式？因为这就是SpringAOP的底层！【SpringAOP和SpringMVC】 代理模式的分类： 静态代理 动态代理 静态代理角色分析： 抽象角色：一般会使用接口或者抽象类来解决 真实角色：被代理的角色 代理角色：代理真实角色，代理真实角色后，我们一般会做一个附属操作 客户：访问代理对象的人 代码步骤： 接口 真实角色 代理角色 客户端访问代理角色 代理模式的好处： 可以使真实角色的操作更加纯粹，不用去关注一些公共的业务 公共业务就交给代理角色，实现了业务的分工 公共业务发生扩展的时候，方便集中管理 缺点：一个真实角色就会产生一个代理角色，代码量会翻倍~开发效率会变低 加深理解聊聊AOP： 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是我们直接写好的 动态代理分为两大类：基于接口的动态代理，基于类的动态代理 基于接口 — JDK动态代理【我们在这里使用】 基于类：cglib java字节码实现：javasist 需要了解两个类：Proxy ：代理，InvocationHandler：调用处理程序 动态代理的好处： 可以使真实角色的操作更加纯粹，不用去关注一些公共的业务 公共业务就交给代理角色，实现了业务的分工 公共业务发生扩展的时候，方便集中管理 一个动态代理类代理的是一个接口，一般就是对应的一些业务 一个动态代理类可以代理多个类，只要实现同一个接口即可 AOP什么是AOPAOP（Aspect Oriented Programming） 意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生泛型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率 Aop在Spring中的作用==提供声明式事务；允许用户自定也切面== 横切关注点：跨越应用程序多个模块的方法或功能，即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志、安全、缓存、事务等等… 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法 目标（Target）：被通知的对象 代理（Proxy）：向目标对应应用通知之后创建的对象 切入点（PointCut）：切面通知 执行的“地点”的定义 连接点（JointPoint）：与切入点匹配的执行点 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5中类型的Advice 即Aop在不改变原有代码的情况下，去增加新的功能 使用Spring实现AOP【重点】使用AOP织入，需要导入一个依赖包 方式一：使用Spring的API接口【主要SpringAPI接口实现】 方式二：自定义来实现AOP【主要是切面定义】 方式三：使用注解实现 整合Mybatis步骤： 导入相关jar包 junit mybatis mysql数据库 spring相关的 aop织入 mybatis-spring【new】 编写配置文件 测试 回忆Mybatis 编写pojo实体类 实现mybatis的配置文件 UserDao接口编写 接口对应的Mapper映射文件 测试类 Mybatis-spring整合实现一： 编写数据源配置 sqlSessionFactory sqlSessionTemplate 需要给接口加实现类 将自己写的实现类，注入到Spring中 测试使用即可 整合实现二： mybatis-spring1.2.3版以上的才有这个 . 编写数据源配置 sqlSessionFactory 实现类 将自己写的实现类，注入到Spring中 测试使用即可 声明式事务回顾事务 把一组业务当成一个业务来做，要么都成功，要么都失败 事务在项目开发中，十分的重要，涉及到数据的一致性问题，不能马虎！ 确保完整性和一致性 事务ACID原则： 原子性 一致性 隔离性 多个业务可能操作同一个资源，防止数据损坏 持久性 事务一旦提交，无论系统发生什么问题，结果都不会再被影响，被持久化的写到存储器中 spring中的事务管理Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。 声明式事务：AOP 一般情况下比编程式事务好用。 将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。 编程式事务：需要在代码中，进行事务的管理 将事务管理代码嵌到业务方法中来控制事务的提交和回滚 缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码 使用Spring管理事务，注意头文件的约束导入 : tx 思考： 为什么需要事务？ 如果不配置事务，可能存在数据提交不一致的情况 如果我们不在Spring中去配置声明式事务，就需要在代码中手动配置事务 事务在项目的开发中十分重要，涉及到数据的一致性和完整性问题，不容马虎！ "},{"title":"Mybatis","date":"2022-03-04T06:30:21.000Z","url":"/2022/03/04/Mybatis/","categories":[["undefined",""]],"content":"Mybatis-9.28环境： JDK1.8 Mysql maven IDEA 回顾： JDBC Mysql Java基础 Maven Junit SSM框架：配置文件； 学习最好的方式：看官网文档 简介什么是Mybatis MyBatis 是一款优秀的持久层框架 它支持自定义 SQL、存储过程以及高级映射。 MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。 MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 MyBatis本是apache的一个开源项目iBatis，2010年这个项目由apache software foundation迁移到了[google code]( code/2346604)，并且改名为MyBatis。 2013年11月迁移到Github。 如何获得Mybatis maven仓库： Github：Releases · mybatis/mybatis-3 (github.com) 中文文档：mybatis – MyBatis 3 | 简介 持久化数据持久化 持久化就是将程序的数据在初九状态和瞬时状态转化的过程 内存：断电即失 数据库（Jdbc），io文件持久化 生活：冷藏，罐头 为什么需要持久化？ 有一些对象，不能让他丢掉 内存太贵了 持久层Dao层、Service层、Controller层 完成持久化工作的代码块 层界限十分明显 为什么需要Mybatis？ 帮助程序猿将数据存入到数据库中 方便 传统的JDBC代码太复杂，简化，框架，自动化 不用Mybatis也可以。更容易上手，技术没用高低之分 优点： 简单易学 灵活 sql和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射。 提供对象关系映射标签，支持对象关系组建维护。 提供xml标签，支持编写动态sql。 最重要的一点：使用的人多 第一个Mybatis程序思路：搭建环境–&gt;导入Mybatis–&gt;编写代码–&gt;测试！ 搭建环境搭建数据库 新建项目 新建一个普通的maven项目 删除src目录 导入maven依赖 创建一个模块 编写mybatis的核心配置文件 编写mybatis工具类 编写代码 实体类 Dao接口 接口实现类由原来的Use人DaoImpl转变为一个Mapper配置文件 测试注意点： org.apache.ibatis.binding.BindingException: Type interface com.xcw.dao.UserDao is not known to the MapperRegistry. MapperRegistry是什么？ 核心配置文件中注册mappers junit测试 可能会遇到的问题： 配置文件没用注册 绑定接口错误 方法名不对 返回类型不对 Maven导出资源问题 CRUDnamespacenamespace中的包名要和 Dao/mapper 接口的包名一致 Select选择、查询语句 id：对应的namespace中的方法名 resultType：Sql语句执行的返回值 parameterType：参数类型 编写接口 编写对应的mapper中的sql语句 测试 Insert update delete 注意点： 增删改需要提交事务！ 分析错误 标签不要匹配错 resource绑定mapper，需要使用路径 程序配置文件必须符合规范 NullPointerException，没有注册到资源 输出的xml文件中存在中文乱码问题 maven资源没有导出问题 万能Map假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map Map传递参数，直接在sql中取出key即可 【parameterType=”map”】 对象传递参数，直接在sql中取对象的属性即可 【parameterType=”Object”】 只有一个基本类型参数的情况下，可以直接在sql中取到 多个参数用Map，或者注解 配置解析核心配置文件 mybatis-config.xml MyBatis的配置文件包含了会深深影响MyBatis行为的设置和属性信息 环境配置（environments）MyBatis 可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 学会使用配置多套运行环境 Mybatis默认的事务管理起就是JDBC，连接池：POOLED 属性（properties）我们可以通过properties属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置 【db.properties】 编写一个配置文件 db.properties 在核心配置文件中引入 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，优先使用外部配置文件 类型别名（typeAliases） 类型别名可为 Java 类型设置一个缩写名字 意在降低冗余的全限定类名书写 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名 在实体类比较少的时候，使用第一种方式 如果实体类十分多，建议使用第二种 第一种可以DIY别名，第二种则不行，如果非要改，需要在实体类上增加注解 设置（settings）这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 其他配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） MyBatis Generator Core MyBatis Plus 通用mapper 映射器（mappers）MapperRegistry：注册绑定我们的Mapper文件 方式一：【推荐使用】 方式二： 注意点： 接口和他的Mapper配置文件必须同名 接口和他的Mapper配置文件必须在同一个包下 方式三： 注意点： 接口和他的Mapper配置文件必须同名 接口和他的Mapper配置文件必须在同一个包下 生命周期和作用域 作用域和生命周期，是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuilder： 一旦创建了 SqlSessionFactory，就不再需要它了 局部变量 SqlSessionFactory： 可以想象为：数据库连接池 SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 因此 SqlSessionFactory 的最佳作用域是应用作用域。 最简单的就是使用单例模式或者静态单例模式。 SqlSession： 连接到连接池的一个请求 SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要感觉关闭，否则资源被占用 这里的每一个Mapper，都代表一个具体的业务 解决属性名和字段名不一致的问题问题数据库中的字段 新建一个项目，拷贝之前的，测试实体类字段不一致的情况 测试出现问题 解决办法: 起别名 resultMap resultMap结果集映射 resultMap 元素是 MyBatis 中最重要最强大的元素 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 ResultMap 的优秀之处——你完全可以不用显式地配置它们。 如果这个世界总是这么简单就好了。 日志日志工厂如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手 曾经：sout、debug 现在：日志工厂 SLF4J LOG4J(deprecated since 3.5.9) 【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING 【掌握】 NO_LOGGING 在Mybatis中具体使用那个日志实现，在设置中设定 STDOUT_LOGGING 标准日志输出 在mybatis核心配置文件中，配置我们的日志 Log4j什么是Log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 导入log4j的包 log4j.properties 配置log4j为日志的实现 Log4j的使用，直接测试运行 简单使用 在要使用Log4j的类中，导入包 import org.apache.log4j.Logger; 日志对象，参数为当前类的class 日志级别 分页思考：为什么要分页？ 减少数据的处理量 使用Limit分页 使用Mybatis实现分页，核心SQL 接口 Mapper.xml 测试 RowBounds分页不再使用SQL实现分页 接口 mapper.xml 测试 分页插件 MyBatis 分页插件 PageHelper 使用注解开发面向接口编程 在真正的开发中，很大时候我们会选择面向接口编程 根本原因：解耦，可扩展，提高服用，分层开发中，上层不用管具体的实现，大家都遵守共同的标准，使得开发变得容易，规范性更好 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的对系统设计人员来讲就不那么重要了； 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程我想就是指按照这种思想来编程 关于接口的理解。 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。 接口的本身反映了系统设计人员对系统的抽象理解。 接口应有两类： 第一类是对一个体的抽象，它可对应为一个抽象体(abstract class)； 第二类是对一个体某一方面的抽象，即形成一个抽象面（interface）； 一个体有可能有多个抽象面。 抽象体与抽象面是有区别的。 三个面想区别 使用注解开发 注解在接口上实现 需要在核心配置文件中绑定接口 测试 本质：反射机制实现 底层：动态代理 Mybatis详细执行流程 CRUD我在工具类创建时实现自动提交事务 编写接口，增加注解 测试类 【注意：我们必须要将接口注册绑定到我们的核心配置文件中】 关于@Param()注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型的话，可以忽略，但是建议加上 在SQL中引用的就是这里的@Param()中设定的属性名 Lombok java library plugs build tools with one annotation your class 使用步骤： 在IDEA中安装Lombok插件 在项目中导入lombok的jar包 在实体类上加注解 说明： 多对一处理多对一： 多个学生，对应一个老师 多于学生而言， 关联… 多个学生，关联一个老师【多对一】 对于老师而言，集合， 一个老师，有很多学生【一对多】 SQL： 测试环境搭建 导入lombok 新建实体类 Teacher，Student 建立Mapper接口 建立Mapper.xml文件 在核心配置文件中绑定注册Mapper 测试查询是否能够成功 按照查询嵌套处理 按照结构嵌套处理 回顾mysql多对一查询方式： 子查询 联表查询 一对多处理如：一个老师拥有多个学生 对应老师而言，就是一对多的关系 环境搭建实体类 按照结果嵌套处理 按照查询嵌套处理 小结 关联 - association【多对一】 集合 - collection【一对多】 javaType &amp; ofType javaType 用来指定实体类中属性的类型 ofType 用来指定映射到List或者集合中的pojo类型，泛型中的约束类型 注意点： 保证SQL的可读性，尽量保证通俗易懂 注意一对多和多对一中，属性名和字段的问题 如果问题不好排查错误，可以使用日志，建议使用Log4j 面试高频 Mysql引擎 InnoDB底层原理 索引 索引优化 动态SQL**什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句 利用动态 SQL，可以彻底摆脱这种痛苦。 环境搭建 创建一个基础工程 导包 编写配置文件 编写实体类 编写实体类对应Mapper接口和Mapper.XML文件 IF choose、when、otherwise trim、where、set 所谓的动态SQL，本质还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码 SQL片段有的时候，我们可能会将一些功能的部分抽取出来，方便复用 使用SQL便签抽取公共部分 在需要使用的地方使用include标签引用即可 注意事项： 最好基于单表来定义SQL片段 不要存在where标签 Foreach 动态SQL就是在拼接SQL语句，我们只有保证SQL的正确性，按照SQL的格式，去排列组合就可以了 建议： 先在Mysql中写出完整的SQL再对应去修改成为我们的动态SQL实现通用 缓存简介 什么是缓存【Cache】？ 存在内存中的临时数据 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库数据文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率 什么样的数据能使用缓存 经常查询并且不经常改变的数据。【可以使用缓存】 Mybatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便的定制和配置缓存，缓存可以极大的提升查询效率 MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，它是基于namespace级别的缓存 为了提高扩展性，MyBatis定义了缓存接口Cache，我们可以通过实现Cache接口来自定义二级缓存 一级缓存 一级缓存也叫本地缓存 与数据库同一次会话期间查询到的数据会放在本地缓存中 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库 测试步骤： 开启日志 测试在一个Session中查询两次相同的记录 查看日志输出 缓存失效的情况： 查询不同的东西 增删改操作，可能会改变原理的数据，所以必定会刷新缓存 查询不同的Mapper.xml 手动清理缓存 小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段 一级缓存就是一个Map 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中 如果当前会话关闭了，这个会话对应的一级缓存就没了。但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中 新的会话查询信息，就可以从二级缓存中获取内容 不同的mapper查处的数据会放在自己对应的的缓存（马匹）中 步骤： 开启全局缓存 在要使用二级缓存的Mapper中开启 也可以自定义参数 测试 问题：需要将实体类序列化，否则会报错 小结： 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会先放在一级缓存中 只用当会话提交或者关闭的时候，才会提交到二级缓存 缓存原理 自定义缓存-ehcacheEhcache是一种广泛使用的开源Java分布式缓存，主要面向通用缓存 要在程序中使用ehcache，先要导包 在mapper中指定使用我们的ehcache缓存实现"},{"title":"Javaweb","date":"2022-03-04T06:30:04.000Z","url":"/2022/03/04/Javaweb/","categories":[["undefined",""]],"content":"基本概念前言web开发： web，网页的意思，www.baidu.com 静态web html，css 提供给所有人看的数据始终不会发生变化！ 动态web 淘宝，几乎所有的网站 提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同 技术栈：Servlet/JSP，ASP，PHP 在java中，动态web资源开发的技术统称为javaWeb web应用程序web应用程序，可以提供浏览器访问的程序： a.html、b.html……多个web资源，这些web资源可以被外界访问，对外界提供服务 我们能访问到的任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上 URL 这个统一的web资源会被放在同一个文件夹下，web应用程序–&gt;Tomcat：服务器 一个web应用由多部分组成（静态web，动态web） html，css，js jsp，servlet java程序 jar包 配置文件（Properties） web应用程序编写完毕后，若想提供给外界访问，需要一个服务器来统一管理 静态web *.htm, *.html这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取，同学 静态web存在的缺点 web页面无法动态更新，所有用户看到的都是同一个页面 轮播图，点击特性：伪动态 javaScript [实际开发中，用的最多] VBScript 它无法和数据库交互（数据无法持久化，用户无法交互） 动态web 页面会动态展示：”web的页面展示的效果因人而异“ 缺点 加入服务器的动态web资源出现错误，我们需要重新编写我们的后台程序 停机维护 优点： web页面可以动态更新，所有用户看到的都不是同一个页面 它可以和数据库交互（数据持久化：注册，商品信息，用户信息） web服务器技术讲解ASP： 微软：国内最早流行的就是ASP 在HTML中嵌入了VB的脚本，ASP+COM 在ASP开发中，基本一个页面都有几千行的业务代码，页面极其混乱 维护成本高 C# IIS PHP PHP开发速度很快，功能很强大，跨平台，代码很简单（70%，WP） 无法承载大访问量的情况（局限性） JSP/ServletB/S：浏览器和服务器 C/S：客户端和服务器 sun公司主推的B/S架构 基于java语言的（所有的大公司，或者一些开源的组件，都是用java写的） 可以承载三高问题带来的影响 语法像ASP web服务器服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息 IIS微软的，ASP…，Windowss中自带的 Tomcat面向百度编程 Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为比较流行的Web 应用服务器。 Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个java初学web的人来说，它是最佳的选择 Tomcat 实际上运行JSP 页面和Servlet。另外，Tomcat和IIS等Web服务器一样，具有处理HTML页面的功能，另外它还是一个Servlet和JSP容器，独立的Servlet容器是Tomcat的默认模式。不过，Tomcat处理静态HTML的能力不如Apache服务器。Tomcat最新版本为10.0.14。 下载tomcat： 安装 or 解压 了解配置文件及目录结构 这个东西的作用 Tomcat安装Tomcattomcat官网： Tomcat启动文件夹作用 启动，关闭Tomacat 访问测试： 可能遇到的问题： java环境变量没有配置 闪退问题：需要配置兼容性 可在startup.bat最后加上pause，再启动即可显示原因 乱码问题：配置文件中设置 配置 可以配置启动的端口号 tomcat的默认端口号为：8080 mysql：3306 http：80 https：443 可以配置主机的名称 默认的主机名为：localhost-&gt;127.0.0.1 默认网站应用存放的位置为：webapps 高难度面试题 请你谈谈网站时如何进行访问的 输入一个域名，回车 检查本机的C:\\Windows\\System32\\drivers\\etc\\hosts配置文件下有没有这个域名映射； 有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问 没有：去DNS服务器找，找到的化就返回，找不到就返回找不到 发布一个web网站将自己写的网站，放大服务器（Tomcat）中指定的web应用的文件夹（webapps）下，就可以访问了 网站应该有的结构 HTTP什么是HTTPHTTP (超文本传输协议) 是一个简单的请求-响应协议，它通常运行在TCP之上。 文本：html、字符串、… 超文本：图片、音乐、视频、定位、地图…. 80 https：安全的 443 两个时代 http1.0 HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接 http2.0 HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源 HTTP请求 客户端—发请求（Request）—服务器 百度： 请求行 请求行中的请求方式：GET 请求方式：Get，Post，HEAD，DELETE，PUT，TRACT… get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效 post：请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效 消息头 HTTP响应 服务器—响应—客户端 百度： 响应体 响应状态码（重点）200：请求响应成功 3xx：请求重定向 重定向：你重新到我给你新位置去 4xx：找不到资源 404 资源不存在 5xx：服务器代码错误 500 502：网关错误 常见面试题：当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？ Maven 为什么要学习这个技术？ 在javaweb开发中，需要使用大量的jar包，我们手动去导入 如何能够让一个东西自动帮我导入和配置这个jar包 ​ 由此，Maven诞生了 Maven项目架构管理工具我们目前用来就是方便导入jar包的 Maven的核心思想：约定大于配置 有约束，不要去违反 Maven会规定号你该如何去编写我们的java代码，必须要按照这个规范来 下载安装Maven官网： 配置参考博客：maven的安装和配置（包括配置环境变量,镜像,本地仓库,jdk）_机智大头-CSDN博客_阿里云仓库配置 配置环境变量在我们的系统环境变量中 配置如下配置： M2_HOME maven目录下的bin目录 MAVEN_HOME maven的目录 在系统的path中配置 %MAVEN_HOME%\\bin 测试Maven是否安装成功，保证必须配置完毕 报错：The JAVA_HOME environment variable is not defined correctly maven配置报错以及The JAVA_HOME environment variable is not defined correctly的解决方法_cms18374672699的博客-CSDN博客 阿里云镜像 镜像：mirrors 作用：加速我们的下载 国内建议使用阿里云的镜像 本地仓库在本地的仓库，远程仓库 建立一个本地仓库：localRepository 在IDEA中使用Maven 打开idea 创建一个Maven项目 等待系统初始化完毕 观察maven仓库中多了什么东西？ IDEA中的Maven设置 ​ 注意：IDEA项目创建成功后，看一眼Maven的配置 到这里，Maven在IDEA中的配置和使用就ok了 创建一个普通的Maven项目 这个只有在Web应用下才会有！ 标记文件夹功能 在IDEA中配置Tomcat社区版IDEA配置Tomcat：Java 在IDEA社区版中配置Tomcat并使用_weixin_44953227的博客-CSDN博客_社区版idea配置tomcat 启动Tomact pom文件pom.xml是Maven的核心配置文件 Maven由于它的约定大于配置，之后可能遇到我们写的配置文件，无法被导出或者生效的问题，解决方案： 解决遇到的问题maven默认web项目中的web.xml版本问题 替换为webapp5.0版本和tomact一致 重复配置maven问题 maven仓库的使用地址： Servlet简介 Servlet就是sun公司开发动态web的一门技术 sun在这些API中提供了一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤： 编写一个类，实现Servlet接口 把开发好的java类部署到web服务器中 把实现了Servlet接口的java程序叫做：Servlet HelloServletSerlvet接口Sun公司有两个默认的实现类：HttpServlet，GenericServlet 构建一个普通的Maven项目，删掉里面的src目录，以后的学习可以在这个项目里建立Moudel；这个空的工程就是Maven主工程 关于Maven父子工程的理解： 父项目中会有 子项目中会有 父项目中的jar子项目可以直接使用 Maven环境优化 修改web.xml为最新的 将maven的结构搭建完整 编写一个Servlet程序 编写一个普通类 实现Servlet接口，这里我们直接继承HttpServlet 编写Servlet的映射 为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要在web服务中注册我们写的Servlet，还需要给它一个浏览器能够访问的路径； 配置Tomcat ​ 注意：配置项目发布的路径就可以了 启动测试 Servlet原理Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会： Mapping问题 一个Servlet可以指定一个映射路径 一个Servlet可以指定多个映射路径 一个Servlet可以指定通用映射路径 默认请求路径 指定一些后缀或者前缀等等…. 优先级问题 指定了固有的映射路径优先级最高，如果找不到就会由默认的处理请求 ServletContextweb容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用 共享数据我在这个Servlet中保存的数据，可以在另外一个servlet中拿到 测试访问结果 获取初始化参数 请求转发 读取资源文件Properties 在java目录下新建properties 在resources目录下新建properties 发现：都被打包到了同一个路径下：classes，我们俗称这个路径为classpath 思路：需要一个文件流 测试访问结果 HttpServletResponseweb服务器接受到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，和一个代表响应的HttpServletResponse 如果要获取客户端请求过来的参数：找HttpServletRequest 如果要给客户端响应一些信息：找HttpServletResponse 简单分类负责向浏览器发送数据的方法 负责向浏览器发送响应头的方法 响应的状态码 下载文件 要获取下载文件的路径 下载的文件名是啥？ 设置想办法让浏览器能够支持下载我们需要的东西 获取下载文件的输入流 创建缓冲区 获取OutputStream 讲FileOutputStream流写入到buffer缓冲区 使用OutputStream将缓冲区中的数据输出到客户端 验证功能 实现重定向 一个web资源（B）收到客户端A请求后，B会通知客户端（A）去访问另外一个web资源（C），这个过程叫重定向 常见场景： 用户登录 测试 面试题：请你聊聊重定向和转发的区别？ 相同的 页面都会实现跳转 不同点 请求转发的时候，url不会产生变化 重定向的时候，url地址栏会发生变化 HttpServletRequest 获取前端传递的参数,请求转发 Cookie、Session会话会话：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话 有状态会话：一个同学来过教室，下次再来教师，我们会知道这个同学，曾经来过，称之为有状态会话 一个网站，怎么证明你来过？ 客户端 服务端 服务端给客户端一个信件，客户端下次访问服务器带上信件就可以了；cookie 服务器登记你来过了，下次你来的时候我来匹配你；sesion 保存会话的两种技术cookie 客户端技术（响应，请求） session 服务器技术，利用这个技术，可以保存用户的会话信息，我们可以把信息或数据放在Session中 常见案例：网站登录之后，下次不用再登陆了，第二次访问直接就上去了 Cookie 从请求中拿到cookie信息 服务器响应给客户端cookie cookie：一般会保存至本地的 用户目录下 appdata 一个网站cookie存在上限 一个Cookie只能保存一个信息 一个web站点可以给浏览器发送多个cookie，最多存放20个cookie Cookie大小有限制4kb 300个cookie浏览器上限 删除cookie 不设置有效期，关闭浏览器，自动失效 设置有效期时间为0 编码解码： Session(重点) 什么是Session： 服务器会给每一个用户（浏览器）创建一个Session对象 一个Session独占一个浏览器，只要浏览器没有关闭，这个Session就存在 用户登录之后，整个网站它都可以访问！..&gt;保存用户的信息；保存购物车信息… Session和Cookie的区别： Cookie是把用户的数据写给用户的浏览器，浏览器保存（可以保存多个） Session把用户的数据写到用户独占Session中服务器端保存（保存重要的信息，减少服务器资源的浪费） Session对象由服务器创建 使用场景： 保存一个登录用户的信息 购物车信息 在整个网站中经常会使用的数据，我们将保存在Session中 使用Session： 会话自动注销：web.xml配置 JSP什么是JSPJava Server Pages：java服务器端页面，也和Servlet一样，用于动态web技术！ 最大的特点： 写JSP就像在写HTML 区别 HTML只给用户提供静态的数据 JSP页面中可以嵌入JAVA代码，为用户提供动态数据 JSP原理思路：JSP到底怎么执行的 底层代码没有任何问题 服务器内部工作 ​ tomcat中有一个work目录 ​ IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录 我电脑的地址为： 发现页面转变成了Java程序 浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet JSP最终也会被转换成一个Java类 JSP本质上就是一个Servlet 判断请求 内置一些对象 输出页面前增加的代码 以上的这些对象我们可以在JSP页面中直接使用 在JSP页面中 只要是JAVA代码就会被原封不动的输出 如果是HTML代码，就会被转换为： 这样的格式，输出到前端 JSP基本语法任何语言都有自己的语法，JAVA中有。。JSP作为java技术的一种应用，它拥有一些自己扩充的语法（了解，知道即可！），java所以语法都支持！ JSP表达式 JSP脚本片段 脚本片段的再实现 JSP声明 JSP声明：会被编译到JSP生成的java的类中，其他的就会被生成到_jspService方法中！ 再JSP，嵌入java代码即可 JSP指令 9大内置对象 PageContext 存东西 Request 存东西 Response Session 存东西 Application 【SerlvetContext】 存东西 config 【SerlvetConfig】 out page ，不用了解 exception request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！ session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车 application：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据 JSP标签，JSTL标签，EL表达式 EL表达式：${ } 获取数据 执行运算 获取web开发的常用对象 JSP标签: JSTL标签： JSTL标签库的使用就是为了弥补HTML标签的不足；他自定义许多标签，可以供我们使用，标签的功能和java代码一样！ 格式化标签 SQL标签 XML标签 核心标签（掌握部分） JSTL标签库使用步骤： 引入对应的taglib 使用其中的方法 在Tomcat也需要引入jstl的包，否则会报错：JSTL解析错误 c:if c:when c:forEach JavaBean实体类 JavaBean有特定的写法： 必须要有一个无参构造 属性必须私有化 必须有对应的get/set方法 一般用来和数据库的字段做映射 ORM ORM：对象关系映射 表–&gt;类 字段–&gt;属性 行记录–&gt;对象 People表 id name age address 1 行初雾1号 18 邯郸 2 行初雾2号 20 西安 3 行初雾3号 23 西安 MVC三层架构什么是MVC：Model View Controller 模型、视图、控制器 早期 用户直接访问控制器，控制器就可以直接操作数据库 MVC三层架构 Model 业务处理：业务逻辑（Service） 数据持久层：CRUD（Dao） View 展示数据 提供链接发起Servlet请求（a，form，img….） Controller（Servlet） 接收用户的请求：（req：请求参数，Session信息..） 交给业务层处理对应的代码 控制视图的跳转 Filter（重点）Filter：过滤器，用来过滤网站的数据 处理中文乱码 登录验证… Filter开发步骤： 导包 编写过滤器 导包不要错 ​ 实现Filter接口，重写对应的方法即可 在web.xml中配置Filter 监听器实现一个监听器的接口（有N钟） 编写一个监听器 实现监听器的接口 web.xml中注册监听器 看情况是否使用 过滤器、监听器常见应用用户登录之后才能进入主页！用户注销后就不能进入主页了 用户登录后，向Session中放入用户的数据 进入主页的时候判断用户是否已经登录，要求：在过滤器中实现 JDBC什么是JDBC：java连接数据库 需要的jar包的支持： java.sql javax.sql mysql-conneter-java… 连接驱动（必须要导入） 实验环境搭建 导入数据库依赖 IDEA中连接数据库 JDBC固定步骤 加载驱动 连接数据库，代表数据库 向数据库发送SQL的对象Statement ：CRUD 编写SQL（根据业务，不同的SQL） 执行查询SQL，返回一个ResultSet ：结果集 关闭连接 预编译SQL 事务要么都成功，要么都失败 ACID原则：保证数据的安全 Junit单元测试 依赖 简单实用 @Test注解只有在方法上有效，只要加了这个注解的方法，就可以直接运行 "},{"title":"SMBMS","date":"2022-03-01T06:44:51.000Z","url":"/2022/03/01/SMBMS/","categories":[["undefined",""]],"content":"SMBMS参考博客：Javaweb-超市订单管理系统SMBMS_Mario的博客-CSDN博客_超市订单系统 数据库 项目如何搭建？ 考虑使用不使用Maven？依赖，jar 项目搭建准备工作 搭建一个Maven web项目 配置Tomcat 测试项目是否能够跑起来 导入项目中会遇到的jar包 jsp，Servlet，mysql驱动，jstl，stand… 创建项目包结构 编写实体类 ORM映射：表-类映射 编写基础公共类 数据库配置文件 编写数据库的公共类 编写字符编码过滤器 导入静态资源 登陆功能实现 编写前端页面 设置首页 编写dao层用户登录的接口 编写dao接口的实现类 业务层接口 业务层实现类 编写servlet 注册servlet 测试访问，确保以上功能成功！ 登录功能优化注销功能：思路：移除Session，返回登录页面 注册xml 登录拦截优化编写一个过滤器，并注册 密码修改 导入前端素材 写项目，建议用底层向上写 UserDao接口 UserDao接口实现类 UserService层 UserService实现类 Servlet实现复用，需要提取出方法 Servlet注册 测试 验证旧密码： 用户管理实现思路： 导入分页的工具类 用户列表页面导入 userlist.jsp 获取用户数量 UserDao UserDaoImpl UserService UserServiceImpl 获取用户列表 UserDao UserDaoImpl UserService UserServiceImpl 获取角色操作为了我们职责统一，可以把角色的操作单独放在一个包中，和POJO类对应 RoleDao RoleDaoImpl RoleService RoleServiceImpl 用户显示的Servlet 获取用户前端的数据（查询） 判断请求释放需要执行，看参数的值判断 为了实现分页，需要计算出当前页面和总页面，页面大小… 用户列表展示 返回前端 "},{"title":"JVM 入门","date":"2022-01-23T05:36:30.000Z","url":"/2022/01/23/JVM-%E5%85%A5%E9%97%A8/","categories":[["undefined",""]],"content":"面试常见： 请你谈谈你对JVM的理解? java8虚拟机和之前的变化更新? 什么是OOM，什么是栈溢出StackOverFlowError? 怎么分析? JVM的常用调优参数有哪些? 内存快照如何抓取？怎么分析Dump文件？ 谈谈JVM中，类加载器你的认识？ JVM的位置 三种JVM: Sun公司：HotSpot 用的最多 BEA：JRockit IBM：J9VM 我们学习都是：HotSpot JVM的体系结构 jvm调优：99%都是在方法区和堆，大部分时间调堆。 JNI（java native interface）本地方法接口。 类加载器 作用：加载Class文件——如果new Student();（具体实例在堆里，引用变量名放栈里） 。 先来看看一个类加载到 JVM 的一个基本结构： 类是模板，对象是具体的，通过new来实例化对象。car1，car2，car3，名字在栈里面，真正的实例，具体的数据在堆里面，栈只是引用地址。 虚拟机自带的加载器 启动类（根）加载器 扩展类加载器 应用程序加载器 类加载器的分类 Bootstrap ClassLoader 启动类加载器 Extention ClassLoader 标准扩展类加载器 Application ClassLoader 应用类加载器 User ClassLoader 用户自定义类加载器 双亲委派机制 idea报了一个错误： 这是因为，在运行一个类之前，首先会在应用程序加载器(APP)中找，如果APP中有这个类，继续向上在扩展类加载器EXC中找，然后再向上，在启动类( 根 )加载器BOOT中找。如果在BOOT中有这个类的话，最终执行的就是根加载器中的。如果BOOT中没有的话，就会倒找往回找。 过程总结 1.类加载器收到类加载的请求 2.将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器 3.启动类加载器检查是否能够加载当前这个类，能加载就结束，使用当前的加载器，否则，抛出异常，一层一层向下，通知子加载器进行加载 4.重复步骤3 关于双亲委派机制的博客： 你确定你真的理解“双亲委派“了吗？！ 面试官：java双亲委派机制及作用 ==概念==：当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。 ==例子==：当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。 ==作用==： 防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。 保证核心.class不能被篡改。通过委托方式，不会去篡改核心.class，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。 比如：如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。 沙箱安全机制 Java安全模型的核心就是Java沙箱(sandbox)，什么是沙箱?沙箱是一个限制程序运行的环境。沙箱机制就是将Java代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱主要限制系统资源访问，那系统资源包括什么?CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。 所有的Java程序运行都可以指定沙箱，可以定制安全策略。 在]ava中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的ava实现中，安全依赖于沙箱(Sandbox)机制。如下图所示JDK1.0安全模型。 但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的Java1.1 版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型。 在Java1.2版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型。 当前最新的安全机制实现，则引入了域(Domain)的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain)，对应不一样的权限(Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示最新的安全模型(jdk 1.6)。 组成沙箱的基本组件: 字节码校验器(bytecode verifier)︰确保Java类文件遵循lava语言规范。这样可以帮助lava程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。 类装载器(class loader) :其中类装载器在3个方面对Java沙箱起作用： 。它防止恶意代码去干涉善意的代码;。它守护了被信任的类库边界;。它将代码归入保护域，确定了代码可以进行哪些操作。 虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。 类装载器采用的机制是双亲委派模式。 1.从最内层VM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用; 2.由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。 存取控制器(access controller)︰存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。 安全管理器(security manager)︰是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。 安全软件包(security package) : java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括: 安全提供者 消息摘要 数字签名 加密 鉴别 Native 编写一个多线程类启动。 点进去看start方法的源码： 凡是带了native关键字的，说明 java的作用范围达不到，去调用底层C语言的库！ JNI：Java Native Interface（Java本地方法接口） 凡是带了native关键字的方法就会进入本地方法栈； Native Method Stack 本地方法栈 本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java在诞生的时候是C/C++横行的时候，想要立足，必须有调用C、C++的程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 在 Native Method Stack 中登记native方法，在 ( ExecutionEngine ) 执行引擎执行的时候加载Native Libraies。 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍！ PC寄存器程序计数器：Program Counter Register 每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码(用来存储指向像一条指令的地址，也即将要执行的指令代码)，在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。 方法区Method Area 方法区 方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间; ==静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关==。 static ，final ，Class ，常量池~ 栈 在计算机流传有一句废话： 程序 = 算法 + 数据结构 但是对于大部分同学都是： 程序 = 框架 + 业务逻辑 栈：后进先出 / 先进后出 队列：先进先出（FIFO : First Input First Output） 栈管理程序运行 存储一些基本类型的值、对象的引用、方法等。 栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。 思考：为什么main方法最后执行！为什么一个test() 方法执行完了，才会继续走main方法！ 喝多了吐就是栈，吃多了拉就是队列。 说明： 1、栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放。 2、对于栈来说不存在垃圾回收问题，只要线程一旦结束，该栈就Over，生命周期和线程一致，是线程私有的。 3、方法自己调自己就会导致栈溢出（递归死循环测试）。 栈里面会放什么东西那？ 8大基本类型 + 对象的引用 + 实例的方法 栈运行原理 Java栈的组成元素——栈帧。 栈帧是一种用于帮助虚拟机执行方法调用与方法执行的数据结构。他是独立于线程的，一个线程有自己的一个栈帧。封装了方法的局部变量表、动态链接信息、方法的返回地址以及操作数栈等信息。 第一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生了栈帧F2也被压入栈中，B方法又调用了C方法，于是产生栈帧F3也被压入栈中 执行完毕后，先弹出F3， 然后弹出F2，在弹出F1…….. 遵循 “先进后出” / “后进先出” 的原则。 栈满了，抛出异常：stackOverflowError 对象实例化的过程。 三种JVM Sun公司HotSpot java Hotspot™64-Bit server vw (build 25.181-b13，mixed mode) BEA JRockit IBM 39 VM 我们学习都是：Hotspot 堆Java7之前 Heap 堆，一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。 类加载器读取了类文件后，需要把类，方法，常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行。 堆内存分为三部分： 新生区 Young Generation Space Young/New 养老区 Tenure generation space Old/Tenure 永久区 Permanent Space Perm 堆内存逻辑上分为三部分：新生，养老，永久（元空间 : JDK8 以后名称）。 谁空谁是to GC垃圾回收主要是在新生区和养老区，又分为轻GC 和 重GC，如果内存不够，或者存在死循环，就会导致 在JDK8以后，永久存储区改了个名字(元空间)。 新生区、养老区 新生区是类诞生，成长，消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。 新生区又分为两部分：伊甸区（Eden Space）和幸存者区（Survivor Space），所有的类都是在伊甸区被new出来的，幸存区有两个：0区 和 1区，当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC）。将伊甸园中的剩余对象移动到幸存0区，若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区，那如果1区也满了呢？（这里幸存0区和1区是一个互相交替的过程）再移动到养老区，若养老区也满了，那么这个时候将产生MajorGC（Full GC），进行养老区的内存清理，若养老区执行了Full GC后发现依然无法进行对象的保存，就会产生OOM异常 “OutOfMemoryError ”。如果出现 java.lang.OutOfMemoryError：java heap space异常，说明Java虚拟机的堆内存不够，原因如下： 1、Java虚拟机的堆内存设置不够，可以通过参数 -Xms（初始值大小），-Xmx（最大大小）来调整。 2、代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）或者死循环。 永久区（Perm） 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class，Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。 如果出现 java.lang.OutOfMemoryError：PermGen space，说明是 Java虚拟机对永久代Perm内存设置不够。一般出现这种情况，都是程序启动需要加载大量的第三方jar包， 例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。 注意： JDK1.6之前： 有永久代，常量池1.6在方法区； JDK1.7： 有永久代，但是已经逐步 “去永久代”，常量池1.7在堆； JDK1.8及之后：无永久代，常量池1.8在元空间。 熟悉三区结构后方可学习JVM垃圾回收机制 实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名，叫做Non-Heap（非堆），目的就是要和堆分开。 对于HotSpot虚拟机，很多开发者习惯将方法区称之为 “永久代（Parmanent Gen）”，但严格本质上说两者不同，或者说使用永久代实现方法区而已，永久代是方法区（相当于是一个接口interface）的一个实现，Jdk1.7的版本中，已经将原本放在永久代的字符串常量池移走。 常量池（Constant Pool）是方法区的一部分，Class文件除了有类的版本，字段，方法，接口描述信息外，还有一项信息就是常量池，这部分内容将在类加载后进入方法区的运行时常量池中存放！ 堆内存调优 ==-Xms==：设置初始分配大小，默认为物理内存的 “1/64”。 ==-Xmx==：最大分配内存，默认为物理内存的 “1/4”。 ==-XX:+PrintGCDetails==：输出详细的GC处理日志。 测试1 代码测试 IDEA中进行VM调优参数设置，然后启动。 发现，默认的情况下分配的内存是总内存的 1/4，而初始化的内存为 1/64 ！ VM参数调优：把初始内存，和总内存都调为 1024M，运行，查看结果！ 来大概计算分析一下！ 再次证明：元空间并不在虚拟机中，而是使用本地内存。 测试2 代码： vm参数： 测试，查看结果！ 这是一个young 区域撑爆的JAVA 内存日志，其中 PSYoungGen 表示 youngGen分区的变化1536k 表示 GC 之前的大小。 488k 表示GC 之后的大小。 整个Young区域的大小从 1536K 到 672K , young代的总大小为 7680K。 user – 总计本次 GC 总线程所占用的总 CPU 时间。 sys – OS 调用 or 等待系统时间。 real – 应用暂停时间。 如果GC 线程是 Serial Garbage Collector 串行搜集器的方式的话（只有一条GC线程,）， real time 等于user 和 system 时间之和。 通过日志发现Young的区域到最后 GC 之前后都是0，old 区域 无法释放，最后报堆溢出错误。 其他文章链接 一文读懂 - 元空间和永久代 Java方法区、永久代、元空间、常量池详解 GCDump内存快照 在运行java程序的时候，有时候想测试运行时占用内存情况，这时候就需要使用测试工具查看了。在eclipse里面有 Eclipse Memory Analyzer tool(MAT)插件可以测试，而在idea中也有这么一个插件，就是JProfiler，一款性能瓶颈分析工具！ 作用： 分析Dump文件，快速定位内存泄漏； 获得堆中对象的统计数据 获得对象相互引用的关系 采用树形展现对象间相互引用的情况 安装JProﬁler IDEA插件安装 安装JProﬁler监控软件 下载地址：ﬁler/version_92 下载完双击运行，选择自定义目录安装，点击Next。 注意：安装路径，建议选择一个文件名中没有中文，没有空格的路径 ，否则识别不了。然后一直点Next。 注册 配置IDEA运行环境 Settings–Tools–JProﬂier–JProﬂier executable选择JProﬁle安装可执行文件。（如果系统只装了一个版本， 启动IDEA时会默认选择）保存。 代码测试： vm参数 ： -Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError 寻找文件： 使用 Jproﬁler 工具分析查看 双击这个文件默认使用 Jproﬁler 进行 Open大的对象！ 从软件开发的角度上，dump文件就是当程序产生异常时，用来记录当时的程序状态信息（例如堆栈的状态），用于程序开发定位问题。 四大算法引用计数法 每个对象有一个引用计数器，当对象被引用一次则计数器加1，当对象引用失效一次，则计数器减1，对于计数器为0的对象意味着是垃圾对象，可以被GC回收。 目前虚拟机基本都是采用可达性算法，从GC Roots 作为起点开始搜索，那么整个连通图中的对象边都是活对象，对于GC Roots 无法到达的对象变成了垃圾回收对象，随时可被GC回收。 复制算法 年轻代中使用的是Minor GC，采用的就是复制算法（Copying）。 什么是复制算法？ Minor GC 会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移动到Old generation中，也就是说，一旦收集后，Eden就是变成空的了 当对象在Eden（包括一个Survivor区域，这里假设是From区域）出生后，在经过一次Minor GC后，如果对象还存活，并且能够被另外一块Survivor区域所容纳 （上面已经假设为from区域，这里应为to区域，即to区域有足够的内存空间来存储Eden 和 From 区域中存活的对象），则使用复制算法将这些仍然还活着的对象复制到另外一块Survivor区域（即 to 区域）中，然后清理所使用过的Eden 以及Survivor 区域（即form区域），并且将这些对象的年龄设置为1，以后对象在Survivor区，每熬过一次MinorGC，就将这个对象的年龄 + 1，当这个对象的年龄达到某一个值的时候（默认是15岁，通过- XX:MaxTenuringThreshold 设定参数）这些对象就会成为老年代。 -XX:MaxTenuringThreshold 任期门槛=&gt;设置对象在新生代中存活的次数 面试题：如何判断哪个是to区呢？一句话：谁空谁是to 原理解释： 年轻代中的GC，主要是复制算法（Copying） HotSpot JVM 把年轻代分为了三部分：一个 Eden 区 和 2 个Survivor区（from区 和 to区）。默认比例为 8:1:1，一般情况下，新创建的对象都会被分配到Eden区（一些大对象特殊处理），这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区，对象在Survivor中每熬过一次Minor GC ， 年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中，因为年轻代中的对象基本上 都是朝生夕死，所以在年轻代的垃圾回收算法使用的是复制算法！复制算法的思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产 生内存碎片！ 在GC开始的时候，对象只会在Eden区和名为 “From” 的Survivor区，Survivor区“TO” 是空的，紧接着进行GC，Eden区中所有存活的对象都会被复制到 “To”，而在 “From” 区中，仍存活的对象会更具他们的年龄值来决定去向。 年龄达到一定值的对象会被移动到老年代中，没有达到阈值的对象会被复制到 “To 区域”，经过这次GC后，Eden区和From区已经被清空，这个时候， “From” 和 “To” 会交换他们的角色， 也就是新的 “To” 就是GC前的“From” ， 新的 “From” 就是上次GC前的 “To”。 不管怎样，都会保证名为To 的Survicor区域是空的。 Minor GC会一直重复这样的过程。直到 To 区 被填满 ，“To” 区被填满之后，会将所有的对象移动到老年代中。 因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区域，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的Eden 对象转移到10%的to空闲区域，接下来，将之前的90%的内存，全部释放，以此类推； 好处：没有内存碎片；坏处：浪费内存空间。 劣势： 复制算法它的缺点也是相当明显的。 1、他浪费了一半的内存，这太要命了。 2、如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视，所以从以上描述不难看出。复制算法要想使用，最起码对象的存活率要非常低才行，而且 最重要的是，我们必须要克服50%的内存浪费。 标记清除（Mark-Sweep） 回收时，对需要存活的对象进行标记； 回收不是绿色的对象。 当堆中的有效内存空间被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。 标记：从引用根节点开始标记所有被引用的对象，标记的过程其实就是遍历所有的GC Roots ，然后将所有GC Roots 可达的对象，标记为存活的对象。 清除： 遍历整个堆，把未标记的对象清除。 缺点：这个算法需要暂停整个应用，会产生内存碎片。两次扫描，严重浪费时间。 用通俗的话解释一下 标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清 除掉，接下来便让程序恢复运行。 劣势： 首先、它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用 程序，这会导致用户体验非常差劲 其次、主要的缺点则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象 都是随机的出现在内存的各个角落，现在把他们清除之后，内存的布局自然乱七八糟，而为了应付 这一点，JVM就不得不维持一个内存空间的空闲列表，这又是一种开销。而且在分配数组对象的时 候，寻找连续的内存空间会不太好找。 标记压缩 标记整理说明：老年代一般是由标记清除或者是标记清除与标记整理的混合实现。 什么是标记压缩？ 原理： 在整理压缩阶段，不再对标记的对象作回收，而是通过所有存活对象都像一端移动，然后直接清除边界以外的内存。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被 清理掉，如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 标记、整理算法 不仅可以弥补 标记、清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价； 标记清除压缩 先标记清除几次，再压缩。 总结 内存效率：复制算法 &gt; 标记清除算法 &gt; 标记压缩算法 （时间复杂度）； 内存整齐度：复制算法 = 标记压缩算法 &gt; 标记清除算法； 内存利用率：标记压缩算法 = 标记清除算法 &gt; 复制算法； 可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所 提到的三个指标，标记压缩算法相对来说更平滑一些 ， 但是效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记清除多了一个整理内存的过程。 难道就没有一种最优算法吗？ 答案： 无，没有最好的算法，只有最合适的算法 。 —————-&gt; 分代收集算法 年轻代：（Young Gen） 年轻代特点是区域相对老年代较小，对象存活低。 这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因而很适 用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。 老年代：（Tenure Gen） 老年代的特点是区域较大，对象存活率高！ 这种情况，存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。Mark阶段的开销与存活对象的数量成正比，这点来说，对于老年代，标记清除或 者标记整理有一些不符，但可以通过多核多线程利用，对并发，并行的形式提标记效率。Sweep阶段的 开销与所管理里区域的大小相关，但Sweep “就地处决” 的 特点，回收的过程没有对象的移动。使其相对其他有对象移动步骤的回收算法，仍然是是效率最好的，但是需要解决内存碎片的问题。 JMM 什么是JMM？ JMM：（java Memory Model的缩写） 他干嘛的？官方，其他人的博客，对应的视频！ 作用：缓存一致性协议，用于定义数据读写的规则(遵守，找到这个规则)。 JMM定义了线程工作内存和主内存之间的抽象关系∶线程之间的共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory)。 解决共享对象可见性这个问题：volilate 它该如何学习？ JMM：抽象的概念，理论。 JMM对这八种指令的使用 ，制定了如下规则： 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write。 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存。 不允许一个线程将没有assign的数据从工作内存同步回主内存。 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作。 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁。 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。 对一个变量进行unlock操作之前，必须把此变量同步回主内存。 JMM对这八种操作规则和对volatile的一些特殊规则就能确定哪里操作是线程安全，哪些操作是线程不安全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分析。更多的时候，使用java的happen-before规则来进行分析。"},{"title":"网络编程","date":"2022-01-14T11:45:52.000Z","url":"/2022/01/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","categories":[["undefined",""]],"content":"概述计算机网络计算机网络是指将==地理位置不同==的具有独立功能的==多台计算机及其外部设备，通过通信线路连接起来==，在网络操作系统，网络管理软件，及==网络通信协议==的管理和协调下，==实现资源共享==和信息传递的计算机系统 网络编程的目的无线电台…传播交流信息，==数据交换==，==通信== 网络通信的要素 网络编程中两个主要问题 如何准确定位到网络上的一台或者多台主机 找到主机之后如何进行通信 网络编程中的要素 IP 和 端口号 网络通信协议 Java，万物皆对象 OSI七层网络模型 TCP/IP四层概念模型 对应网络协议 应用层 应用层 HTTP、TFTP，FTP，NFS，WAIS、SMTP 表示层 应用层 Telnet，Rlogin，SNMP，Gopher 会话层 应用层 SMTP，DNS 传输层 传输层 TCP，UDP 网络层 网络层 IP，ICMP，ARP，RARP，AKP，UUCP 数据链路层 数据链路层 FDDI，Ethernet，Arpanet，PDN，SLIP，PPP 物理层 数据链路层 IEEE 802.1A，IEEE 802.2到IEEE 802.11 IPip地址：InetAddress 唯一定位一台网络上计算机 127.0.0.1：本机localhost ip地址的分类 ipv4 / ipv6· ==IPV4== 127.0.0.1 ,4个字节组成 。0~255，42亿 ；30亿在北美，亚洲4亿。2011年就用尽 ==IPV6== fe80::45b5:d8c3:c002:7b9f%21 ：128位，8个无符号整数 公网（互联网） - 私网（局域网） ABCD类地址 192.168.xx.xx，专门给组织内部使用的 端口端口表示计算机上的一个程序的进程 不同的进程有不同的端口号，用来区分软件 被规定 0 ~65535 TCP，UDP：65535*2，单个协议下，端口号不能冲突 端口分类 共有端口 0~1023 HTTP：80 HTTPS：443 FTP：21 Telent：23 程序注册端口： 1024~49151，分配用户或者程序 Tomcat：8080 MySQL： 3306 Oracle： 1521 动态、私有： 49152~65535 通信协议协议：约定，就好比我们现在说的时普通话 网络通信协议：速率、传输码率，代码结构，传输控制。。。 问题：非常的复杂？ 大事化小：分层！ TCP、IP协议簇 实际上是一组协议 重要： TCP：用户传输协议 UDP：用户数据报协议 出名的协议： TCP IP：网络互连协议 TCP UDP对比 TCP：打电话 连接，稳定 ==三次握手，四次挥手== ```最少需要三次，保证稳定连接！A：你瞅啥？B：瞅你咋地？A：干一场！ A：我要走了B：你真的要走了吗？B：你真的真的要走了吗？A：我真的要走了 public class TcpClientDemo1 {public static void main(String[] args) { }} public class TcpServerDemo1 {public static void main(String[] args) { }} public class TcpServerDemo2 {public static void main(String[] args) throws IOException { }} public class TcpClientDemo2 {public static void main(String[] args) throws Exception { }} public class UDPClientDemo1 {public static void main(String[] args) throws IOException { }} public class UDPServerDemo1 {public static void main(String[] args) throws IOException { }} public class UdpSenderDemo2 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(8888); } public class UdpReceiveDemo2 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(6666); } public class TalkSend implements Runnable{ DatagramSocket socket = null; BufferedReader reader = null; private int fromPort; private String toIP; private int toPort; } public class TalkReceive implements Runnable{ DatagramSocket socket; private int port; private String msgFrom; public TalkReceive(int port,String msgFrom) { this.port = port; this.msgFrom = msgFrom; try { socket = new DatagramSocket(port); } catch (SocketException e) { e.printStackTrace(); } } } public class TalkTeacher { public static void main(String[] args) { //开启两个线程 new Thread(new TalkSend(5555,”localhost”,8888)).start(); new Thread(new TalkReceive(9999,”学生”)).start(); }} public class TalkStudent { public static void main(String[] args) { //开启两个线程 new Thread(new TalkSend(7777,”localhost”,9999)).start(); new Thread(new TalkReceive(8888,”老师”)).start(); }} public class UrlDown { public static void main(String[] args) throws IOException { //1.下载地址 URL url = new URL(“;); } "},{"title":"数据结构与算法","date":"2022-01-14T11:44:44.000Z","url":"/2022/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/","categories":[["undefined",""]],"content":"数据结构数组字符串队列栈链表集合哈希表树二叉树多叉树字典树算法排序双指针查找分治动态规划动态规划常常适用于有重叠子问题和最优子结构性质的问题，并且记录所有子问题的结果，因此动态规划方法所耗时间往往远少于朴素解法。 动态规划有自底向上和自顶向下两种解决问题的方式。自顶向下即记忆化递归，自底向上就是递推。 使用动态规划解决的问题有个明显的特点，一旦一个子问题的求解得到结果，以后的计算过程就不会修改它，这样的特点叫做无后效性，求解问题的过程形成了一张有向无环图。动态规划只解决每个子问题一次，具有天然剪枝的功能，从而减少计算量。 递归回溯贪心位运算DFS与BFS 图"},{"title":"mysql","date":"2022-01-14T11:38:12.454Z","url":"/2022/01/14/mysql/","categories":[["undefined",""]],"content":"初始Mysql 什么是数据库概念：​ 数据仓库（软件），安装在操作系统（window，Linux，mac…）之上。可以存储大量数据。500万 作用：​ 数据库是存储数据，管理数据， 为什么学习数据库 趋势，岗位需求 大数据时代，得数据者得天下 被迫需求：存数据 数据库是所有软件体系中最核心得存在 数据库分类关系型数据库：（SQL） MySQL、Oracle、SQL server、DB2、SQLlite… 通过表与表之间、行与行之间的关系进行数据的存储。 非关系型数据库：(NoSQL)Not Only SQL redis、MongDB 对象存储，通过对象自身的属性来决定。 连接数据库命令行连接： 数据库XXX语言DDL 定义 DML 操作 DQL 查询 DCL 控制 MySQL属性和操作1.常用密令 mysql的关键字不区分字母的大小写 2.操作数据库。数据库名：demo 创建数据库 删除数据库 使用数据库 查看数据库 3.数据库列的类型 mysql数据类型长度问题总结： 数值 tinyint：十分小的数据，1个字节。 smallint：较小的数据，2个字节。 mediumint：中等大小的数据，3个字节。 int：标准的证书，4个字节。（常用的变量） bigint：较大的数据，8个字节。 float：浮点数，4个字节。 double：浮点数，8个字节。 decimal：字符串形式的浮点数。涉及到金钱计算时，一般使用decimal 字符串 char：字符串固定大小的，0~255字节。 varchar：可变字符串，0~65535字节。（常用的变量） tinytext：微型文本，2^8-1字节。 text：文本串，2^16-1字节。 时间 date：YYYY-MM-DD，日期格式。 time：HH：mm：ss，时间格式。 datatime：YYYY-MM-DD HH：mm：ss，最常用的时间格式。 timestamp：时间戳，1970.1.1道现在的毫秒数。 year：年份表示。 null 没有值，未知。 注意：不要使用NULL进行运算，没有意义，计算结果为NULL 4.数据库的字段属性 Unsigned 无符号的整数。 声明了该列不能为负数。 zerofill 0填充 不足的位数使用0填充。int(5)类型存储数字9会变成00009 自增 通常理解为自增，自动在上一条记录的基础上+1（默认）。 通常用来设计唯一的主键，必须是整数类型。 可以自定义设计主键自增的起始值和步长。 非空 勾选上not null，如果不给字段赋值，则会报错。 默认 设置默认的值。 sex，默认值为男，如果不指定该列的值，则会有默认的值。 拓展： 5.创建数据库 注意点，使用英文()，表的名称和字段尽量使用``括起来。 AUTO_INCREMENT 自增。 字符串使用单引号括起来。 所有的语句后面加，（英文的），最后一个不用加。 PRIMARY KEY主键，一般一个表只有一个唯一的主键。 格式： 6.数据表类型 关于数据库引擎 InnoDB：5.5版本以后默认使用。 MyISam：早些年使用的默认。 MyISam InnoDB 事务支持 不支持 支持 数据行锁定 不支持 支持 外键约束 不支持 支持 全文索引 支持 不支持 表空间大小 较小 较大，约为myisam两倍 在物理空间存在的位置所有的数据库文件都存在data目录下，一个文件夹就对应一个数据库，本质还是文件的存储。 MySQL引擎在物理文件上的区别。 InnoDB在数据库表中只有一个*.frm文件，以及上级目录下的ibdata1文件。 MYISAM对应文件： *.frm：表结构的定义文件 *.MYD：数据文件（data） *.MYI：索引文件（index） 7.设置数据库表的字符集编码 MySQL默认字符编码的设置： 不设置的话，会是mysql默认的字符集编码（不支持中文） MySQL的默认编码是Latin1，不支持中文。 在my.ini中配置默认的编码 8.修改数据表字段 *change一般用来字段重命名，modify不用来字段重命名，只能修改字段类型和约束* 9.删除数据表字段 MySQL数据管理外键（了解即可）方式一：在创建表的时候，增加约束（麻烦，比较复杂） 删除有外键关系的表的时候，必须要先删除引用别人的表（从表），再删除被引用的表（主表） 方式二：创建表成功后，添加外键约束 以上操作都是物理外键，数据库级别的外键，不建议使用！（避免数据库过多造成困扰） ==最佳实践== 数据库就是单纯的表，只用来存数据，只有行（数据）和列（字段） 我们想使用多张表的数据，想使用外键（程序去实现） DML语言（全部记住）数据库意义：数据存储，数据管理 DML语言：数据操作语言 insert update delete 添加 注意事项： 字段和字段之间使用 英文逗号 隔开 字段可以省略，但是后面的值必须要一一对应，不能少 可以同时插入多条数据，VALUES后面的值，需要使用,隔开即可 (),() 修改 条件：where子句 操作符： =、&lt;&gt;或!=、&lt;、&gt;、&lt;=、&gt;=、BETWEEN…and… 、AND、OR 语法：update 表名 set column_name=value,[column_name=value,…] where [条件] 注意： colnum_name 是数据库的列，尽量带上`` 条件，筛选的条件，如果没有指定，则会修改所有的列 value，是一个具体的值，也可以是一个变量 多个设置的属性之间，使用英文逗号隔开 删除delete命令： 语法：delete from 表名 [where 条件] ```– 不指定条件的情况下，会删除所有的记录：delete from 表名delete from student where id=1; 清空整张表truncate table student; 测试delete与TRUNCATE区别CREATE TABLE test( id INT(4) NOT NULL AUTO_INCREMENT, coll VARCHAR(20) NOT NULL, PRIMARY KEY(id))ENGINE=INNODB DEFAULT CHARSET=utf8mb4 INSERT INTO test(coll) VALUES(‘1’),(‘2’),(‘3’) DELETE FROM test – 不会影响自增 TRUNCATE TABLE test – 自增会归零 SELECT [ALL | DISTINCT]{* | table.* | [table.field1[as alias1][,table.field2[as alias2]][,…]]}FROM table_name [as table_alias] [left | right | inner join table_name2] – 联合查询 [WHERE …] – 指定结果需满足的条件 [GROUP BY …] – 指定结果按照哪几个字段来分组 [HAVING] – 过滤分组的记录必须满足的次要条件 [ORDER BY …] – 指定查询记录按一个或多个条件排序 [LIMIT {[offset,]row_count | row_countOFFSET offset}]; – 指定查询的记录从哪条至哪条 语法：==SELECT 字段,… FROM 表== 有时，列表名不是那么见名知意，可以起别名：AS 去重及数据库的表达式去重：distinct 数据库的列（表达式） ==数据库中的表达式：文本值、列、Null、函数、计算表达式、系统变量…== select ==表达式== from 表 where子句之逻辑运算符作用：检索数据中符合条件的值 搜索的条件由一个或者多个表达式组成，结果布尔值 逻辑运算符 运算符 语法 描述 and &amp;&amp; a and b a&amp;&amp;b 逻辑与 or || a orb a||b 逻辑或 not ! not a !a 逻辑非 ==尽量使用英文字母== 模糊查询：比较运算符 模糊查询：比较运算符 运算符 语法 描述 IS NULL a is null 如果操作符为null，结果为真 IS NOT NULL a is not null 如果操作符不为null，结果为真 BWTWEEN…AND… a between b and c 若a在b和c之间，则结果为真 LIKE a like b SQL匹配，如果a匹配b,则结果为真 IN a in (a1,a2,a3,…) 假设a在a1或者a2或者a3,…其中的某一个，则结果为真 连表查询join on join 对比 七种join理论 操作 描述 inner join 如果表中至少有一个匹配，就返回行 left join 会从左边中返回所有的值，即使右表中没有匹配 right join 会从右边中返回所有的值，即使左表中没有匹配 自连接自己的表和自己的表连接，核心：==一张表拆为两张一样的表即可== 父类 pid category_id category_name 1 2 信息技术 1 3 软件开发 1 5 美术设计 子类 pid category_id category_name 3 4 数据库 2 8 办公信息 3 6 web开发 5 7 ps技术 操作：查询父类对应的子类关系 父类 子类 信息技术 办公信息 软件开发 数据库 软件开发 web开发 美术设计 ps技术 分页和排序 排序 分页 语法： limit (查询起始下标,页面大小) 子查询和嵌套查询where（这个值是计算出来的） 本质：在where语句中嵌套一个子查询语句 常用函数 聚合函数及分组过滤 函数名称 描述 count() 计数 sum() 求和 avg() 平均值 max() 最大值 min() 最小值 数据库级别的md5加密（扩展）什么是MD5? 主要增加算法复杂度和不可逆性。 MD5不可逆，具体的值的md5是一样的 MD5破解网站的原理，背后有一个字典，MD5加密后的值，加密前的值 事务什么是事务==要么都成功，要么都失败== 将一组sql放到一个批次中去执行 事务原则：ACID原则 原子性 、一致性、隔离性、持久性 （脏读，幻读。。。） 参考博客链接：事务ACID理解 原子性（Atomicity） 要么都成功，要么都失败 一致性（Consistency） 事务前后的数据完整性要保持一致 下图操作前和操作后的总和都是1000 隔离性（Isolation） 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性（Durability） 事务一旦移交不可逆，被持久化到数据库中 隔离所导致的一些问题脏读：1、在事务A执行过程中，事务A对数据资源进行了修改，事务B读取了事务A修改后的数据。 2、由于某些原因，事务A并没有完成提交，发生了RollBack操作，则事务B读取的数据就是脏数据。 这种读取到另一个事务未提交的数据的现象就是脏读(Dirty Read)。 不可重复读：事务B读取了两次数据资源，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的数据不一致。 这种**==在同一个事务中==，前后两次读取的数据不一致的现象就是不可重复读(Nonrepeatable Read)。** 虚读(幻读)事务B前后两次读取同一个范围的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后一次读取到前一次查询没有看到的行。 幻读和不可重复读有些类似，但是幻读强调的是集合的增减，而不是单条数据的更新。 第一类更新丢失事务A和事务B都对数据进行更新，但是事务A由于某种原因事务回滚了，把已经提交的事务B的更新数据给覆盖了。这种现象就是第一类更新丢失。 第二类更新丢失其实跟第一类更新丢失有点类似，也是两个事务同时对数据进行更新，但是事务A的更新把已提交的事务B的更新数据给覆盖了。这种现象就是第二类更新丢失。 事务隔离级别为了解决以上的问题，主流的关系型数据库都会提供四种事务的隔离级别。事务隔离级别从低到高分别是：读未提交，读已提交，可重复读，串行化。事务隔离级别越高，越能保证数据的一致性和完整性，但是执行效率也越低，所以在设置数据库的事务隔离级别时需要做一下权衡，mysql默认是可重复读 读未提交读未提交(Read Uncommitted)，是最低的隔离级别，所有的事务都可以看到其他未提交的事务的执行结果。只能防止第一类更新丢失，不能解决脏读，可重复读，幻读，所以很少应用于实际项目。 读已提交读已提交(Read Committed)，在该隔离级别下，一个事务的更新操作只有在该事务提交之后，另外一个事务才可能读取到同一笔数据更新后的结果。可以防止脏读和第一类更新丢失，但是不能解决可重复和幻读的问题。 可重复读（重要）可重复读(Repeatable Read)，mysql默认的隔离级别。在该隔离级别下，一个事务多次读同一个数据，在这个事务还没有结束时，其他事务不能访问该数据（包括了读写），这样就可以在同一个事务内两次读到的数据是一样的。可以防止脏读、不可重复读、第一类更新丢失，第二类更新丢失的问题，不过还是会出现幻读。 串行化串行化(Serializable)，这是最高的隔离级别。它要求事务序列化执行，事务只能一个接着一个的执行，不能并发执行。在这个级别，可以解决上面提到的所有并发问题，但是可能导致大量的超时现象和锁竞争，通常不会用这个隔离级别。 总结 扩展：回滚机制在mysql中，恢复机制是通过回滚日志（undo log）实现的，所有的事务进行的修改都会先记录到这个回滚日志中，然后在堆数据库中的对应进行写入。 mysql的事务是由redo和undo的，redo操作的所有信息都是记录到重做日志（redo_log）中，也就是说当一个事务做commit操作时，需要先把这个事务的操作写到redo_log中，然后在把这些操作flush到磁盘上，当出现故障时，只需要读取redo_log，然后在重新flush到磁盘就行了。 而对于undo就比较麻烦，mysql在处理事务时，会在数据共享表空间里申请一个段就做segment段，用保存undo信息，当在处理rollback，不是完完全全的物理undo，而是逻辑undo，也就是说会之前的操作进行反操作（对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。），但是这些共享表空间是不进行回收的。这些表空间的回收需要由mysql的master thread进程进行回收。 索引 Msql官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构。 提取句子主干，就可以得到索引的本质：索引是数据结构。 索引的分类 在一个表中，主键索引只能有一个，唯一索引可以有多个 主键索引（primary key） 唯一的标识，主键不可重复，只能有一个列作为主键 唯一索引 （unique key） 避免重复的列出现，可以重复，多个列都可以标示为唯一索引 常规索引（key/index） 默认的 index 或者key关键字来设置 全文索引（FullText） 在特定的数据库引擎下才有，myisam 快速定位数据 基础语法 【MySQL优化】——看懂explain_漫漫长途，终有回转；余味苦涩，终有回甘-CSDN博客_explain 测试索引 测试： 索引在小数据量的时候，用处不大，但是再大数据的时候，区分十分明显 索引原则 索引不是越多越好 不要对经常变动的数据加索引 小数据量的表不需要加索引 索引一般加载常用来查询的字段上 索引的数据结构 Hash类型的索引 Btree ：innodb的默认数据结构 CodingLabs - MySQL索引背后的数据结构及算法原理 权限管理和备份用户管理 sql 命令操作 用户表：mysql.user 本质:读这张表进行增删改查 MySQL备份为什么要备份？ 保证重要的数据不丢失 数据转移 mysql数据库备份的方式 直接拷贝物理文件 在sqlyog这种可视化工具中手动导出 在想要导出的表或者库中，右键，导出 使用命令行导出 mysqldump 命令行使用 假设你要备份数据库，防止数据丢失。 把数据库给别人，直接给sql即可。 如何设计一个项目的数据库为什么需要设计 ==当数据库比较复杂的时候，我们就需要设计了== 糟糕的数据库设计 数据冗余，浪费空间 数据库插入和删除都会麻烦、异常（屏蔽使用物理外键） 程序的性能差 良好的数据库设计 节省内存空间 保证数据库的完整性 方便我们开发系统 软件开发中，关于数据库的设计 分析需求，分析业务和需要处理的数据库的需求 概要设计：设计关系图E-R图 设计数据库的步骤（个人博客） 收集信息，分析需求 用户表（用户登录注销，用户的个人信息，写博客，创建分类） 分类表（文章分类，谁创建的） 文章表（文章信息） 评论表 友链表（友情链接信息） 自定义表（系统信息，某个关键的字，或者一些主字段） key:value 关注表(粉丝数) 说说表（发表心情， id…content…create_time） 标识实体（把需求落到每个字段） 标识实体之间的关系 写博客：user –&gt; blog 创建分类：user –&gt; category 关注：user –&gt; user 友链：links 评论：user –&gt; user –&gt; blog (bbs / crm) 三大范式第一范式（1NF） 原子性：保证每一列不可再分 第二范式（2NF） 前提：满足第一范式 第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。 每张表只描述一件事情 第三范式（3NF） 前提：满足第一范式和第二范式 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 规范数据库的设计 规范性和性能的问题 关联查询的表不得超过三张表 考虑商业化的需求和目标（成本，用户体验）数据库的性能更加重要 在规范性能的问题的时候，需要适当的考虑一下规范性 故意给某些表增加一些冗余的字段。（从多表查询中变为单表查询） 故意增加一些计算列（从大数据库降低为小数据量的查询：索引） JDBC数据库驱动驱动：声卡，显卡，数据库 我们的程序会通过数据库驱动，和数据库打交道！ JDBCSUN公司为了简化开发人员的（对数据库的统一）操作，提供了一个（java操作数据库的）规范，俗称JDBC 这些规范的实现由具体的厂商去做~ 对于开发人员来说，我们只需要掌握JDBC接口的操作即可！ java.sql javax.sql 还需要导入一个数据库驱动包 mysql-connector-java-5.1.47.jar 第一个JDBC程序 创建测试数据库 创建一个普通项目 导入数据库驱动（jar包） 编写测试代码 步骤总结： 加载驱动 连接数据库DriverManager 获取执行SQL的对象 Statement 获得返回的结果集 释放连接 JDBC对象解释 DriverManager URL Statement 执行sql对象 、 PreparedStatement 执行sql对象 ResultSet 查询的结果集，封装了所有的查询结果 获得指定的数据类型 遍历，指针 释放资源 statement对象详解==jdbc中的statement对象用于向数据库发送SQL语句，想完成对数据库的增删改查，只需要通过这个对象向数据库发送增删改查语句即可。== Statement对象的executeUpdate方法，用于向数据库发送增、删、改的SQL语句，executeUpdate执行完后，将会返回一个整数（即增删改语句导致了数据库几行数据发送了变化）。 Statement.executeQuery方法用于向数据库发送查询语句，executeQuery方法返回代表查询结果的ResultSet对象。 CRUD操作-create 使用executeUpdate(String sql)方法完成数据添加操作，示例操作： CRUD操作-delete CRUD操作-update CRUD操作-read 代码实现 提取工具类 配置文件db.properties 编写增删改的方法，executeUpdate 查询 sql注入问题sql存在漏洞，会被攻击导致数据泄露 ==SQL会被拼接== 导致结果：错误的用户名或者密码可以获取到全部的用户信息 PreparedStatement对象PreparedStatement可以防止SQL注入，效率更好 增加 删除 更新 查询 防止sql注入 执行结果：查不到任何结果 使用idea连接数据库 连接成功后，就可以选择数据库 连接不上的话，可以看一下下面这里，配置对应的mysql版本 双击数据库 更新数据（提交） idea编写sql JDBC操作事务==要么都成功，要么都失败== ACID原则 原子性：要么全部成功，要么全部失败 一致性：总数不变 隔离性：多个进程互不干扰 持久性：一旦提交不可逆，持久化到数据库了 隔离性的问题： 脏读：一个事务读取了另外一个没有提交的事务 不可重复读：在同一个事务内，重复读取表中数据，表数据发生了改变 幻读：在一个事务内，读取到了别人插入的数据，导致前后读出来的结果不一致 代码实现 开启事务con.setAutoCommit(false); 一组业务执行完毕，提交事务 可以在catch语句中显示的定义回滚语句，但是默认失败就会回滚 正常情况 异常情况 DBCP-C3P0连接池数据库连接 – 执行完毕 – 释放 连接– 释放 是十分浪费系统资源的 池化技术：准备一些预先的资源，过来就连接预先准备好的 最小连接数：10(常用连接) 最大连接数：100 （业务最高承载上线） 等待超时：100ms 编写连接池，实现一个接口DataSource 开源数据源实现 DBCP C3p0 Druid:阿里巴巴 使用了这些数据库连接池之后，我们在项目开发中就不需要编写连接数据库的代码了 DBCP 需要用到的jar包 commons-dbcp-1.4 commons-pool-1.6 配置文件dbcp.properties 工具类 测试类 C3P0 需要用到的jar包 c3p0-0.9.5.5.jar mchange-commons-java-0.2.19.jar 配置文件c3p0-config.xml 工具类 测试类 总结 无论用什么数据源，本质还是一样的，DataSource接口不会变，方法就不会变 Welcome to The Apache Software Foundation! "},{"title":"java基础语法","date":"2022-01-14T11:24:01.000Z","url":"/2022/01/14/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","categories":[["undefined",""]],"content":"基础快捷键 注释 标识符和关键字关键字： abstract assert boolean break byte case catch char class const continue default do double else enum extends final finally float for goto if implements import instanceof int interface long native new package private protected public return strictfp short static super switch synchronized this throw throws transient try void volatile while 数据类型强类型语言：要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用 java的数据类型分为两大类： 基本数据类型：整数类型、浮点类型、字符类型、boolean类型 引用数据类型：类、接口、数组 类型转换 变量、常量、作用域变量： 常量：用final来修饰 运算符 算数运算符：+，_，*，/，%，++，– 赋值运算符：= 关系运算符：&gt;，&lt;，&gt;=，&lt;=，==，!=，instanceof（判断是否是一个类的实例） 逻辑运算符：&amp;&amp;，||，！ 位运算符：&amp;，|，~，&gt;&gt;，&lt;&lt;，&gt;&gt;&gt; 条件运算符：？： 扩展赋值运算符：+=，-=，*=，/= 包机制包语句的语法格式为： 一般利用公司域名倒置作为包名 导包用import语句 javaDoc生成文档jaovDoc命令用来生成自己的API文档 参数信息 @author 作者名 @version 版本号 @since 指明需要最早使用的jdk版本 @param 参数 @return 返回值情况 @throws 异常抛光情况 命令行生成文档： idea生成JavaDoc文档： 流程控制用户交互Scannernext(): 以空格为结束符 一定要读取到有效字符后才可以结束输入 next()不能得到带有空格的字符串 nextLine(): 以Enter为结束符 可以获得空白 判断输入的是否是整数：scanner.has.NextInt() 判断输入的是否是小数：scanner.has.NextFloat() 顺序结构JAVA的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行 它是任何一个算法都离不开的一种基本算法结构 选择结构 循环结构 break &amp; continue break在任何循环语句的主题部分，均可用break控制循环的流程。break用于强制退出循环 continue用于终止某次循环过程 方法Java方法是语句的集合，它们在一起执行一个功能 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用 设计方法的原则：最好保持方法的原子行，就是一个方法只完成1个功能，这样利于我们后期的扩展 定义及调用 方法重载重载就是在一个类中，有相同的函数名称，但形参不同的函数 规则： 方法名称必须相同 参数列表必须不同（个数、类型、参数排列顺序等） 方法的返回类型可以相同也可以不相同 仅仅返回类型不同不足以成为方法的重载 理论：方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法， 如果匹配失败，则编译器保持。 可变参数JDK1.5开始，jav支持传递同类型的可变参数给一个方法 在方法声明中，在指定参数类型后加一个省略号(…) 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。 递归递归：自己调用自己 递归结构： 递归头：什么时候不调用自身方法。如果没有头，将陷入死循环 递归体：什么时候调用自身方法 数组 数组是相同类型数据的有序集合 数组描述的是相同类型的若干数据，按照一定的先后次序排列组合而成 每一个数据称作一个数组元素，用下标来访问 数组声明创建 数组使用 普通的For循环 For-Each循环 数组作方法入参 数组作返回值 多维数组多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组 Arrays类数组的工具类java.util.Arrays 给数组赋值：fill 对数组排序：sort 比较数组：equals 查找数组元素：binarySearch 稀疏数组当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组 处理方式： 记录数组一共有几行几列，有多少个不同的值 把具有不同值的元素和行列及值记录在一个小规模的数组中 面向对象面向对象思想： 物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后才对某个分类下的细节进行面向过程的思索 面向对象适合处理复杂的问题，适合处理需要多人协作的问题 面向对象编程（Object-Oriented Programming,OOP） 面向对象编程的本质：以类的方式组织代码，以对象的组织（封装）数据 抽象 三大特性： 封装 继承 多态 构造器 和类名相同 没有返回值 作用： new本质在调用构造方法 初始化对象的值 注意点： 定义有参构造后，如果想使用无参构造，显示的定义一个无参的构造 封装 我们程序设计要追求”高内聚，低耦合“。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合就是仅暴露少量的方法给外部使用 封装（数据的隐藏）：通常应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问 属性私有，get/set 好处： 提高程序的安全性，保护数据 隐藏代码的实现细节 统一接口 系统可维护性增加 继承 继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模 extends的意思是”扩展“。子类是父类的扩展 JAVA中类只有单继承，没有多继承 继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖。组合、聚合等 继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示 在JAVA中，所有的类都默认直接或间接继承Object 私有的东西无法被继承 supersuper注意点 super调用父类的构造方法，必须在构造方法的第一个 super必须只能出现在子类的方法或者构造方法中 super和this不能同时调用构造方法 Vs this： 代表的对象不同 this：本身调用者这个对象 super：代表父类对象的应用 前提 this：没有继承也可以使用 super：只能在继承条件才可以使用 构造方法 this（）：本来的构造 super（）：父类的构造 方法重写重写都是方法的重写，和属性无关 需要有继承关系，子类重写父类的方法 子类的方法和子类必须一致，方法体不同 方法名必须相同 参数列表必须相同 修饰符：范围可以扩大不能缩小 public&gt;Protect&gt;Default&gt;private 抛出的异常：范围，可以被缩小，不能扩大：ClassNotFoundException –&gt; Exception(大) 为什么需要重写： 父类的功能，子类不一定需要，或不一定满足 多态 多态即同一方法可以根据发送对象的不同而采用多种不同的行为方式 一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多（父类，有关系的类） 多态存在的条件 有继承关系 子类重写父类方法 父类引用指向子类对象 注意：多态是方法的多态，属性没有多态性 把子类转换为父类，向上转型 把父类转换为子类，向下转型 强制转换 方便方法的调用，减少重复的代码 简洁 instanceof 判断一个对象是什么类型 static抽象类abstract，抽象方法，只要方法名字，没有方法实现 不能new这个抽象类，只能靠子类去实现它；约束！ 抽象类中可以写普通的方法 抽象方法必须在抽象类中 抽象的抽象：约束 接口 普通类：只有具体实现 抽象类：具体实现和规范（抽象方法）都有 接口：只有规范 OO的精髓，是对对象的抽象，最能体现这一点的就是接口。 声明接口的关键字是interface 实现接口用implements 接口不能被实例化，接口中没有构造方法 内部类在一个类的内部定义一个类 成员内部类 静态内部类 局部内部类 匿名内部类 异常 异常（Exception）指程序运行中出现的不期而至的各种状况，如：文件找不到，网络连接错误，非法参数等 异常发生在程序运行期间，它影响了正常的程序执行流程 检查性移仓：最具代表的检查性异常是用户错误或问题引起的异常 运行时异常：是可能被程序员避免的异常 错误：错误不是异常，而是脱离程序员控制的问题 异常体系结构 java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类 在Java API中已经定义了许多异常类，常分为两大类，错误Error和异常Exception Error Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关 Java虚拟机运行错误，当JVM不再有继续执行操作所需的内存资源是，将出现OutOfMemoryError。这些异常发生时，JVM一般会选择线程终止 还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError），连接错误（LinkageError）。 Exception 在Exception分支中有一个重要的子类RuntimeException（运行时异常） ArrayIndexOutOfBoundsException（数组小标越界） NullPointerException（空指针异常） ArithmeticException（算术异常） MissingResourceException（丢失资源） ClassNotFoundException（找不到类） 这些异常一般时由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生 Error和Exception的区别：Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，JVM一般会选择终止线程。Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。 捕获、抛出异常 抛出异常 捕获异常 异常处理五个关键字：try、catch、finally、throw、throws 自定义异常 处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理 在多重catch快后面，可以加一个catch(Exception)来处理可能会被遗漏的异常 对应不确定的代码，也可以加上try-catch，处理潜在的异常 尽量去处理异常，切忌只是简单地调用PrintStackTrace（）去打印输出 具体如何处理异常，要根据不同的业务需求和异常类型去决定 尽量添加finally语句块去释放占用的资源 常用类 包装类 针对八种基本数据类型相应的引用类型—-包装类 有了类的特点，就可以调用类中的方法 基本数据类型 包装类 父类 boolean Boolean Object char Character Object byte Byte Number short Short Number int Integer Number long Long Number float Float Number double Double Number 包装类与String互转 String 字符串不可变，他们的值在创建后不能被更改 String的值不可变，但是它们可以被共享 构造方法： 字符串比较使用==做比较 基本类型：比较的是数据值是否相同 引用类型：比较的是地址值是否相同 字符串是对象，它比较内容是否相同，是用equals()比较多 字符串遍历 常用方法indexOf()：返回指定字符的索引。charAt()：返回指定索引处的字符。 toCharArray()：把字符串转变成字符数组 replace()：字符串替换。trim()：去除字符串两端空白。split()：分割字符串，返回一个分割后的字符串数组。getBytes()：返回字符串的 byte 类型数组。length()：返回字符串长度。toLowerCase()：将字符串转成小写字母。toUpperCase()：将字符串转成大写字符。substring()：截取字符串。equals()：字符串比较。 StringBuffer可变长字符串，JDK1.0提供，运行效率慢、线程安全 StringBuilder可变长字符串，JDK5.0提供，运行效率快、线程不安全 如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，即耗时又浪费内存空间。 StringBuilder是一个可变的字符串类，可以把它看成是一个容器 构造方法 添加和反转 StringBuilder和String相互转换 StringBuilder –&gt; String：通过toString() String –&gt; tringBuilder：通过构造方法 Date构造方法 常用方法 SimpleDateFormatSimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期 日期和时间格式由日期和时间模式字符串指定，其中，从’A’到’Z’以及从’a’到’z’引号的字母被解释为表示日期或时间字符串的组件的模式字母 常用的模式字母及对应关系如下： y 年 M 月 d 日 H 时 m 秒 s 分 方法 CalendarCalendar为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法 集合集合类的特点：提供一种存储空间可变的存储模型，存储的数据容量可以发生改变 ArrayListArrayList: 可调整大小的数组实现 ：是一种特殊的数据类型，泛型 构造和添加方法 常用方法public boolean remove(Object o);删除指定的元素，返回删除是否成功 public E remove(int index);删除指定索引处的元素，返回被删除的元素 public E set(int index,E element);修改指定索引处的元素，返回被修该的元素 public E get(int index);返回指定索引处的元素 public int size();返回集合中的元素的个数 Collection集合概述： 是单例集合的顶层接口，它表示一组对象，这些对象也被称为Collection的元素 JDK不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List）实现 创建Collection集合的对象 多态的方式 具体的实现类ArrayList 构造方法 常用方法 boolean add(E e) //添加元素 boolean remove(Object o) //从该集合中删除指定元素 void clear() //清空集合中的元素 boolean contains(Object o) //判断集合中是否存在指定的元素 boolean isEmpty() //判断集合是否为空 int size() //集合的长度，也就是集合中元素的个数 集合的遍历Iterator：迭代器，集合的专用遍历方式 Iterator iterator(); 返回此集合中元素的迭代器，通过集合的iterator()方法得到 迭代器是通过集合的iterator()方法得到的，所以我们说它是依赖于集合而存在的 Iterator中的常用方法： E next(); 返回迭代中的下一个元素 boolean hasNext(); 如果迭代具有更多元素，则返回true ListList集合概述 有序集合（也称为序列 ）。 该界面的用户可以精确控制列表中每个元素的插入位置。 用户可以通过整数索引（列表中的位置）访问元素，并搜索列表中的元素。 与Set集合不同，列表通常允许重复的元素。 List集合特点 有序：存储和取出的元素顺序一致 可重复：存储的元素可以重复 构造方法 常用方法 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 并发修改异常 并发修改异常（ConcurrentModificationException） 原因：迭代器遍历过程中，通过集合对象修改了集合中元素的长度，导致了迭代器获取元素中判断预期修改值和实际修改值不一致 解决方案：用for循环遍历，然后用集合对象做对应的操作即可 ListIteratorListItertor：列表迭代器 通过List集合的listIterator()方法得到，所以说它是List集合特意的迭代器 用于允许程序员沿任一方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置 ListIterator中的常用方法： E next()：返回迭代中的下一个元素 boolean hasNext()：如果迭代具有更多元素，则返回true E previous()：返回列表中的上一元素 boolean hasPrevious()：如果此列表迭代器在相反方向遍历列表时具有更多元素，则返回true void add(E e)：将指定的元素插入列表 增强for循环增强for：简化数组和Collection集合的遍历 实现Iterable接口的类允许其对象成为增强型语句的目标 它时JDK5之后出现的，其内部原理是一个Iterrator迭代器 增强for的格式 格式： 范例 List集合子类List集合常用子类：ArrayList、LinkedList ArrayList：底层数据结构是数组，查询快，增删慢 LinkedList：底层数据结构是链表，查询慢，增删快 LinkedList集合的特有功能 public void addFirst(E e); 在该列表开头插入指定的元素 public void addLast(E e); 将指定的元素追加到此列表的末尾 public E getFirst(); 返回此列表中的第一个元素 public E getLast(); 返回此列表中的最后一个元素 public E removeFirst(); 从此列表中欧给删除并返回第一个元素 public E removeLast(); 从此列表中欧给删除并返回最后一个元素 Setset集合特点 不包含重复元素的集合 没有带索引的方法，所以不能使用普通for循环遍历 哈希值哈希值：是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值 Object类中有一个方法可以获取对象的哈希值 Public int hashCode(); 返回对象的哈希码值 对象的哈希值特点 同一个对象多次调用hashCode()方法返回的哈希值是相同的 默认情况下，不同对象的哈希值是不同的，而重写hasCode()方法，可以使其相同 HashSet集合特点 底层数据结构使哈希表 对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致 没有带索引的方法，所以不能使用普通for循环遍历 由于是Set集合，所以不包含重复元素 LinkedHashSetLinkedHashSet集合概述和特点 哈希表和链表实现的Set接口，具有可预测的迭代次序 由链表保证元素有序，也就是说元素的存储和取出顺序一致 由哈希表保证元素唯一，也就是说没有重复的元素 TreeSetTreeSet集合特点 元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方法取决于构造方法 TreeSet(); 根据其元素的自然排序进行排序 TreeSet(Comparator comparator); 根据指定的比较器进行排序 没有带索引的方法，所以不能使用普通的for循环遍历 由于是Set集合，所以不包含重复元素的集合 Comparable 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 Comparator 泛型泛型：是JDK5中引入的特性，它提供了编译时类型安全检测机制，该极致允许在编译时检测到非法的类型 它的本质时参数化类型，也就是说所操作的数据类型被指定为一个参数 泛型定义格式： &lt;类型&gt;：指定一种类型的格式。这里的类型可以看成是形参 &lt;类型1，类型2…&gt;：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成事形参 将来具体调用时给定的类型可以看成事实参，并且实参的类型只能是引用数据类型 泛型的好处： 把运行时期的问题提前到了编译期间 避免了强制类型转换 泛型类泛型类的定义格式： 格式：修饰符 class 类名 &lt;类型&gt;{} 范例：public class Generic{} 此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型 泛型方法泛型方法的定义格式： 格式：修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名){} 范例：public void show(T t){} 泛型接口泛型接口的定义格式： 格式：修饰符 interface 接口名&lt;类型&gt;{} 范例：public interface Generic{} 类型通配符为了表示各种泛型List的父类，可以使用类型通配符 类型通配符：&lt;?&gt; List&lt;?&gt;：表示元素类型未知的List，它的元素可以匹配任何的类型 这种带通配符的List仅代表它是各种泛型List的父类，并不能把元素添加到其中 如果说我们不希望List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限 类型通配符上限：&lt;? extends 类型&gt; List&lt;? extends Number&gt;：它表示的类型是Number或者其子类型 除了可以指定类型通配符的上限，我们也可以指定其下限 类型通配符下限：&lt;? super 类型&gt; List&lt;? super Number&gt;：它表示的类型是Number或者其父类型 可变参数可变参数又称参数个数可变，用作方法的形参出现，那么方法的参数个数就是可变的了 格式：修饰符 返回值类型 方法名(数据类型…变量名){} 范例：public static int sum(int…a){} 注意事项： 这里的变量其实是一个数组 如果一个方法有多个参数，包含可变参数，可变参数要放在最后 可变参数的使用Arrays工具类中有一个静态方法： public static List asList(T…a); 返回由指定数组支持的固定大小的列表 返回的集合不能做增删操作，可以做修改操作 List接口中有一个静态方法： public static List of(E…elements); 返回包含任意数量元素的不可变列表 返回的集合不能做增删改操作 Set接口中有一个静态方法： public static Set of(E…elements); 返回一个包含任意数量元素的不可变集合 返回的集合不能做增删操作，没有修改的方法 MapMap集合概述： Interface Map&lt;K,V&gt; K：健的类型；V：值的类型 将健映射到值的对象；不能包含重复的健；每个健可以映射到最多一个值 举例：学生的学号和姓名 创建Map集合的对象： 多态的方式 具体的实现类HashMap 常用方法 V put(K key,V value); 添加元素 V remove(Object key); 根据健删除键值对元素 void clear(); 移除所有的键值对元素 boolean containsKey(Object key); 判断集合中是否包含指定的健 boolean containsValue(Object value); 判断集合中是否包含指定的值 boolean isEmpty(); 判断集合是否为空 int size(); 集合长度，也就是集合中键值对的个数 Map集合的获取功能 V get(Object key); 根据健获取值 Set keySet(); 获取所有健的集合 Collection values(); 获取所有值的集合 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(); 获取所有键值对对象的集合 HashMap案例ArrayList集合存储HashMap元素并遍历: HashMap集合存储ArrayList元素并遍历: 统计字符串中每个字符出现的次数： CollctionsCollections类是针对集合操作的工具类 常用方法 public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List list); 将指定的列表按升序排序 public static void reverse(List&lt;?&gt; list); 反转指定列表中元素的顺序 public static void shuffle(List&lt;?&gt; list); 使用默认的随机源随机排序指定列表 案例ArrayList存储学生对象并排序 模拟斗地主： 模拟斗地主升级版： 常用APIMathmath包含执行基本数字运算的方法 静态类，通过类名可以直接调用 工具类的设计思想： 构造方法用private修饰 成员用public static修饰 常用方法 方法名 说明 public static int abs(int a) 返回参数的绝对值 public static double ceil(double a) 返回大于或等于参数的最小double值，等于一个整数 public static double floor(double a) 返回小于或等于参数的最大double值，等于一个整数 public static int round(float a) 按照四舍五入返回最接近参数的int public static int max(int a,int b) 返回两个int值中的较大值 public static int min(int a,int b) 返回两个int值中的较小值 public static double pow(double a,double b) 返回a的b次幂的值 public static double random() 返回值为double的正值，[0.0,1.0) SystemSystem包含几个有用的类字段和方法，它不能被实例化 常用方法 方法名 说明 public static void exit(int status) 终止当前运行的java虚拟机，非零表示异常终止 public static long currentTimeMillis() 返回当前的时间（以毫秒为单位） ObjectObject是类层次结构的根，每个类都可以将Object作为超类，所有类都直接或间接的继承自该类 构造方法：public Object(); 常用方法 public String toString();//返回对象的字符串表示形式，建议所有子类重写此方法，自动生成即可 public boolean equals(Object obj);//比较对象是否相等。默认比较地址，重写可以比较内容，自动生成 ArraysArrays类包含用于操作数组的各种方法 常用方法 public static String toString(int[] a);返回指定数组的内容的字符串表示形式 public static void sort(int[] a);按照数字顺序排列指定的数组 IO IO流概述： IO：输入/输出(Input/Output) 流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输 IO流就是用来处理设备间数据传输问题的，如：文件复制、文件上传、文件下载 分类： 按照数据的流向： 输入流：读数据 输出流：写数据 按照数据类型： 字节流：字节输入流、字节输出流 字符流：字符输入流、字符输出流 如果数据通过记事本软件打开，可以读懂，用字符流 否则用字节流，一般默认字节流 FileFile：它是文件和目录路径名的抽象表示 文件和目录是可以通过File封装成对象的 对应File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的 构造方法 File(String pathname); 通过将给定的路径名字符串转换为抽象路径名来创建新的File实例 File(String parent,String child); 从父路径名字符串和子路径名字符串创建新的File实例 File(File parent,String child); 从父抽象路径名和子路径名字符串创建新的File实例 创建方法 public boolean createNewFile(); 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 public boolean mkdir(); 创建由此抽象路径名命名的目录 public boolean mkdirs(); 创建由此抽象路径名命名的目录，包括任何必须但不存在的父目录 判断和获取功能 public boolean isDirectory(); 测试此抽象路径名表示的File是否为目录 public boolean isFile(); 测试此抽象路径名表示的File是否为文件 public boolean exists(); 测试此抽象路径名表示的File是否为存在 public String getAbsolutePath(); 返回此抽象路径名的绝对路径名字符串 public String getPath(); 将此抽象路径名转换为路径名字符串 public String getName(); 返回此抽象路径名表示的文件或目录的名称 public String[] list(); 返回此抽象路径名表示的目录中的文件和目录的名称字符串数组 public File[] listFiles(); 返回此抽象路径名表示的目录中的文件和目录的File对象数组 删除功能 public boolean delete(); 删除由此抽象路径名表示的文件或目录 注意事项 如果一个目录中有内容（目录，文件），不能直接删除。应该先删除目录中的内容，最后才能删除目录 案例遍历目录： 字节流字节流抽象基类： InputStream：这个抽象类是表示字节输入流的所有类的超类 OutputStream：这个抽象类是表示字节输出流的所有类的超类 子类名特点：子类名称都是以其父类名作为子类名的后缀 FileOutputStreamFileOutputStream：文件输出流用于将数据写入File FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 使用字节输出流写数据的步骤： 创建字节输出流对象（调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件） 调用字节输出流对象的写数据方法 释放资源 写数据方法 void write(int b)：将指定的字节写入此文件输出流，一次写一个字节数据 void write(byte[] b)：将b.length字节从指定的字节数组写入此文件输出流，一次写一个字节数组数据 void write(byte[] b,int off,int len)：将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流，一次写一个字节数组的部分数据 换行和追加写入换行： 写完数据后，加换行符 windows：\\r\\n linux：\\n mac：\\r 追加写入： public FielOutputStream(String name,boolean append) 创建文件输出流以指定的名称写入文件。如果第二个参数为true，则字节将写入文件的末尾而不是开头 异常 FileInputStreamFileInputStream：从文件系统中的文件获取输入字节 FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream，该文件由文件系统中的路径名name命名 使用字节输入流写数据的步骤： 创建字节输入流对象 调用字节输入流对象的读数据方法 释放资源 读字节数组数据 案例字节流复制文本文件： 复制图片 复制视频 字节缓冲流字节缓冲流： BufferedOutputStream：该类实现缓冲输出流。通过设置这样的输出流，应用程序可以想底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用 BufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组。当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节 构造方法： 字节缓冲输出流：BufferedOutputStream(OutputSteam out) 字节缓冲输入流：BufferedInputStream(InputStream in) 字节缓冲流仅仅提供缓冲区，而真正的读写数据还得依靠基本得字节流对象进行操作 字符流由于字节流操作中文不是特别方便，所有java就提供了字符流 字符流 = 字节流 + 编码表 用字节流复制文本文件时，最终底层操作会自动进行字节拼接成中文 汉字在存储时，无论选择哪种编码存储，第一个字节都是负数 编码表 Ascll GBK UTF-8 编码： byte[] getBytes(),使用平台的默认字符集将String编码为一系列字节，将结果存储到新的字节数组中 byte[] getBytes(String charsetName)，使用指定得字符集将String编码为一系列字节，将结果存储到新的字节数组中 解码： String(byte[] bytes)，通过使用平台的默认字符集解码指定的字节数组来构造新的String String(byte[] bytes, String charsetName)，通过指定的字符集解码指定的字节数组来构造新的String 字符流的编码解码字符流抽象基类： Reader：字符输入流的抽象类 Writer：字符输出流的抽象类 字符流中和编码解码问题相关的两个类： InputStreamReader OutputStreamWriter 写数据方法 void write(int c)： 写一个字符 void write(char[] cbuf)： 写入一个字符数组 void write(char[] cbuf,int off,int len)： 写入字符数组的一部分 void write(String str)： 写一个字符串 void write(String str,int off,int len)： 写一个字符串的一部分 读数据方法 int read()： 一次读一个字符数据 int read(char[] cbuf)： 一次读一个字符数组数据 案例复制java文件 复制java文件（改进版） 为了简化书写，转换流提供了对应的子类 FileReader：用于读取字符文件的便捷类 FileReader(String fileName) FileWriter：用于写入字符文件的便捷类 FileWriter(String fileName) 复制java文件（字符缓冲流改进版） 字符缓冲流 BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途 BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。默认值足够大，可用于大多数用途 特有功能 BufferedWriter: void newLine()：写一行行分隔符，行分割符字符串由系统属性定义 BufferedReader： public String readLine()：读一行文字，结果包含行的的内容的字符串，不包括任何行终止字符，如果流的结尾已经到达，则为null 案例集合到文件： 文件到集合： 复制单级文件夹 复制多级文件夹 特殊操作流标准输入输出流System类中有两个静态的成员变量： public static final InputStream in：标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的另一个输入源 public static final PrintStream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输入目标 自己实现键盘录入数据 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); Java提供了一个类实现键盘录入 Scanner sc = new Scanner(System.in); 输出语句的本质：是一个标准的输出流 PrintStream ps = System.out; PrintStream类有的方法，System.out都可以使用 打印流打印流分类： 字节打印流：PrintStream 字符打印流：PrintWriter 打印流的特点： 只负责输出数据，不负责读取数据 有自己的特有方法 字节打印流： PrintStream(String fileName)：使用指定的文件名创建新的打印流 使用继承父类的方法（write()）写数据，查看时会转码；使用自己特有的方法（print（））写数据，查看的数据原样输出 字符打印流： PrintWriter(String fileName) 使用指定的文件名创建一个新的PrintWriter，而不需要自动执行刷新 PrintWriter(Writer out,boolean autoFlush) 创建一个新的PrintWriter，out：字符输出流；autoFlush：若为真，则Println，printf，format方法将刷新输出缓冲区 对象序列化流对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象 对象序列化流：ObjectOutputStream 对象反序列化流对象反序列化流：ObjectInputStream 多线程 线程简介 程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念 进程是执行程序的一次执行过程，是一个动态的概念。是系统资源分配的单位 一个进程中可以包含若干个线程。线程是CPU调度和执行的单位 核心概念： 线程就是独立的执行路径 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程 main()称之为主线程，为系统的入口，用于执行整个程序 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为的干预的 堆同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制 线程会带来额外的开销，如cpu调度时间，并发控制开销 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致 线程实现（重点）创建线程的三种方式： 继承Thread类 子类继承Thread类具有多线程能力 启动线程：子类对象.start() 不建议使用：避免OOP单继承局限性 实现Runnable接口 实现接口Runnable具有多线程能力 启动线程：传入目标对象+Thread对象.start() 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 实现Callable接口 Thread 自定义线程类继承Thread类 重写run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程 案例：下载网图 Runnable 自定义类实现Runnable接口 实现run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程 案例并发： 龟兔赛跑： Callable 实现Callable接口，需要返回值类型 重写call方法，需要抛出异常 创建目标对象 创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(3); 提交执行：Future r1 = ser.submit(t1); 获取结果：boolean rs1 = r1.get(); 关闭服务：ser.shutdownNow(); Lambda 避免匿名内部类定义过多 其实质属于函数式编程得概念 理解Functional Interface（函数式接口）是学习Java8 lambda表达式得关键所在 函数式接口得定义： 任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口 对于函数式接口，我们可以通过lambda表达式来创建该接口的对象 总结： lambda表达式只能在有一行代码的情况下才能简化成为一行，如果有多好，那么就用代码块包裹 前提是接口为函数式接口 多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号 静态代理模式 真实对象和代理对象都要实现同一个接口 代理对象要代理真实角色 好处： 代理对象可以做很多真实对象做不了得事情 真实对象专注做自己得事情 线程状态 线程方法 setPriority(int newPriority) 更改线程优先级 static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程休眠 void join() 等待该线程终止 static void yield() 暂停当前正在执行的线程对象，并执行其他线程 void interrupt() 中断线程，别用这个方式 boolean isAlive() 测试线程是否处于活动状态 线程停止： 建议线程正常停止—&gt;利用次数，不建议死循环 建议使用标志位–&gt;设置一个标志位 不要使用stop或者destroy等过时或JDK不建议使用的方法 线程休眠 sleep(时间)指定当前线程阻塞的毫秒数 sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延时，倒计时等 每一个对象都有一个锁，sleep不会释放锁 线程礼让 礼让线程，让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让cpu重新调度，礼让不一定成功！看CPU心情 线程强制执行 Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞 可以想象成插队 线程状态观测Thread.State：线程状态。线程可以处于以下状态之一 NEW RUNNABLE BLOCKED WAITING TIMED_WAITING TERMINATED 线程优先级 Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度那个线程来执行 现成的优先级用数字表示，范围从1~10 Thread.MIN_PRIORITY = 1 Thread.MAX_PRIORITY = 10 Thread.NORM_PRIORITY = 5 使用一些方式改变或获取优先级 getPriority() setPriority(int x) 收获线程 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕 如，后台记录操作日志，监控内存，垃圾回收等待 线程同步（重点） 线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用 形成条件：队列+锁 由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题： 一个线程持有锁会导致其他所有需要此锁的线程挂起 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题 线程不安全的集合： 同步方法 由于我们可以通过private关键字来保证数据对象只能被方法访问，所以只需要针对方法提出一套机制，也就是synchronized关键字，它包括两种用法：synchronized方法和synchronzied块 同步方法：public synchronized void method(int args){} synchronzied方法控制对对象的访问，每个对象对应一把锁，每个synchronzied方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，知道该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行 缺陷：若将一个大的方法申明为synchronzied将会影响效率 弊端：方法里需要修改的内容才需要锁，锁的太多，浪费资源 同步块 同步块：synchronzied(Obj){} Obj称之为同步监视器 Obj可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class 同步监视器的执行过程 第一个线程访问，锁定同步监视器，执行其中代码 第二个线程访问，发现同步监视器被锁定，无法访问 第一个线程访问完毕，解锁同步监视器 第二个线程访问，发现同步监视器没有锁，然后锁定并访问 锁的对象是变化的量，需要增删改的对象 死锁 多个线程各自占有一些共有资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有“两个以上对象的锁”时，就可能发生死锁问题 产生死锁的四个必要条件： 互斥条件：一个资源每次只能被一个进程使用 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系 Lock（锁） 从JDK5.0开始，Java提供了更强大的线程同步机制—-通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象 ReentrantLock类实现了Lock，它拥有与synchronized相同的并分性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显示加锁、释放锁 synchronized与Lock对比 Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，除了作用域自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） 优先使用顺序： Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源）&gt;同步方法（在方法体之外） 线程通信 应用场景：生产者和消费者问题 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费 如果仓库中没有产品，则生产者将产品放入仓库，否则停止生成并等待，直到仓库中的产品被消费者取走为止 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止 这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件 在此问题中，仅有synchronized是不够的 synchronized可阻止并发更新同一个共享资源，实现了同步 synchronized不能用来实现不同线程之间的消息传递（通信） 方法 wait() 表示线程一直等待，知道其他线程通知，与sleep不同，会释放锁 wait(long timeout) 指定等待的毫秒数 notify() 唤醒一个处于等待状态的线程 notifyAll() 唤醒同一个对象上所有调用wait()方法的线程，优先级高的线程优先调度 均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常 管程法 生产者：负责生产数据的模块（可能是方法，对象，线程，进程） 消费者：负责处理数据的模块（可能是方法，对象，线程，进程） 缓冲区：消费者不能直接使用生产者的数据，他们之间有个“缓冲区” 生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据 信号灯法 线程池 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大 思路：提前创建好多个线程，放入线程池中，使用是直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具 好处： 提高响应时间（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理（…） corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后终止 JDK5.0起提供了线程池相关API：ExecutorService和Executors ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor void execute(Runnable command)： 执行任务/命令，没有返回值，一般用来执行Runnable Future submit(Callable task)： 执行任务，有返回值，一般用来执行Callable void shutdown()： 关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 总结总结线程的创建 注解和反射 注解什么是注解Annotation是从JDK5.0开始引入的新技术 Annotation的作用： 不是程序本身，可以对程序作出解释。（这一点和注释（comment）没什么区别） 可以被其他程序（如：编译器等）读取 Annotation的格式： 注解是以”@注释名”在代码中存在的，还可以添加一些参数值，如：@SuppressWarnings(value=:unchecked”) Annotation在那里使用？ 可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问 内置注解 @Override：定义在java.lang.Override中，此注释只适用于修斯方法，表示一个方法声明打算重写超类中的另一个方法声明 @Deprecated：定义在java.lang.Deprecated中，此注释可以用于修斯方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择 @SuppressWarnings：定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息 与前两个注释不同，需要添加一个参数才能正确使用 @SuppressWarnings(“all”) SuppressWarnings(“unchecked”) SuppressWarnings(value={“unchecked”,”deprecation”}) 等等…… 元注解 元注解的作用就是负责注解其他注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明 @Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期 SOURCE &lt; CLASS &lt; RUNTIME @Document：说明该注解将被包含在javadoc中 @Inherited：说明子类可以继承父类中的该注解 自定义注解使用 @interface自定义注解时，自动继承了java.lang.annotation.Annotation接口 @interface用来声明一个注解，格式：public @ interface 注解名 {定义内容} 其中的每一个方法实际上是声明了一个配置参数 方法的名称就是参数的名称 返回值类型就是参数的类型（返回值只能是基本类型，Class，String，Enum） 可以通过default来声明参数的默认值 如果只有一个参数成员，一般参数名为value 注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值 反射 动态语言：是一类在运行时可以改变其结果的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或时其他结果上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构 主要动态语言：Object-C、C#、JavaScript、PHP、Python等 静态语言：运行时结构不可变的语言。 如Java、C、C++ java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性 什么是反射 Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过镜子可以看到类的结构，姑称之为：反射 功能： 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时处理注解 在运行时调用任意一个对象的成员变量和方法 在运行时获取泛型信息 生成动态代理 。。。。。。 优点： 可以实现动态创建对象和编译，体现出很大的灵活性 缺点： 对性能有影响。 Class类在Object类中定义了以下方法，此方法将被所有子类继承 public final Class getClass() Class类的常用方法 static Class forName(String name) 返回指定类名name的Class对象 Object newInstance() 调用缺省构造函数，返回Class对象的一个实例 getName() 返回此Class对象所表示的实体（类，接口，数组类或void）的名称 Class getSuperClass() 返回当前Class对象的父类的Class对象 Class[] getInterfaces() 获取当前Class对象的接口 ClassLoader getClassLoader 返回该类的类加载器 Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组 Method getMothod(String name,Class.. T) 返回一个Method对象，此对象的形参类型为paramType Field[] getDeclaredFields() 返回Field对象的一个数组 那些类型有Class对象 class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类 interface：接口 []：数组 enum：枚举 annotation：注解@interface primitive type：基本数据类型 void java内存分析java内容： 堆 存放new的对象和数据 可以被所有的线程共享，不会存放别的对象引用 栈 存放基本变量类型（会包含这个基本类型的具体数值） 引用对象的变量（会存放这个引用在堆里面的具体地址） 方法区 可以被所有的线程共享 包含了所有的class和static变量 类的加载与ClassLoader的理解 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象 链接：将Java类的二进制代码合并到 JVM的运行状态之中的过程 验证：确保加载的类信息符合JVM规范，没有安全方面的问题 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程 初始化： 执行类构造器()方法的过程。类构造器()方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器） 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化 虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步 类初始化时间 类的主动引用（一定会发生类的初始化） 当虚拟机启动，先初始化main方法所在的类 new一个类的对象 调用类的静态成员（除了final常量）和静态方法 使用java.lang.reflect包的方法对类进行反射调用 当初始化一个类，如果其父类没有被初始化，则会先初始化它的父类 类的被动引用（不会发生类的初始化） 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） 类加载器的作用 类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后再堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象 类加载器作用是用来把类（class）装载进内存的。JVM规范定义了如下类型的类的加载器： 引导类加载器：用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库。该加载器无法直接获取 扩展类加载器：负责jre/lib/ext目录下的jar包或—D java.ext.dirs指定目录下的jar包装入工作库 系统类加载器：负责java -classpath 或—D java.class.path所指目录下的类与jar包装入工作，是最常用的加载器 获取运行时类的完整结构通过反射获取运行时类的完整结构： Field、Method、Constructor、Superclass、Interface、Annot 实现的全部接口 所继承的父类 全部的构造器 全部的方法 全部的Field 注解 。。。 动态创建对象执行方法创建类的对象：调用Class对象的newInstance()方法 类必须有一个无参数的构造器 类的构造器的访问权限需要足够 没有无参数的构造器： 通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数 通过Constructor实例化对象 调用指定的方法： 通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型 之后使用Object invoke(Object obj,Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息 setAccessible Method和Field、Constructor对象都有setAccessible方法 setAccessible作用时启动和禁用访问安全检查的开关 参数值为true则知指示反射的对象在使用时应该取消java语言访问检查 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true 使得原本无法访问的私有成员也可以访问 参数值为false则指示反射的对象应该实施java语言访问检查 性能分析 反射操作泛型（了解即可） Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型有关的类型全部擦除 为了通过反射操作这些类型，Java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型 ParameterizedType：表示一种参数化类型，如Collection GenericArrayType：表示一种元素类型时参数化类型或者类型变量的数组类型 TypeVariable：是各种类型变量的公共父接口 WildcardType：代表一种通配符类型表达式 反射操作注解 JDK8新特性Lambda表达式Lambda和匿名内部类在使用上的区别： 所需的类型不一样： 匿名内部类：需要的类型可以是类，抽象类，接口 Lambda表达式，需要的类型必须是接口 抽象方法的数量不一样 匿名内部类所需的接口中抽象方法的数量随意 Lambda表达式所需的接口只能有一个抽象方法 实现原理不同 匿名内部类是在编译后会形成class Lambda表达式是在程序运行的时候动态生成class 小结：当接口中只有一个抽象方法时，建议使用Lambda表达式，其他情况还是需要使用匿名内部类 集合之Stream流式操作接口的增强JDK8接口新增两个方法： 默认方法 静态方法 JDK8以前的接口： JDK8的接口 默认方法在JDK 8以前接口中只能有抽象方法。存在以下问题： 如果给接口新增抽象方法，所有实现类都必须重写这个抽象方法。不利于接口的扩展 因此，在JDK 8时为接口新增了默认方法，格式如下： 静态方法为了方便接口扩展，JDK 8为接口新增了静态方法 静态方法不能重写 格式如下： 默认方法和静态方法的区别 默认方法通过实例调用，静态方法通过接口名调用 默认方法可以被继承，实现类可以直接使用接口默认方法，也可以重写接口默认方法 静态方法不能被继承，实现类不能重写接口静态方法，只能使用接口名调用 小结： 如果这个方法需要被实现类继承或重写，使用默认方法，否则使用静态方法 并行数组排序Optional中避免Null检查新的时间和日期API可重复注解"}]