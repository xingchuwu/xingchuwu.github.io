[{"date":"2022-01-14T11:58:49.950Z","url":"/2022/01/14/leetCode/","categories":[["undefined",""]]},{"title":"网络编程","date":"2022-01-14T11:45:52.000Z","url":"/2022/01/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","categories":[["undefined",""]],"content":"概述计算机网络计算机网络是指将==地理位置不同==的具有独立功能的==多台计算机及其外部设备，通过通信线路连接起来==，在网络操作系统，网络管理软件，及==网络通信协议==的管理和协调下，==实现资源共享==和信息传递的计算机系统 网络编程的目的无线电台…传播交流信息，==数据交换==，==通信== 网络通信的要素 网络编程中两个主要问题 如何准确定位到网络上的一台或者多台主机 找到主机之后如何进行通信 网络编程中的要素 IP 和 端口号 网络通信协议 Java，万物皆对象 OSI七层网络模型 TCP/IP四层概念模型 对应网络协议 应用层 应用层 HTTP、TFTP，FTP，NFS，WAIS、SMTP 表示层 应用层 Telnet，Rlogin，SNMP，Gopher 会话层 应用层 SMTP，DNS 传输层 传输层 TCP，UDP 网络层 网络层 IP，ICMP，ARP，RARP，AKP，UUCP 数据链路层 数据链路层 FDDI，Ethernet，Arpanet，PDN，SLIP，PPP 物理层 数据链路层 IEEE 802.1A，IEEE 802.2到IEEE 802.11 IPip地址：InetAddress 唯一定位一台网络上计算机 127.0.0.1：本机localhost ip地址的分类 ipv4 / ipv6· ==IPV4== 127.0.0.1 ,4个字节组成 。0~255，42亿 ；30亿在北美，亚洲4亿。2011年就用尽 ==IPV6== fe80::45b5:d8c3:c002:7b9f%21 ：128位，8个无符号整数 公网（互联网） - 私网（局域网） ABCD类地址 192.168.xx.xx，专门给组织内部使用的 端口端口表示计算机上的一个程序的进程 不同的进程有不同的端口号，用来区分软件 被规定 0 ~65535 TCP，UDP：65535*2，单个协议下，端口号不能冲突 端口分类 共有端口 0~1023 HTTP：80 HTTPS：443 FTP：21 Telent：23 程序注册端口： 1024~49151，分配用户或者程序 Tomcat：8080 MySQL： 3306 Oracle： 1521 动态、私有： 49152~65535 通信协议协议：约定，就好比我们现在说的时普通话 网络通信协议：速率、传输码率，代码结构，传输控制。。。 问题：非常的复杂？ 大事化小：分层！ TCP、IP协议簇 实际上是一组协议 重要： TCP：用户传输协议 UDP：用户数据报协议 出名的协议： TCP IP：网络互连协议 TCP UDP对比 TCP：打电话 连接，稳定 ==三次握手，四次挥手== ```最少需要三次，保证稳定连接！A：你瞅啥？B：瞅你咋地？A：干一场！ A：我要走了B：你真的要走了吗？B：你真的真的要走了吗？A：我真的要走了 public class TcpClientDemo1 {public static void main(String[] args) { }} public class TcpServerDemo1 {public static void main(String[] args) { }} public class TcpServerDemo2 {public static void main(String[] args) throws IOException { }} public class TcpClientDemo2 {public static void main(String[] args) throws Exception { }} public class UDPClientDemo1 {public static void main(String[] args) throws IOException { }} public class UDPServerDemo1 {public static void main(String[] args) throws IOException { }} public class UdpSenderDemo2 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(8888); } public class UdpReceiveDemo2 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(6666); } public class TalkSend implements Runnable{ DatagramSocket socket = null; BufferedReader reader = null; private int fromPort; private String toIP; private int toPort; } public class TalkReceive implements Runnable{ DatagramSocket socket; private int port; private String msgFrom; public TalkReceive(int port,String msgFrom) { this.port = port; this.msgFrom = msgFrom; try { socket = new DatagramSocket(port); } catch (SocketException e) { e.printStackTrace(); } } } public class TalkTeacher { public static void main(String[] args) { //开启两个线程 new Thread(new TalkSend(5555,”localhost”,8888)).start(); new Thread(new TalkReceive(9999,”学生”)).start(); }} public class TalkStudent { public static void main(String[] args) { //开启两个线程 new Thread(new TalkSend(7777,”localhost”,9999)).start(); new Thread(new TalkReceive(8888,”老师”)).start(); }} public class UrlDown { public static void main(String[] args) throws IOException { //1.下载地址 URL url = new URL(“;); } "},{"title":"数据结构与算法","date":"2022-01-14T11:44:44.000Z","url":"/2022/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/","categories":[["undefined",""]],"content":"数据结构数组字符串队列栈链表集合哈希表树二叉树多叉树字典树算法排序双指针查找分治动态规划动态规划常常适用于有重叠子问题和最优子结构性质的问题，并且记录所有子问题的结果，因此动态规划方法所耗时间往往远少于朴素解法。 动态规划有自底向上和自顶向下两种解决问题的方式。自顶向下即记忆化递归，自底向上就是递推。 使用动态规划解决的问题有个明显的特点，一旦一个子问题的求解得到结果，以后的计算过程就不会修改它，这样的特点叫做无后效性，求解问题的过程形成了一张有向无环图。动态规划只解决每个子问题一次，具有天然剪枝的功能，从而减少计算量。 递归回溯贪心位运算DFS与BFS 图"},{"title":"mysql","date":"2022-01-14T11:38:12.454Z","url":"/2022/01/14/mysql/","categories":[["undefined",""]],"content":"初始Mysql 什么是数据库概念：​ 数据仓库（软件），安装在操作系统（window，Linux，mac…）之上。可以存储大量数据。500万 作用：​ 数据库是存储数据，管理数据， 为什么学习数据库 趋势，岗位需求 大数据时代，得数据者得天下 被迫需求：存数据 数据库是所有软件体系中最核心得存在 数据库分类关系型数据库：（SQL） MySQL、Oracle、SQL server、DB2、SQLlite… 通过表与表之间、行与行之间的关系进行数据的存储。 非关系型数据库：(NoSQL)Not Only SQL redis、MongDB 对象存储，通过对象自身的属性来决定。 连接数据库命令行连接： 数据库XXX语言DDL 定义 DML 操作 DQL 查询 DCL 控制 MySQL属性和操作1.常用密令 mysql的关键字不区分字母的大小写 2.操作数据库。数据库名：demo 创建数据库 删除数据库 使用数据库 查看数据库 3.数据库列的类型 mysql数据类型长度问题总结： 数值 tinyint：十分小的数据，1个字节。 smallint：较小的数据，2个字节。 mediumint：中等大小的数据，3个字节。 int：标准的证书，4个字节。（常用的变量） bigint：较大的数据，8个字节。 float：浮点数，4个字节。 double：浮点数，8个字节。 decimal：字符串形式的浮点数。涉及到金钱计算时，一般使用decimal 字符串 char：字符串固定大小的，0~255字节。 varchar：可变字符串，0~65535字节。（常用的变量） tinytext：微型文本，2^8-1字节。 text：文本串，2^16-1字节。 时间 date：YYYY-MM-DD，日期格式。 time：HH：mm：ss，时间格式。 datatime：YYYY-MM-DD HH：mm：ss，最常用的时间格式。 timestamp：时间戳，1970.1.1道现在的毫秒数。 year：年份表示。 null 没有值，未知。 注意：不要使用NULL进行运算，没有意义，计算结果为NULL 4.数据库的字段属性 Unsigned 无符号的整数。 声明了该列不能为负数。 zerofill 0填充 不足的位数使用0填充。int(5)类型存储数字9会变成00009 自增 通常理解为自增，自动在上一条记录的基础上+1（默认）。 通常用来设计唯一的主键，必须是整数类型。 可以自定义设计主键自增的起始值和步长。 非空 勾选上not null，如果不给字段赋值，则会报错。 默认 设置默认的值。 sex，默认值为男，如果不指定该列的值，则会有默认的值。 拓展： 5.创建数据库 注意点，使用英文()，表的名称和字段尽量使用``括起来。 AUTO_INCREMENT 自增。 字符串使用单引号括起来。 所有的语句后面加，（英文的），最后一个不用加。 PRIMARY KEY主键，一般一个表只有一个唯一的主键。 格式： 6.数据表类型 关于数据库引擎 InnoDB：5.5版本以后默认使用。 MyISam：早些年使用的默认。 MyISam InnoDB 事务支持 不支持 支持 数据行锁定 不支持 支持 外键约束 不支持 支持 全文索引 支持 不支持 表空间大小 较小 较大，约为myisam两倍 在物理空间存在的位置所有的数据库文件都存在data目录下，一个文件夹就对应一个数据库，本质还是文件的存储。 MySQL引擎在物理文件上的区别。 InnoDB在数据库表中只有一个*.frm文件，以及上级目录下的ibdata1文件。 MYISAM对应文件： *.frm：表结构的定义文件 *.MYD：数据文件（data） *.MYI：索引文件（index） 7.设置数据库表的字符集编码 MySQL默认字符编码的设置： 不设置的话，会是mysql默认的字符集编码（不支持中文） MySQL的默认编码是Latin1，不支持中文。 在my.ini中配置默认的编码 8.修改数据表字段 *change一般用来字段重命名，modify不用来字段重命名，只能修改字段类型和约束* 9.删除数据表字段 MySQL数据管理外键（了解即可）方式一：在创建表的时候，增加约束（麻烦，比较复杂） 删除有外键关系的表的时候，必须要先删除引用别人的表（从表），再删除被引用的表（主表） 方式二：创建表成功后，添加外键约束 以上操作都是物理外键，数据库级别的外键，不建议使用！（避免数据库过多造成困扰） ==最佳实践== 数据库就是单纯的表，只用来存数据，只有行（数据）和列（字段） 我们想使用多张表的数据，想使用外键（程序去实现） DML语言（全部记住）数据库意义：数据存储，数据管理 DML语言：数据操作语言 insert update delete 添加 注意事项： 字段和字段之间使用 英文逗号 隔开 字段可以省略，但是后面的值必须要一一对应，不能少 可以同时插入多条数据，VALUES后面的值，需要使用,隔开即可 (),() 修改 条件：where子句 操作符： =、&lt;&gt;或!=、&lt;、&gt;、&lt;=、&gt;=、BETWEEN…and… 、AND、OR 语法：update 表名 set column_name=value,[column_name=value,…] where [条件] 注意： colnum_name 是数据库的列，尽量带上`` 条件，筛选的条件，如果没有指定，则会修改所有的列 value，是一个具体的值，也可以是一个变量 多个设置的属性之间，使用英文逗号隔开 删除delete命令： 语法：delete from 表名 [where 条件] ```– 不指定条件的情况下，会删除所有的记录：delete from 表名delete from student where id=1; 清空整张表truncate table student; 测试delete与TRUNCATE区别CREATE TABLE test( id INT(4) NOT NULL AUTO_INCREMENT, coll VARCHAR(20) NOT NULL, PRIMARY KEY(id))ENGINE=INNODB DEFAULT CHARSET=utf8mb4 INSERT INTO test(coll) VALUES(‘1’),(‘2’),(‘3’) DELETE FROM test – 不会影响自增 TRUNCATE TABLE test – 自增会归零 "},{"title":"java基础语法","date":"2022-01-14T11:24:01.000Z","url":"/2022/01/14/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","categories":[["undefined",""]],"content":"基础快捷键 注释 标识符和关键字关键字： abstract assert boolean break byte case catch char class const continue default do double else enum extends final finally float for goto if implements import instanceof int interface long native new package private protected public return strictfp short static super switch synchronized this throw throws transient try void volatile while 数据类型强类型语言：要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用 java的数据类型分为两大类： 基本数据类型：整数类型、浮点类型、字符类型、boolean类型 引用数据类型：类、接口、数组 类型转换 变量、常量、作用域变量： 常量：用final来修饰 运算符 算数运算符：+，_，*，/，%，++，– 赋值运算符：= 关系运算符：&gt;，&lt;，&gt;=，&lt;=，==，!=，instanceof（判断是否是一个类的实例） 逻辑运算符：&amp;&amp;，||，！ 位运算符：&amp;，|，~，&gt;&gt;，&lt;&lt;，&gt;&gt;&gt; 条件运算符：？： 扩展赋值运算符：+=，-=，*=，/= 包机制包语句的语法格式为： 一般利用公司域名倒置作为包名 导包用import语句 javaDoc生成文档jaovDoc命令用来生成自己的API文档 参数信息 @author 作者名 @version 版本号 @since 指明需要最早使用的jdk版本 @param 参数 @return 返回值情况 @throws 异常抛光情况 命令行生成文档： idea生成JavaDoc文档： 流程控制用户交互Scannernext(): 以空格为结束符 一定要读取到有效字符后才可以结束输入 next()不能得到带有空格的字符串 nextLine(): 以Enter为结束符 可以获得空白 判断输入的是否是整数：scanner.has.NextInt() 判断输入的是否是小数：scanner.has.NextFloat() 顺序结构JAVA的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行 它是任何一个算法都离不开的一种基本算法结构 选择结构 循环结构 break &amp; continue break在任何循环语句的主题部分，均可用break控制循环的流程。break用于强制退出循环 continue用于终止某次循环过程 方法Java方法是语句的集合，它们在一起执行一个功能 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用 设计方法的原则：最好保持方法的原子行，就是一个方法只完成1个功能，这样利于我们后期的扩展 定义及调用 方法重载重载就是在一个类中，有相同的函数名称，但形参不同的函数 规则： 方法名称必须相同 参数列表必须不同（个数、类型、参数排列顺序等） 方法的返回类型可以相同也可以不相同 仅仅返回类型不同不足以成为方法的重载 理论：方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法， 如果匹配失败，则编译器保持。 可变参数JDK1.5开始，jav支持传递同类型的可变参数给一个方法 在方法声明中，在指定参数类型后加一个省略号(…) 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。 递归递归：自己调用自己 递归结构： 递归头：什么时候不调用自身方法。如果没有头，将陷入死循环 递归体：什么时候调用自身方法 数组 数组是相同类型数据的有序集合 数组描述的是相同类型的若干数据，按照一定的先后次序排列组合而成 每一个数据称作一个数组元素，用下标来访问 数组声明创建 数组使用 普通的For循环 For-Each循环 数组作方法入参 数组作返回值 多维数组多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组 Arrays类数组的工具类java.util.Arrays 给数组赋值：fill 对数组排序：sort 比较数组：equals 查找数组元素：binarySearch 稀疏数组当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组 处理方式： 记录数组一共有几行几列，有多少个不同的值 把具有不同值的元素和行列及值记录在一个小规模的数组中 面向对象面向对象思想： 物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后才对某个分类下的细节进行面向过程的思索 面向对象适合处理复杂的问题，适合处理需要多人协作的问题 面向对象编程（Object-Oriented Programming,OOP） 面向对象编程的本质：以类的方式组织代码，以对象的组织（封装）数据 抽象 三大特性： 封装 继承 多态 构造器 和类名相同 没有返回值 作用： new本质在调用构造方法 初始化对象的值 注意点： 定义有参构造后，如果想使用无参构造，显示的定义一个无参的构造 封装 我们程序设计要追求”高内聚，低耦合“。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合就是仅暴露少量的方法给外部使用 封装（数据的隐藏）：通常应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问 属性私有，get/set 好处： 提高程序的安全性，保护数据 隐藏代码的实现细节 统一接口 系统可维护性增加 继承 继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模 extends的意思是”扩展“。子类是父类的扩展 JAVA中类只有单继承，没有多继承 继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖。组合、聚合等 继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示 在JAVA中，所有的类都默认直接或间接继承Object 私有的东西无法被继承 supersuper注意点 super调用父类的构造方法，必须在构造方法的第一个 super必须只能出现在子类的方法或者构造方法中 super和this不能同时调用构造方法 Vs this： 代表的对象不同 this：本身调用者这个对象 super：代表父类对象的应用 前提 this：没有继承也可以使用 super：只能在继承条件才可以使用 构造方法 this（）：本来的构造 super（）：父类的构造 方法重写重写都是方法的重写，和属性无关 需要有继承关系，子类重写父类的方法 子类的方法和子类必须一致，方法体不同 方法名必须相同 参数列表必须相同 修饰符：范围可以扩大不能缩小 public&gt;Protect&gt;Default&gt;private 抛出的异常：范围，可以被缩小，不能扩大：ClassNotFoundException –&gt; Exception(大) 为什么需要重写： 父类的功能，子类不一定需要，或不一定满足 多态 多态即同一方法可以根据发送对象的不同而采用多种不同的行为方式 一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多（父类，有关系的类） 多态存在的条件 有继承关系 子类重写父类方法 父类引用指向子类对象 注意：多态是方法的多态，属性没有多态性 把子类转换为父类，向上转型 把父类转换为子类，向下转型 强制转换 方便方法的调用，减少重复的代码 简洁 instanceof 判断一个对象是什么类型 static抽象类abstract，抽象方法，只要方法名字，没有方法实现 不能new这个抽象类，只能靠子类去实现它；约束！ 抽象类中可以写普通的方法 抽象方法必须在抽象类中 抽象的抽象：约束 接口 普通类：只有具体实现 抽象类：具体实现和规范（抽象方法）都有 接口：只有规范 OO的精髓，是对对象的抽象，最能体现这一点的就是接口。 声明接口的关键字是interface 实现接口用implements 接口不能被实例化，接口中没有构造方法 内部类在一个类的内部定义一个类 成员内部类 静态内部类 局部内部类 匿名内部类 异常 异常（Exception）指程序运行中出现的不期而至的各种状况，如：文件找不到，网络连接错误，非法参数等 异常发生在程序运行期间，它影响了正常的程序执行流程 检查性移仓：最具代表的检查性异常是用户错误或问题引起的异常 运行时异常：是可能被程序员避免的异常 错误：错误不是异常，而是脱离程序员控制的问题 异常体系结构 java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类 在Java API中已经定义了许多异常类，常分为两大类，错误Error和异常Exception Error Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关 Java虚拟机运行错误，当JVM不再有继续执行操作所需的内存资源是，将出现OutOfMemoryError。这些异常发生时，JVM一般会选择线程终止 还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError），连接错误（LinkageError）。 Exception 在Exception分支中有一个重要的子类RuntimeException（运行时异常） ArrayIndexOutOfBoundsException（数组小标越界） NullPointerException（空指针异常） ArithmeticException（算术异常） MissingResourceException（丢失资源） ClassNotFoundException（找不到类） 这些异常一般时由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生 Error和Exception的区别：Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，JVM一般会选择终止线程。Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。 捕获、抛出异常 抛出异常 捕获异常 异常处理五个关键字：try、catch、finally、throw、throws 自定义异常 处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理 在多重catch快后面，可以加一个catch(Exception)来处理可能会被遗漏的异常 对应不确定的代码，也可以加上try-catch，处理潜在的异常 尽量去处理异常，切忌只是简单地调用PrintStackTrace（）去打印输出 具体如何处理异常，要根据不同的业务需求和异常类型去决定 尽量添加finally语句块去释放占用的资源 常用类 包装类 针对八种基本数据类型相应的引用类型—-包装类 有了类的特点，就可以调用类中的方法 基本数据类型 包装类 父类 boolean Boolean Object char Character Object byte Byte Number short Short Number int Integer Number long Long Number float Float Number double Double Number 包装类与String互转 String 字符串不可变，他们的值在创建后不能被更改 String的值不可变，但是它们可以被共享 构造方法： 字符串比较使用==做比较 基本类型：比较的是数据值是否相同 引用类型：比较的是地址值是否相同 字符串是对象，它比较内容是否相同，是用equals()比较多 字符串遍历 常用方法indexOf()：返回指定字符的索引。charAt()：返回指定索引处的字符。 toCharArray()：把字符串转变成字符数组 replace()：字符串替换。trim()：去除字符串两端空白。split()：分割字符串，返回一个分割后的字符串数组。getBytes()：返回字符串的 byte 类型数组。length()：返回字符串长度。toLowerCase()：将字符串转成小写字母。toUpperCase()：将字符串转成大写字符。substring()：截取字符串。equals()：字符串比较。 StringBuffer可变长字符串，JDK1.0提供，运行效率慢、线程安全 StringBuilder可变长字符串，JDK5.0提供，运行效率快、线程不安全 如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，即耗时又浪费内存空间。 StringBuilder是一个可变的字符串类，可以把它看成是一个容器 构造方法 添加和反转 StringBuilder和String相互转换 StringBuilder –&gt; String：通过toString() String –&gt; tringBuilder：通过构造方法 Date构造方法 常用方法 SimpleDateFormatSimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期 日期和时间格式由日期和时间模式字符串指定，其中，从’A’到’Z’以及从’a’到’z’引号的字母被解释为表示日期或时间字符串的组件的模式字母 常用的模式字母及对应关系如下： y 年 M 月 d 日 H 时 m 秒 s 分 方法 CalendarCalendar为某一时刻和一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法 集合集合类的特点：提供一种存储空间可变的存储模型，存储的数据容量可以发生改变 ArrayListArrayList: 可调整大小的数组实现 ：是一种特殊的数据类型，泛型 构造和添加方法 常用方法public boolean remove(Object o);删除指定的元素，返回删除是否成功 public E remove(int index);删除指定索引处的元素，返回被删除的元素 public E set(int index,E element);修改指定索引处的元素，返回被修该的元素 public E get(int index);返回指定索引处的元素 public int size();返回集合中的元素的个数 Collection集合概述： 是单例集合的顶层接口，它表示一组对象，这些对象也被称为Collection的元素 JDK不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List）实现 创建Collection集合的对象 多态的方式 具体的实现类ArrayList 构造方法 常用方法 boolean add(E e) //添加元素 boolean remove(Object o) //从该集合中删除指定元素 void clear() //清空集合中的元素 boolean contains(Object o) //判断集合中是否存在指定的元素 boolean isEmpty() //判断集合是否为空 int size() //集合的长度，也就是集合中元素的个数 集合的遍历Iterator：迭代器，集合的专用遍历方式 Iterator iterator(); 返回此集合中元素的迭代器，通过集合的iterator()方法得到 迭代器是通过集合的iterator()方法得到的，所以我们说它是依赖于集合而存在的 Iterator中的常用方法： E next(); 返回迭代中的下一个元素 boolean hasNext(); 如果迭代具有更多元素，则返回true ListList集合概述 有序集合（也称为序列 ）。 该界面的用户可以精确控制列表中每个元素的插入位置。 用户可以通过整数索引（列表中的位置）访问元素，并搜索列表中的元素。 与Set集合不同，列表通常允许重复的元素。 List集合特点 有序：存储和取出的元素顺序一致 可重复：存储的元素可以重复 构造方法 常用方法 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 并发修改异常 并发修改异常（ConcurrentModificationException） 原因：迭代器遍历过程中，通过集合对象修改了集合中元素的长度，导致了迭代器获取元素中判断预期修改值和实际修改值不一致 解决方案：用for循环遍历，然后用集合对象做对应的操作即可 ListIteratorListItertor：列表迭代器 通过List集合的listIterator()方法得到，所以说它是List集合特意的迭代器 用于允许程序员沿任一方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置 ListIterator中的常用方法： E next()：返回迭代中的下一个元素 boolean hasNext()：如果迭代具有更多元素，则返回true E previous()：返回列表中的上一元素 boolean hasPrevious()：如果此列表迭代器在相反方向遍历列表时具有更多元素，则返回true void add(E e)：将指定的元素插入列表 增强for循环增强for：简化数组和Collection集合的遍历 实现Iterable接口的类允许其对象成为增强型语句的目标 它时JDK5之后出现的，其内部原理是一个Iterrator迭代器 增强for的格式 格式： 范例 List集合子类List集合常用子类：ArrayList、LinkedList ArrayList：底层数据结构是数组，查询快，增删慢 LinkedList：底层数据结构是链表，查询慢，增删快 LinkedList集合的特有功能 public void addFirst(E e); 在该列表开头插入指定的元素 public void addLast(E e); 将指定的元素追加到此列表的末尾 public E getFirst(); 返回此列表中的第一个元素 public E getLast(); 返回此列表中的最后一个元素 public E removeFirst(); 从此列表中欧给删除并返回第一个元素 public E removeLast(); 从此列表中欧给删除并返回最后一个元素 Setset集合特点 不包含重复元素的集合 没有带索引的方法，所以不能使用普通for循环遍历 哈希值哈希值：是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值 Object类中有一个方法可以获取对象的哈希值 Public int hashCode(); 返回对象的哈希码值 对象的哈希值特点 同一个对象多次调用hashCode()方法返回的哈希值是相同的 默认情况下，不同对象的哈希值是不同的，而重写hasCode()方法，可以使其相同 HashSet集合特点 底层数据结构使哈希表 对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致 没有带索引的方法，所以不能使用普通for循环遍历 由于是Set集合，所以不包含重复元素 LinkedHashSetLinkedHashSet集合概述和特点 哈希表和链表实现的Set接口，具有可预测的迭代次序 由链表保证元素有序，也就是说元素的存储和取出顺序一致 由哈希表保证元素唯一，也就是说没有重复的元素 TreeSetTreeSet集合特点 元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方法取决于构造方法 TreeSet(); 根据其元素的自然排序进行排序 TreeSet(Comparator comparator); 根据指定的比较器进行排序 没有带索引的方法，所以不能使用普通的for循环遍历 由于是Set集合，所以不包含重复元素的集合 Comparable 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 Comparator 泛型泛型：是JDK5中引入的特性，它提供了编译时类型安全检测机制，该极致允许在编译时检测到非法的类型 它的本质时参数化类型，也就是说所操作的数据类型被指定为一个参数 泛型定义格式： &lt;类型&gt;：指定一种类型的格式。这里的类型可以看成是形参 &lt;类型1，类型2…&gt;：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成事形参 将来具体调用时给定的类型可以看成事实参，并且实参的类型只能是引用数据类型 泛型的好处： 把运行时期的问题提前到了编译期间 避免了强制类型转换 泛型类泛型类的定义格式： 格式：修饰符 class 类名 &lt;类型&gt;{} 范例：public class Generic{} 此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型 泛型方法泛型方法的定义格式： 格式：修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名){} 范例：public void show(T t){} 泛型接口泛型接口的定义格式： 格式：修饰符 interface 接口名&lt;类型&gt;{} 范例：public interface Generic{} 类型通配符为了表示各种泛型List的父类，可以使用类型通配符 类型通配符：&lt;?&gt; List&lt;?&gt;：表示元素类型未知的List，它的元素可以匹配任何的类型 这种带通配符的List仅代表它是各种泛型List的父类，并不能把元素添加到其中 如果说我们不希望List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限 类型通配符上限：&lt;? extends 类型&gt; List&lt;? extends Number&gt;：它表示的类型是Number或者其子类型 除了可以指定类型通配符的上限，我们也可以指定其下限 类型通配符下限：&lt;? super 类型&gt; List&lt;? super Number&gt;：它表示的类型是Number或者其父类型 可变参数可变参数又称参数个数可变，用作方法的形参出现，那么方法的参数个数就是可变的了 格式：修饰符 返回值类型 方法名(数据类型…变量名){} 范例：public static int sum(int…a){} 注意事项： 这里的变量其实是一个数组 如果一个方法有多个参数，包含可变参数，可变参数要放在最后 可变参数的使用Arrays工具类中有一个静态方法： public static List asList(T…a); 返回由指定数组支持的固定大小的列表 返回的集合不能做增删操作，可以做修改操作 List接口中有一个静态方法： public static List of(E…elements); 返回包含任意数量元素的不可变列表 返回的集合不能做增删改操作 Set接口中有一个静态方法： public static Set of(E…elements); 返回一个包含任意数量元素的不可变集合 返回的集合不能做增删操作，没有修改的方法 MapMap集合概述： Interface Map&lt;K,V&gt; K：健的类型；V：值的类型 将健映射到值的对象；不能包含重复的健；每个健可以映射到最多一个值 举例：学生的学号和姓名 创建Map集合的对象： 多态的方式 具体的实现类HashMap 常用方法 V put(K key,V value); 添加元素 V remove(Object key); 根据健删除键值对元素 void clear(); 移除所有的键值对元素 boolean containsKey(Object key); 判断集合中是否包含指定的健 boolean containsValue(Object value); 判断集合中是否包含指定的值 boolean isEmpty(); 判断集合是否为空 int size(); 集合长度，也就是集合中键值对的个数 Map集合的获取功能 V get(Object key); 根据健获取值 Set keySet(); 获取所有健的集合 Collection values(); 获取所有值的集合 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(); 获取所有键值对对象的集合 HashMap案例ArrayList集合存储HashMap元素并遍历: HashMap集合存储ArrayList元素并遍历: 统计字符串中每个字符出现的次数： CollctionsCollections类是针对集合操作的工具类 常用方法 public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List list); 将指定的列表按升序排序 public static void reverse(List&lt;?&gt; list); 反转指定列表中元素的顺序 public static void shuffle(List&lt;?&gt; list); 使用默认的随机源随机排序指定列表 案例ArrayList存储学生对象并排序 模拟斗地主： 模拟斗地主升级版： 常用APIMathmath包含执行基本数字运算的方法 静态类，通过类名可以直接调用 工具类的设计思想： 构造方法用private修饰 成员用public static修饰 常用方法 方法名 说明 public static int abs(int a) 返回参数的绝对值 public static double ceil(double a) 返回大于或等于参数的最小double值，等于一个整数 public static double floor(double a) 返回小于或等于参数的最大double值，等于一个整数 public static int round(float a) 按照四舍五入返回最接近参数的int public static int max(int a,int b) 返回两个int值中的较大值 public static int min(int a,int b) 返回两个int值中的较小值 public static double pow(double a,double b) 返回a的b次幂的值 public static double random() 返回值为double的正值，[0.0,1.0) SystemSystem包含几个有用的类字段和方法，它不能被实例化 常用方法 方法名 说明 public static void exit(int status) 终止当前运行的java虚拟机，非零表示异常终止 public static long currentTimeMillis() 返回当前的时间（以毫秒为单位） ObjectObject是类层次结构的根，每个类都可以将Object作为超类，所有类都直接或间接的继承自该类 构造方法：public Object(); 常用方法 public String toString();//返回对象的字符串表示形式，建议所有子类重写此方法，自动生成即可 public boolean equals(Object obj);//比较对象是否相等。默认比较地址，重写可以比较内容，自动生成 ArraysArrays类包含用于操作数组的各种方法 常用方法 public static String toString(int[] a);返回指定数组的内容的字符串表示形式 public static void sort(int[] a);按照数字顺序排列指定的数组 IO IO流概述： IO：输入/输出(Input/Output) 流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输 IO流就是用来处理设备间数据传输问题的，如：文件复制、文件上传、文件下载 分类： 按照数据的流向： 输入流：读数据 输出流：写数据 按照数据类型： 字节流：字节输入流、字节输出流 字符流：字符输入流、字符输出流 如果数据通过记事本软件打开，可以读懂，用字符流 否则用字节流，一般默认字节流 FileFile：它是文件和目录路径名的抽象表示 文件和目录是可以通过File封装成对象的 对应File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的 构造方法 File(String pathname); 通过将给定的路径名字符串转换为抽象路径名来创建新的File实例 File(String parent,String child); 从父路径名字符串和子路径名字符串创建新的File实例 File(File parent,String child); 从父抽象路径名和子路径名字符串创建新的File实例 创建方法 public boolean createNewFile(); 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 public boolean mkdir(); 创建由此抽象路径名命名的目录 public boolean mkdirs(); 创建由此抽象路径名命名的目录，包括任何必须但不存在的父目录 判断和获取功能 public boolean isDirectory(); 测试此抽象路径名表示的File是否为目录 public boolean isFile(); 测试此抽象路径名表示的File是否为文件 public boolean exists(); 测试此抽象路径名表示的File是否为存在 public String getAbsolutePath(); 返回此抽象路径名的绝对路径名字符串 public String getPath(); 将此抽象路径名转换为路径名字符串 public String getName(); 返回此抽象路径名表示的文件或目录的名称 public String[] list(); 返回此抽象路径名表示的目录中的文件和目录的名称字符串数组 public File[] listFiles(); 返回此抽象路径名表示的目录中的文件和目录的File对象数组 删除功能 public boolean delete(); 删除由此抽象路径名表示的文件或目录 注意事项 如果一个目录中有内容（目录，文件），不能直接删除。应该先删除目录中的内容，最后才能删除目录 案例遍历目录： 字节流字节流抽象基类： InputStream：这个抽象类是表示字节输入流的所有类的超类 OutputStream：这个抽象类是表示字节输出流的所有类的超类 子类名特点：子类名称都是以其父类名作为子类名的后缀 FileOutputStreamFileOutputStream：文件输出流用于将数据写入File FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 使用字节输出流写数据的步骤： 创建字节输出流对象（调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件） 调用字节输出流对象的写数据方法 释放资源 写数据方法 void write(int b)：将指定的字节写入此文件输出流，一次写一个字节数据 void write(byte[] b)：将b.length字节从指定的字节数组写入此文件输出流，一次写一个字节数组数据 void write(byte[] b,int off,int len)：将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流，一次写一个字节数组的部分数据 换行和追加写入换行： 写完数据后，加换行符 windows：\\r\\n linux：\\n mac：\\r 追加写入： public FielOutputStream(String name,boolean append) 创建文件输出流以指定的名称写入文件。如果第二个参数为true，则字节将写入文件的末尾而不是开头 异常 FileInputStreamFileInputStream：从文件系统中的文件获取输入字节 FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream，该文件由文件系统中的路径名name命名 使用字节输入流写数据的步骤： 创建字节输入流对象 调用字节输入流对象的读数据方法 释放资源 读字节数组数据 案例字节流复制文本文件： 复制图片 复制视频 字节缓冲流字节缓冲流： BufferedOutputStream：该类实现缓冲输出流。通过设置这样的输出流，应用程序可以想底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用 BufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组。当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节 构造方法： 字节缓冲输出流：BufferedOutputStream(OutputSteam out) 字节缓冲输入流：BufferedInputStream(InputStream in) 字节缓冲流仅仅提供缓冲区，而真正的读写数据还得依靠基本得字节流对象进行操作 字符流由于字节流操作中文不是特别方便，所有java就提供了字符流 字符流 = 字节流 + 编码表 用字节流复制文本文件时，最终底层操作会自动进行字节拼接成中文 汉字在存储时，无论选择哪种编码存储，第一个字节都是负数 编码表 Ascll GBK UTF-8 编码： byte[] getBytes(),使用平台的默认字符集将String编码为一系列字节，将结果存储到新的字节数组中 byte[] getBytes(String charsetName)，使用指定得字符集将String编码为一系列字节，将结果存储到新的字节数组中 解码： String(byte[] bytes)，通过使用平台的默认字符集解码指定的字节数组来构造新的String String(byte[] bytes, String charsetName)，通过指定的字符集解码指定的字节数组来构造新的String 字符流的编码解码字符流抽象基类： Reader：字符输入流的抽象类 Writer：字符输出流的抽象类 字符流中和编码解码问题相关的两个类： InputStreamReader OutputStreamWriter 写数据方法 void write(int c)： 写一个字符 void write(char[] cbuf)： 写入一个字符数组 void write(char[] cbuf,int off,int len)： 写入字符数组的一部分 void write(String str)： 写一个字符串 void write(String str,int off,int len)： 写一个字符串的一部分 读数据方法 int read()： 一次读一个字符数据 int read(char[] cbuf)： 一次读一个字符数组数据 案例复制java文件 复制java文件（改进版） 为了简化书写，转换流提供了对应的子类 FileReader：用于读取字符文件的便捷类 FileReader(String fileName) FileWriter：用于写入字符文件的便捷类 FileWriter(String fileName) 复制java文件（字符缓冲流改进版） 字符缓冲流 BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途 BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。默认值足够大，可用于大多数用途 特有功能 BufferedWriter: void newLine()：写一行行分隔符，行分割符字符串由系统属性定义 BufferedReader： public String readLine()：读一行文字，结果包含行的的内容的字符串，不包括任何行终止字符，如果流的结尾已经到达，则为null 案例集合到文件： 文件到集合： 复制单级文件夹 复制多级文件夹 特殊操作流标准输入输出流System类中有两个静态的成员变量： public static final InputStream in：标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的另一个输入源 public static final PrintStream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输入目标 自己实现键盘录入数据 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); Java提供了一个类实现键盘录入 Scanner sc = new Scanner(System.in); 输出语句的本质：是一个标准的输出流 PrintStream ps = System.out; PrintStream类有的方法，System.out都可以使用 打印流打印流分类： 字节打印流：PrintStream 字符打印流：PrintWriter 打印流的特点： 只负责输出数据，不负责读取数据 有自己的特有方法 字节打印流： PrintStream(String fileName)：使用指定的文件名创建新的打印流 使用继承父类的方法（write()）写数据，查看时会转码；使用自己特有的方法（print（））写数据，查看的数据原样输出 字符打印流： PrintWriter(String fileName) 使用指定的文件名创建一个新的PrintWriter，而不需要自动执行刷新 PrintWriter(Writer out,boolean autoFlush) 创建一个新的PrintWriter，out：字符输出流；autoFlush：若为真，则Println，printf，format方法将刷新输出缓冲区 对象序列化流对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象 对象序列化流：ObjectOutputStream 对象反序列化流对象反序列化流：ObjectInputStream 多线程 线程简介 程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念 进程是执行程序的一次执行过程，是一个动态的概念。是系统资源分配的单位 一个进程中可以包含若干个线程。线程是CPU调度和执行的单位 核心概念： 线程就是独立的执行路径 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程 main()称之为主线程，为系统的入口，用于执行整个程序 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为的干预的 堆同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制 线程会带来额外的开销，如cpu调度时间，并发控制开销 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致 线程实现（重点）创建线程的三种方式： 继承Thread类 子类继承Thread类具有多线程能力 启动线程：子类对象.start() 不建议使用：避免OOP单继承局限性 实现Runnable接口 实现接口Runnable具有多线程能力 启动线程：传入目标对象+Thread对象.start() 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 实现Callable接口 Thread 自定义线程类继承Thread类 重写run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程 案例：下载网图 Runnable 自定义类实现Runnable接口 实现run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程 案例并发： 龟兔赛跑： Callable 实现Callable接口，需要返回值类型 重写call方法，需要抛出异常 创建目标对象 创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(3); 提交执行：Future r1 = ser.submit(t1); 获取结果：boolean rs1 = r1.get(); 关闭服务：ser.shutdownNow(); Lambda 避免匿名内部类定义过多 其实质属于函数式编程得概念 理解Functional Interface（函数式接口）是学习Java8 lambda表达式得关键所在 函数式接口得定义： 任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口 对于函数式接口，我们可以通过lambda表达式来创建该接口的对象 总结： lambda表达式只能在有一行代码的情况下才能简化成为一行，如果有多好，那么就用代码块包裹 前提是接口为函数式接口 多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号 静态代理模式 真实对象和代理对象都要实现同一个接口 代理对象要代理真实角色 好处： 代理对象可以做很多真实对象做不了得事情 真实对象专注做自己得事情 线程状态 线程方法 setPriority(int newPriority) 更改线程优先级 static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程休眠 void join() 等待该线程终止 static void yield() 暂停当前正在执行的线程对象，并执行其他线程 void interrupt() 中断线程，别用这个方式 boolean isAlive() 测试线程是否处于活动状态 线程停止： 建议线程正常停止—&gt;利用次数，不建议死循环 建议使用标志位–&gt;设置一个标志位 不要使用stop或者destroy等过时或JDK不建议使用的方法 线程休眠 sleep(时间)指定当前线程阻塞的毫秒数 sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延时，倒计时等 每一个对象都有一个锁，sleep不会释放锁 线程礼让 礼让线程，让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让cpu重新调度，礼让不一定成功！看CPU心情 线程强制执行 Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞 可以想象成插队 线程状态观测Thread.State：线程状态。线程可以处于以下状态之一 NEW RUNNABLE BLOCKED WAITING TIMED_WAITING TERMINATED 线程优先级 Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度那个线程来执行 现成的优先级用数字表示，范围从1~10 Thread.MIN_PRIORITY = 1 Thread.MAX_PRIORITY = 10 Thread.NORM_PRIORITY = 5 使用一些方式改变或获取优先级 getPriority() setPriority(int x) 收获线程 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕 如，后台记录操作日志，监控内存，垃圾回收等待 线程同步（重点） 线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用 形成条件：队列+锁 由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题： 一个线程持有锁会导致其他所有需要此锁的线程挂起 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题 线程不安全的集合： 同步方法 由于我们可以通过private关键字来保证数据对象只能被方法访问，所以只需要针对方法提出一套机制，也就是synchronized关键字，它包括两种用法：synchronized方法和synchronzied块 同步方法：public synchronized void method(int args){} synchronzied方法控制对对象的访问，每个对象对应一把锁，每个synchronzied方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，知道该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行 缺陷：若将一个大的方法申明为synchronzied将会影响效率 弊端：方法里需要修改的内容才需要锁，锁的太多，浪费资源 同步块 同步块：synchronzied(Obj){} Obj称之为同步监视器 Obj可以是任何对象，但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class 同步监视器的执行过程 第一个线程访问，锁定同步监视器，执行其中代码 第二个线程访问，发现同步监视器被锁定，无法访问 第一个线程访问完毕，解锁同步监视器 第二个线程访问，发现同步监视器没有锁，然后锁定并访问 锁的对象是变化的量，需要增删改的对象 死锁 多个线程各自占有一些共有资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有“两个以上对象的锁”时，就可能发生死锁问题 产生死锁的四个必要条件： 互斥条件：一个资源每次只能被一个进程使用 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系 Lock（锁） 从JDK5.0开始，Java提供了更强大的线程同步机制—-通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象 ReentrantLock类实现了Lock，它拥有与synchronized相同的并分性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显示加锁、释放锁 synchronized与Lock对比 Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，除了作用域自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） 优先使用顺序： Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源）&gt;同步方法（在方法体之外） 线程通信 应用场景：生产者和消费者问题 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费 如果仓库中没有产品，则生产者将产品放入仓库，否则停止生成并等待，直到仓库中的产品被消费者取走为止 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止 这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件 在此问题中，仅有synchronized是不够的 synchronized可阻止并发更新同一个共享资源，实现了同步 synchronized不能用来实现不同线程之间的消息传递（通信） 方法 wait() 表示线程一直等待，知道其他线程通知，与sleep不同，会释放锁 wait(long timeout) 指定等待的毫秒数 notify() 唤醒一个处于等待状态的线程 notifyAll() 唤醒同一个对象上所有调用wait()方法的线程，优先级高的线程优先调度 均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常 管程法 生产者：负责生产数据的模块（可能是方法，对象，线程，进程） 消费者：负责处理数据的模块（可能是方法，对象，线程，进程） 缓冲区：消费者不能直接使用生产者的数据，他们之间有个“缓冲区” 生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据 信号灯法 线程池 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大 思路：提前创建好多个线程，放入线程池中，使用是直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具 好处： 提高响应时间（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理（…） corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后终止 JDK5.0起提供了线程池相关API：ExecutorService和Executors ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor void execute(Runnable command)： 执行任务/命令，没有返回值，一般用来执行Runnable Future submit(Callable task)： 执行任务，有返回值，一般用来执行Callable void shutdown()： 关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 总结总结线程的创建 注解和反射 注解什么是注解Annotation是从JDK5.0开始引入的新技术 Annotation的作用： 不是程序本身，可以对程序作出解释。（这一点和注释（comment）没什么区别） 可以被其他程序（如：编译器等）读取 Annotation的格式： 注解是以”@注释名”在代码中存在的，还可以添加一些参数值，如：@SuppressWarnings(value=:unchecked”) Annotation在那里使用？ 可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问 内置注解 @Override：定义在java.lang.Override中，此注释只适用于修斯方法，表示一个方法声明打算重写超类中的另一个方法声明 @Deprecated：定义在java.lang.Deprecated中，此注释可以用于修斯方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择 @SuppressWarnings：定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息 与前两个注释不同，需要添加一个参数才能正确使用 @SuppressWarnings(“all”) SuppressWarnings(“unchecked”) SuppressWarnings(value={“unchecked”,”deprecation”}) 等等…… 元注解 元注解的作用就是负责注解其他注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明 @Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期 SOURCE &lt; CLASS &lt; RUNTIME @Document：说明该注解将被包含在javadoc中 @Inherited：说明子类可以继承父类中的该注解 自定义注解使用 @interface自定义注解时，自动继承了java.lang.annotation.Annotation接口 @interface用来声明一个注解，格式：public @ interface 注解名 {定义内容} 其中的每一个方法实际上是声明了一个配置参数 方法的名称就是参数的名称 返回值类型就是参数的类型（返回值只能是基本类型，Class，String，Enum） 可以通过default来声明参数的默认值 如果只有一个参数成员，一般参数名为value 注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值 反射 动态语言：是一类在运行时可以改变其结果的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或时其他结果上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构 主要动态语言：Object-C、C#、JavaScript、PHP、Python等 静态语言：运行时结构不可变的语言。 如Java、C、C++ java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性 什么是反射 Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过镜子可以看到类的结构，姑称之为：反射 功能： 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时处理注解 在运行时调用任意一个对象的成员变量和方法 在运行时获取泛型信息 生成动态代理 。。。。。。 优点： 可以实现动态创建对象和编译，体现出很大的灵活性 缺点： 对性能有影响。 Class类在Object类中定义了以下方法，此方法将被所有子类继承 public final Class getClass() Class类的常用方法 static Class forName(String name) 返回指定类名name的Class对象 Object newInstance() 调用缺省构造函数，返回Class对象的一个实例 getName() 返回此Class对象所表示的实体（类，接口，数组类或void）的名称 Class getSuperClass() 返回当前Class对象的父类的Class对象 Class[] getInterfaces() 获取当前Class对象的接口 ClassLoader getClassLoader 返回该类的类加载器 Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组 Method getMothod(String name,Class.. T) 返回一个Method对象，此对象的形参类型为paramType Field[] getDeclaredFields() 返回Field对象的一个数组 那些类型有Class对象 class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类 interface：接口 []：数组 enum：枚举 annotation：注解@interface primitive type：基本数据类型 void java内存分析java内容： 堆 存放new的对象和数据 可以被所有的线程共享，不会存放别的对象引用 栈 存放基本变量类型（会包含这个基本类型的具体数值） 引用对象的变量（会存放这个引用在堆里面的具体地址） 方法区 可以被所有的线程共享 包含了所有的class和static变量 类的加载与ClassLoader的理解 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象 链接：将Java类的二进制代码合并到 JVM的运行状态之中的过程 验证：确保加载的类信息符合JVM规范，没有安全方面的问题 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程 初始化： 执行类构造器()方法的过程。类构造器()方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器） 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化 虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步 类初始化时间 类的主动引用（一定会发生类的初始化） 当虚拟机启动，先初始化main方法所在的类 new一个类的对象 调用类的静态成员（除了final常量）和静态方法 使用java.lang.reflect包的方法对类进行反射调用 当初始化一个类，如果其父类没有被初始化，则会先初始化它的父类 类的被动引用（不会发生类的初始化） 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） 类加载器的作用 类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后再堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象 类加载器作用是用来把类（class）装载进内存的。JVM规范定义了如下类型的类的加载器： 引导类加载器：用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库。该加载器无法直接获取 扩展类加载器：负责jre/lib/ext目录下的jar包或—D java.ext.dirs指定目录下的jar包装入工作库 系统类加载器：负责java -classpath 或—D java.class.path所指目录下的类与jar包装入工作，是最常用的加载器 获取运行时类的完整结构通过反射获取运行时类的完整结构： Field、Method、Constructor、Superclass、Interface、Annot 实现的全部接口 所继承的父类 全部的构造器 全部的方法 全部的Field 注解 。。。 动态创建对象执行方法创建类的对象：调用Class对象的newInstance()方法 类必须有一个无参数的构造器 类的构造器的访问权限需要足够 没有无参数的构造器： 通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数 通过Constructor实例化对象 调用指定的方法： 通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型 之后使用Object invoke(Object obj,Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息 setAccessible Method和Field、Constructor对象都有setAccessible方法 setAccessible作用时启动和禁用访问安全检查的开关 参数值为true则知指示反射的对象在使用时应该取消java语言访问检查 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true 使得原本无法访问的私有成员也可以访问 参数值为false则指示反射的对象应该实施java语言访问检查 性能分析 反射操作泛型（了解即可） Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型有关的类型全部擦除 为了通过反射操作这些类型，Java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型 ParameterizedType：表示一种参数化类型，如Collection GenericArrayType：表示一种元素类型时参数化类型或者类型变量的数组类型 TypeVariable：是各种类型变量的公共父接口 WildcardType：代表一种通配符类型表达式 反射操作注解 JDK8新特性Lambda表达式Lambda和匿名内部类在使用上的区别： 所需的类型不一样： 匿名内部类：需要的类型可以是类，抽象类，接口 Lambda表达式，需要的类型必须是接口 抽象方法的数量不一样 匿名内部类所需的接口中抽象方法的数量随意 Lambda表达式所需的接口只能有一个抽象方法 实现原理不同 匿名内部类是在编译后会形成class Lambda表达式是在程序运行的时候动态生成class 小结：当接口中只有一个抽象方法时，建议使用Lambda表达式，其他情况还是需要使用匿名内部类 集合之Stream流式操作接口的增强JDK8接口新增两个方法： 默认方法 静态方法 JDK8以前的接口： JDK8的接口 默认方法在JDK 8以前接口中只能有抽象方法。存在以下问题： 如果给接口新增抽象方法，所有实现类都必须重写这个抽象方法。不利于接口的扩展 因此，在JDK 8时为接口新增了默认方法，格式如下： 静态方法为了方便接口扩展，JDK 8为接口新增了静态方法 静态方法不能重写 格式如下： 默认方法和静态方法的区别 默认方法通过实例调用，静态方法通过接口名调用 默认方法可以被继承，实现类可以直接使用接口默认方法，也可以重写接口默认方法 静态方法不能被继承，实现类不能重写接口静态方法，只能使用接口名调用 小结： 如果这个方法需要被实现类继承或重写，使用默认方法，否则使用静态方法 并行数组排序Optional中避免Null检查新的时间和日期API可重复注解"}]